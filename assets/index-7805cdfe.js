var r5=Object.defineProperty;var n5=(e,t,r)=>t in e?r5(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var nc=(e,t,r)=>(n5(e,typeof t!="symbol"?t+"":t,r),r);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))n(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function r(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function n(s){if(s.ep)return;s.ep=!0;const o=r(s);fetch(s.href,o)}})();function Rr(){}function s5(e,t){for(const r in t)e[r]=t[r];return e}function lh(e){return e()}function l1(){return Object.create(null)}function Da(e){e.forEach(lh)}function fh(e){return typeof e=="function"}function Gn(e,t){return e!=e?t==t:e!==t||e&&typeof e=="object"||typeof e=="function"}function o5(e){return Object.keys(e).length===0}function a5(e,t,r,n){if(e){const s=uh(e,t,r,n);return e[0](s)}}function uh(e,t,r,n){return e[1]&&n?s5(r.ctx.slice(),e[1](n(t))):r.ctx}function i5(e,t,r,n){if(e[2]&&n){const s=e[2](n(r));if(t.dirty===void 0)return s;if(typeof s=="object"){const o=[],a=Math.max(t.dirty.length,s.length);for(let i=0;i<a;i+=1)o[i]=t.dirty[i]|s[i];return o}return t.dirty|s}return t.dirty}function c5(e,t,r,n,s,o){if(s){const a=uh(t,r,n,o);e.p(a,s)}}function l5(e){if(e.ctx.length>32){const t=[],r=e.ctx.length/32;for(let n=0;n<r;n++)t[n]=-1;return t}return-1}function Ot(e,t){e.appendChild(t)}function Fr(e,t,r){e.insertBefore(t,r||null)}function xr(e){e.parentNode&&e.parentNode.removeChild(e)}function lr(e){return document.createElement(e)}function Fn(e){return document.createTextNode(e)}function $r(){return Fn(" ")}function dh(e,t,r,n){return e.addEventListener(t,r,n),()=>e.removeEventListener(t,r,n)}function Vt(e,t,r){r==null?e.removeAttribute(t):e.getAttribute(t)!==r&&e.setAttribute(t,r)}function hh(e){return e===""?null:+e}function f5(e){return Array.from(e.childNodes)}function hl(e,t){t=""+t,e.data!==t&&(e.data=t)}function f1(e,t){e.value=t??""}let mo;function ho(e){mo=e}function u5(){if(!mo)throw new Error("Function called outside component initialization");return mo}function d5(e){u5().$$.on_mount.push(e)}const hs=[],an=[];let vs=[];const ml=[],h5=Promise.resolve();let pl=!1;function m5(){pl||(pl=!0,h5.then(mh))}function vl(e){vs.push(e)}function oo(e){ml.push(e)}const sc=new Set;let rs=0;function mh(){if(rs!==0)return;const e=mo;do{try{for(;rs<hs.length;){const t=hs[rs];rs++,ho(t),p5(t.$$)}}catch(t){throw hs.length=0,rs=0,t}for(ho(null),hs.length=0,rs=0;an.length;)an.pop()();for(let t=0;t<vs.length;t+=1){const r=vs[t];sc.has(r)||(sc.add(r),r())}vs.length=0}while(hs.length);for(;ml.length;)ml.pop()();pl=!1,sc.clear(),ho(e)}function p5(e){if(e.fragment!==null){e.update(),Da(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(vl)}}function v5(e){const t=[],r=[];vs.forEach(n=>e.indexOf(n)===-1?t.push(n):r.push(n)),r.forEach(n=>n()),vs=t}const Sa=new Set;let g5;function cr(e,t){e&&e.i&&(Sa.delete(e),e.i(t))}function dr(e,t,r,n){if(e&&e.o){if(Sa.has(e))return;Sa.add(e),g5.c.push(()=>{Sa.delete(e),n&&(r&&e.d(1),n())}),e.o(t)}else n&&n()}function ao(e,t,r){const n=e.$$.props[t];n!==void 0&&(e.$$.bound[n]=r,r(e.$$.ctx[n]))}function wr(e){e&&e.c()}function hr(e,t,r){const{fragment:n,after_update:s}=e.$$;n&&n.m(t,r),vl(()=>{const o=e.$$.on_mount.map(lh).filter(fh);e.$$.on_destroy?e.$$.on_destroy.push(...o):Da(o),e.$$.on_mount=[]}),s.forEach(vl)}function mr(e,t){const r=e.$$;r.fragment!==null&&(v5(r.after_update),Da(r.on_destroy),r.fragment&&r.fragment.d(t),r.on_destroy=r.fragment=null,r.ctx=[])}function y5(e,t){e.$$.dirty[0]===-1&&(hs.push(e),m5(),e.$$.dirty.fill(0)),e.$$.dirty[t/31|0]|=1<<t%31}function kn(e,t,r,n,s,o,a,i=[-1]){const c=mo;ho(e);const l=e.$$={fragment:null,ctx:[],props:o,update:Rr,not_equal:s,bound:l1(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(t.context||(c?c.$$.context:[])),callbacks:l1(),dirty:i,skip_bound:!1,root:t.target||c.$$.root};a&&a(l.root);let u=!1;if(l.ctx=r?r(e,t.props||{},(d,h,...m)=>{const $=m.length?m[0]:h;return l.ctx&&s(l.ctx[d],l.ctx[d]=$)&&(!l.skip_bound&&l.bound[d]&&l.bound[d]($),u&&y5(e,d)),h}):[],l.update(),u=!0,Da(l.before_update),l.fragment=n?n(l.ctx):!1,t.target){if(t.hydrate){const d=f5(t.target);l.fragment&&l.fragment.l(d),d.forEach(xr)}else l.fragment&&l.fragment.c();t.intro&&cr(e.$$.fragment),hr(e,t.target,t.anchor),mh()}ho(c)}class Dn{constructor(){nc(this,"$$");nc(this,"$$set")}$destroy(){mr(this,1),this.$destroy=Rr}$on(t,r){if(!fh(r))return Rr;const n=this.$$.callbacks[t]||(this.$$.callbacks[t]=[]);return n.push(r),()=>{const s=n.indexOf(r);s!==-1&&n.splice(s,1)}}$set(t){this.$$set&&!o5(t)&&(this.$$.skip_bound=!0,this.$$set(t),this.$$.skip_bound=!1)}}const b5="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(b5);function _5(e){let t;return{c(){t=lr("div"),t.innerHTML='<h1 class="svelte-1chc8t1">Box generator</h1> <p>A simple tool that can be used to generate custom-sized boxes/containers for 3D-printing</p>',Vt(t,"class","container svelte-1chc8t1")},m(r,n){Fr(r,t,n)},p:Rr,i:Rr,o:Rr,d(r){r&&xr(t)}}}class w5 extends Dn{constructor(t){super(),kn(this,t,null,_5,Gn,{})}}var $5=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function x5(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var E5=A5;function A5(){var e=new Float32Array(16);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var T5=S5;function S5(e){var t=new Float32Array(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}var P5=C5;function C5(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}var ph=M5;function M5(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var O5=L5;function L5(e,t){if(e===t){var r=t[1],n=t[2],s=t[3],o=t[6],a=t[7],i=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=r,e[6]=t[9],e[7]=t[13],e[8]=n,e[9]=o,e[11]=t[14],e[12]=s,e[13]=a,e[14]=i}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}var R5=F5;function F5(e,t){var r=t[0],n=t[1],s=t[2],o=t[3],a=t[4],i=t[5],c=t[6],l=t[7],u=t[8],d=t[9],h=t[10],m=t[11],$=t[12],g=t[13],y=t[14],S=t[15],N=r*i-n*a,O=r*c-s*a,L=r*l-o*a,R=n*c-s*i,F=n*l-o*i,z=s*l-o*c,J=u*g-d*$,oe=u*y-h*$,ve=u*S-m*$,le=d*y-h*g,Pe=d*S-m*g,Xe=h*S-m*y,ne=N*Xe-O*Pe+L*le+R*ve-F*oe+z*J;return ne?(ne=1/ne,e[0]=(i*Xe-c*Pe+l*le)*ne,e[1]=(s*Pe-n*Xe-o*le)*ne,e[2]=(g*z-y*F+S*R)*ne,e[3]=(h*F-d*z-m*R)*ne,e[4]=(c*ve-a*Xe-l*oe)*ne,e[5]=(r*Xe-s*ve+o*oe)*ne,e[6]=(y*L-$*z-S*O)*ne,e[7]=(u*z-h*L+m*O)*ne,e[8]=(a*Pe-i*ve+l*J)*ne,e[9]=(n*ve-r*Pe-o*J)*ne,e[10]=($*F-g*L+S*N)*ne,e[11]=(d*L-u*F-m*N)*ne,e[12]=(i*oe-a*le-c*J)*ne,e[13]=(r*le-n*oe+s*J)*ne,e[14]=(g*O-$*R-y*N)*ne,e[15]=(u*R-d*O+h*N)*ne,e):null}var N5=G5;function G5(e,t){var r=t[0],n=t[1],s=t[2],o=t[3],a=t[4],i=t[5],c=t[6],l=t[7],u=t[8],d=t[9],h=t[10],m=t[11],$=t[12],g=t[13],y=t[14],S=t[15];return e[0]=i*(h*S-m*y)-d*(c*S-l*y)+g*(c*m-l*h),e[1]=-(n*(h*S-m*y)-d*(s*S-o*y)+g*(s*m-o*h)),e[2]=n*(c*S-l*y)-i*(s*S-o*y)+g*(s*l-o*c),e[3]=-(n*(c*m-l*h)-i*(s*m-o*h)+d*(s*l-o*c)),e[4]=-(a*(h*S-m*y)-u*(c*S-l*y)+$*(c*m-l*h)),e[5]=r*(h*S-m*y)-u*(s*S-o*y)+$*(s*m-o*h),e[6]=-(r*(c*S-l*y)-a*(s*S-o*y)+$*(s*l-o*c)),e[7]=r*(c*m-l*h)-a*(s*m-o*h)+u*(s*l-o*c),e[8]=a*(d*S-m*g)-u*(i*S-l*g)+$*(i*m-l*d),e[9]=-(r*(d*S-m*g)-u*(n*S-o*g)+$*(n*m-o*d)),e[10]=r*(i*S-l*g)-a*(n*S-o*g)+$*(n*l-o*i),e[11]=-(r*(i*m-l*d)-a*(n*m-o*d)+u*(n*l-o*i)),e[12]=-(a*(d*y-h*g)-u*(i*y-c*g)+$*(i*h-c*d)),e[13]=r*(d*y-h*g)-u*(n*y-s*g)+$*(n*h-s*d),e[14]=-(r*(i*y-c*g)-a*(n*y-s*g)+$*(n*c-s*i)),e[15]=r*(i*h-c*d)-a*(n*h-s*d)+u*(n*c-s*i),e}var k5=D5;function D5(e){var t=e[0],r=e[1],n=e[2],s=e[3],o=e[4],a=e[5],i=e[6],c=e[7],l=e[8],u=e[9],d=e[10],h=e[11],m=e[12],$=e[13],g=e[14],y=e[15],S=t*a-r*o,N=t*i-n*o,O=t*c-s*o,L=r*i-n*a,R=r*c-s*a,F=n*c-s*i,z=l*$-u*m,J=l*g-d*m,oe=l*y-h*m,ve=u*g-d*$,le=u*y-h*$,Pe=d*y-h*g;return S*Pe-N*le+O*ve+L*oe-R*J+F*z}var B5=I5;function I5(e,t,r){var n=t[0],s=t[1],o=t[2],a=t[3],i=t[4],c=t[5],l=t[6],u=t[7],d=t[8],h=t[9],m=t[10],$=t[11],g=t[12],y=t[13],S=t[14],N=t[15],O=r[0],L=r[1],R=r[2],F=r[3];return e[0]=O*n+L*i+R*d+F*g,e[1]=O*s+L*c+R*h+F*y,e[2]=O*o+L*l+R*m+F*S,e[3]=O*a+L*u+R*$+F*N,O=r[4],L=r[5],R=r[6],F=r[7],e[4]=O*n+L*i+R*d+F*g,e[5]=O*s+L*c+R*h+F*y,e[6]=O*o+L*l+R*m+F*S,e[7]=O*a+L*u+R*$+F*N,O=r[8],L=r[9],R=r[10],F=r[11],e[8]=O*n+L*i+R*d+F*g,e[9]=O*s+L*c+R*h+F*y,e[10]=O*o+L*l+R*m+F*S,e[11]=O*a+L*u+R*$+F*N,O=r[12],L=r[13],R=r[14],F=r[15],e[12]=O*n+L*i+R*d+F*g,e[13]=O*s+L*c+R*h+F*y,e[14]=O*o+L*l+R*m+F*S,e[15]=O*a+L*u+R*$+F*N,e}var V5=z5;function z5(e,t,r){var n=r[0],s=r[1],o=r[2],a,i,c,l,u,d,h,m,$,g,y,S;return t===e?(e[12]=t[0]*n+t[4]*s+t[8]*o+t[12],e[13]=t[1]*n+t[5]*s+t[9]*o+t[13],e[14]=t[2]*n+t[6]*s+t[10]*o+t[14],e[15]=t[3]*n+t[7]*s+t[11]*o+t[15]):(a=t[0],i=t[1],c=t[2],l=t[3],u=t[4],d=t[5],h=t[6],m=t[7],$=t[8],g=t[9],y=t[10],S=t[11],e[0]=a,e[1]=i,e[2]=c,e[3]=l,e[4]=u,e[5]=d,e[6]=h,e[7]=m,e[8]=$,e[9]=g,e[10]=y,e[11]=S,e[12]=a*n+u*s+$*o+t[12],e[13]=i*n+d*s+g*o+t[13],e[14]=c*n+h*s+y*o+t[14],e[15]=l*n+m*s+S*o+t[15]),e}var U5=q5;function q5(e,t,r){var n=r[0],s=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=t[7]*s,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}var X5=j5;function j5(e,t,r,n){var s=n[0],o=n[1],a=n[2],i=Math.sqrt(s*s+o*o+a*a),c,l,u,d,h,m,$,g,y,S,N,O,L,R,F,z,J,oe,ve,le,Pe,Xe,ne,Ne;return Math.abs(i)<1e-6?null:(i=1/i,s*=i,o*=i,a*=i,c=Math.sin(r),l=Math.cos(r),u=1-l,d=t[0],h=t[1],m=t[2],$=t[3],g=t[4],y=t[5],S=t[6],N=t[7],O=t[8],L=t[9],R=t[10],F=t[11],z=s*s*u+l,J=o*s*u+a*c,oe=a*s*u-o*c,ve=s*o*u-a*c,le=o*o*u+l,Pe=a*o*u+s*c,Xe=s*a*u+o*c,ne=o*a*u-s*c,Ne=a*a*u+l,e[0]=d*z+g*J+O*oe,e[1]=h*z+y*J+L*oe,e[2]=m*z+S*J+R*oe,e[3]=$*z+N*J+F*oe,e[4]=d*ve+g*le+O*Pe,e[5]=h*ve+y*le+L*Pe,e[6]=m*ve+S*le+R*Pe,e[7]=$*ve+N*le+F*Pe,e[8]=d*Xe+g*ne+O*Ne,e[9]=h*Xe+y*ne+L*Ne,e[10]=m*Xe+S*ne+R*Ne,e[11]=$*Xe+N*ne+F*Ne,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}var H5=Y5;function Y5(e,t,r){var n=Math.sin(r),s=Math.cos(r),o=t[4],a=t[5],i=t[6],c=t[7],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*s+l*n,e[5]=a*s+u*n,e[6]=i*s+d*n,e[7]=c*s+h*n,e[8]=l*s-o*n,e[9]=u*s-a*n,e[10]=d*s-i*n,e[11]=h*s-c*n,e}var W5=Z5;function Z5(e,t,r){var n=Math.sin(r),s=Math.cos(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s-l*n,e[1]=a*s-u*n,e[2]=i*s-d*n,e[3]=c*s-h*n,e[8]=o*n+l*s,e[9]=a*n+u*s,e[10]=i*n+d*s,e[11]=c*n+h*s,e}var Q5=K5;function K5(e,t,r){var n=Math.sin(r),s=Math.cos(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[4],u=t[5],d=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s+l*n,e[1]=a*s+u*n,e[2]=i*s+d*n,e[3]=c*s+h*n,e[4]=l*s-o*n,e[5]=u*s-a*n,e[6]=d*s-i*n,e[7]=h*s-c*n,e}var J5=ey;function ey(e,t,r){var n,s,o,a=r[0],i=r[1],c=r[2],l=Math.sqrt(a*a+i*i+c*c);return Math.abs(l)<1e-6?null:(l=1/l,a*=l,i*=l,c*=l,n=Math.sin(t),s=Math.cos(t),o=1-s,e[0]=a*a*o+s,e[1]=i*a*o+c*n,e[2]=c*a*o-i*n,e[3]=0,e[4]=a*i*o-c*n,e[5]=i*i*o+s,e[6]=c*i*o+a*n,e[7]=0,e[8]=a*c*o+i*n,e[9]=i*c*o-a*n,e[10]=c*c*o+s,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}var ty=ry;function ry(e,t,r){var n=t[0],s=t[1],o=t[2],a=t[3],i=n+n,c=s+s,l=o+o,u=n*i,d=n*c,h=n*l,m=s*c,$=s*l,g=o*l,y=a*i,S=a*c,N=a*l;return e[0]=1-(m+g),e[1]=d+N,e[2]=h-S,e[3]=0,e[4]=d-N,e[5]=1-(u+g),e[6]=$+y,e[7]=0,e[8]=h+S,e[9]=$-y,e[10]=1-(u+m),e[11]=0,e[12]=r[0],e[13]=r[1],e[14]=r[2],e[15]=1,e}var ny=sy;function sy(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var oy=ay;function ay(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}var iy=cy;function cy(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var ly=fy;function fy(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var uy=dy;function dy(e,t){var r=Math.sin(t),n=Math.cos(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var hy=my;function my(e,t){var r=t[0],n=t[1],s=t[2],o=t[3],a=r+r,i=n+n,c=s+s,l=r*a,u=n*a,d=n*i,h=s*a,m=s*i,$=s*c,g=o*a,y=o*i,S=o*c;return e[0]=1-d-$,e[1]=u+S,e[2]=h-y,e[3]=0,e[4]=u-S,e[5]=1-l-$,e[6]=m+g,e[7]=0,e[8]=h+y,e[9]=m-g,e[10]=1-l-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}var py=vy;function vy(e,t,r,n,s,o,a){var i=1/(r-t),c=1/(s-n),l=1/(o-a);return e[0]=o*2*i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o*2*c,e[6]=0,e[7]=0,e[8]=(r+t)*i,e[9]=(s+n)*c,e[10]=(a+o)*l,e[11]=-1,e[12]=0,e[13]=0,e[14]=a*o*2*l,e[15]=0,e}var gy=yy;function yy(e,t,r,n,s){var o=1/Math.tan(t/2),a=1/(n-s);return e[0]=o/r,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=o,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=(s+n)*a,e[11]=-1,e[12]=0,e[13]=0,e[14]=2*s*n*a,e[15]=0,e}var by=_y;function _y(e,t,r,n){var s=Math.tan(t.upDegrees*Math.PI/180),o=Math.tan(t.downDegrees*Math.PI/180),a=Math.tan(t.leftDegrees*Math.PI/180),i=Math.tan(t.rightDegrees*Math.PI/180),c=2/(a+i),l=2/(s+o);return e[0]=c,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=l,e[6]=0,e[7]=0,e[8]=-((a-i)*c*.5),e[9]=(s-o)*l*.5,e[10]=n/(r-n),e[11]=-1,e[12]=0,e[13]=0,e[14]=n*r/(r-n),e[15]=0,e}var wy=$y;function $y(e,t,r,n,s,o,a){var i=1/(t-r),c=1/(n-s),l=1/(o-a);return e[0]=-2*i,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*c,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*l,e[11]=0,e[12]=(t+r)*i,e[13]=(s+n)*c,e[14]=(a+o)*l,e[15]=1,e}var xy=ph,Ey=Ay;function Ay(e,t,r,n){var s,o,a,i,c,l,u,d,h,m,$=t[0],g=t[1],y=t[2],S=n[0],N=n[1],O=n[2],L=r[0],R=r[1],F=r[2];return Math.abs($-L)<1e-6&&Math.abs(g-R)<1e-6&&Math.abs(y-F)<1e-6?xy(e):(u=$-L,d=g-R,h=y-F,m=1/Math.sqrt(u*u+d*d+h*h),u*=m,d*=m,h*=m,s=N*h-O*d,o=O*u-S*h,a=S*d-N*u,m=Math.sqrt(s*s+o*o+a*a),m?(m=1/m,s*=m,o*=m,a*=m):(s=0,o=0,a=0),i=d*a-h*o,c=h*s-u*a,l=u*o-d*s,m=Math.sqrt(i*i+c*c+l*l),m?(m=1/m,i*=m,c*=m,l*=m):(i=0,c=0,l=0),e[0]=s,e[1]=i,e[2]=u,e[3]=0,e[4]=o,e[5]=c,e[6]=d,e[7]=0,e[8]=a,e[9]=l,e[10]=h,e[11]=0,e[12]=-(s*$+o*g+a*y),e[13]=-(i*$+c*g+l*y),e[14]=-(u*$+d*g+h*y),e[15]=1,e)}var Ty=Sy;function Sy(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}var pr={create:E5,clone:T5,copy:P5,identity:ph,transpose:O5,invert:R5,adjoint:N5,determinant:k5,multiply:B5,translate:V5,scale:U5,rotate:X5,rotateX:H5,rotateY:W5,rotateZ:Q5,fromRotation:J5,fromRotationTranslation:ty,fromScaling:ny,fromTranslation:oy,fromXRotation:iy,fromYRotation:ly,fromZRotation:uy,fromQuat:hy,frustum:py,perspective:gy,perspectiveFromFieldOfView:by,ortho:wy,lookAt:Ey,str:Ty};const oc=pr,Py=(e,t={})=>{const{fbo:r}=t,n={cull:{enable:!0},context:{lightDirection:[.2,.2,1]},uniforms:{view:(s,o)=>o.camera.view,eye:(s,o)=>o.camera.position,projection:(s,o)=>o.camera.projection,camNear:(s,o)=>o.camera.near,camFar:(s,o)=>o.camera.far,invertedView:(s,o)=>oc.invert([],o.camera.view),lightPosition:(s,o)=>o&&o.rendering&&o.rendering.lightPosition?o.rendering.lightPosition:[100,200,100],lightDirection:(s,o)=>o&&o.rendering&&o.rendering.lightDirection?o.rendering.lightDirection:s.lightDirection||[0,0,0],lightView:s=>oc.lookAt([],s.lightDirection,[0,0,0],[0,0,1]),lightProjection:oc.ortho([],-25,-25,-20,20,-25,25),lightColor:(s,o)=>o&&o.rendering&&o.rendering.lightColor?o.rendering.lightColor:[1,.8,0],ambientLightAmount:(s,o)=>o&&o.rendering&&o.rendering.ambientLightAmount?o.rendering.ambientLightAmount:.3,diffuseLightAmount:(s,o)=>o&&o.rendering&&o.rendering.diffuseLightAmount?o&&o.rendering&&o.rendering.diffuseLightAmount:.89,specularLightAmount:(s,o)=>o&&o.rendering&&o.rendering.specularLightAmount?o.rendering.specularLightAmount:.16,uMaterialShininess:(s,o)=>o&&o.rendering&&o.rendering.materialShininess?o.rendering.materialShininess:8,materialAmbient:[.5,.8,.3],materialDiffuse:[.5,.8,.3],materialSpecular:[.5,.8,.3]},framebuffer:r};return e(Object.assign({},n,t.extras))};var Cy=Py,Ba={background:[1,1,1,1],meshColor:[0,.6,1,1],lightColor:[1,1,1,1],lightDirection:[.2,.2,1],lightPosition:[100,200,100],ambientLightAmount:.3,diffuseLightAmount:.89,specularLightAmount:.16,materialShininess:8},ac={exports:{}},u1;function My(){return u1||(u1=1,function(e,t){(function(r,n){e.exports=n()})($5,function(){var r=function(f){return f instanceof Uint8Array||f instanceof Uint16Array||f instanceof Uint32Array||f instanceof Int8Array||f instanceof Int16Array||f instanceof Int32Array||f instanceof Float32Array||f instanceof Float64Array||f instanceof Uint8ClampedArray},n=function(f,v){for(var T=Object.keys(v),X=0;X<T.length;++X)f[T[X]]=v[T[X]];return f},s=`
`;function o(f){return typeof atob<"u"?atob(f):"base64:"+f}function a(f){var v=new Error("(regl) "+f);throw console.error(v),v}function i(f,v){f||a(v)}function c(f){return f?": "+f:""}function l(f,v,T){f in v||a("unknown parameter ("+f+")"+c(T)+". possible values: "+Object.keys(v).join())}function u(f,v){r(f)||a("invalid parameter type"+c(v)+". must be a typed array")}function d(f,v){switch(v){case"number":return typeof f=="number";case"object":return typeof f=="object";case"string":return typeof f=="string";case"boolean":return typeof f=="boolean";case"function":return typeof f=="function";case"undefined":return typeof f>"u";case"symbol":return typeof f=="symbol"}}function h(f,v,T){d(f,v)||a("invalid parameter type"+c(T)+". expected "+v+", got "+typeof f)}function m(f,v){f>=0&&(f|0)===f||a("invalid parameter type, ("+f+")"+c(v)+". must be a nonnegative integer")}function $(f,v,T){v.indexOf(f)<0&&a("invalid value"+c(T)+". must be one of: "+v)}var g=["gl","canvas","container","attributes","pixelRatio","extensions","optionalExtensions","profile","onDone"];function y(f){Object.keys(f).forEach(function(v){g.indexOf(v)<0&&a('invalid regl constructor argument "'+v+'". must be one of '+g)})}function S(f,v){for(f=f+"";f.length<v;)f=" "+f;return f}function N(){this.name="unknown",this.lines=[],this.index={},this.hasErrors=!1}function O(f,v){this.number=f,this.line=v,this.errors=[]}function L(f,v,T){this.file=f,this.line=v,this.message=T}function R(){var f=new Error,v=(f.stack||f).toString(),T=/compileProcedure.*\n\s*at.*\((.*)\)/.exec(v);if(T)return T[1];var X=/compileProcedure.*\n\s*at\s+(.*)(\n|$)/.exec(v);return X?X[1]:"unknown"}function F(){var f=new Error,v=(f.stack||f).toString(),T=/at REGLCommand.*\n\s+at.*\((.*)\)/.exec(v);if(T)return T[1];var X=/at REGLCommand.*\n\s+at\s+(.*)\n/.exec(v);return X?X[1]:"unknown"}function z(f,v){var T=f.split(`
`),X=1,K=0,q={unknown:new N,0:new N};q.unknown.name=q[0].name=v||R(),q.unknown.lines.push(new O(0,""));for(var Y=0;Y<T.length;++Y){var ie=T[Y],ae=/^\s*#\s*(\w+)\s+(.+)\s*$/.exec(ie);if(ae)switch(ae[1]){case"line":var he=/(\d+)(\s+\d+)?/.exec(ae[2]);he&&(X=he[1]|0,he[2]&&(K=he[2]|0,K in q||(q[K]=new N)));break;case"define":var pe=/SHADER_NAME(_B64)?\s+(.*)$/.exec(ae[2]);pe&&(q[K].name=pe[1]?o(pe[2]):pe[2]);break}q[K].lines.push(new O(X++,ie))}return Object.keys(q).forEach(function(me){var ye=q[me];ye.lines.forEach(function(ce){ye.index[ce.number]=ce})}),q}function J(f){var v=[];return f.split(`
`).forEach(function(T){if(!(T.length<5)){var X=/^ERROR:\s+(\d+):(\d+):\s*(.*)$/.exec(T);X?v.push(new L(X[1]|0,X[2]|0,X[3].trim())):T.length>0&&v.push(new L("unknown",0,T))}}),v}function oe(f,v){v.forEach(function(T){var X=f[T.file];if(X){var K=X.index[T.line];if(K){K.errors.push(T),X.hasErrors=!0;return}}f.unknown.hasErrors=!0,f.unknown.lines[0].errors.push(T)})}function ve(f,v,T,X,K){if(!f.getShaderParameter(v,f.COMPILE_STATUS)){var q=f.getShaderInfoLog(v),Y=X===f.FRAGMENT_SHADER?"fragment":"vertex";bt(T,"string",Y+" shader source must be a string",K);var ie=z(T,K),ae=J(q);oe(ie,ae),Object.keys(ie).forEach(function(he){var pe=ie[he];if(!pe.hasErrors)return;var me=[""],ye=[""];function ce(de,D){me.push(de),ye.push(D||"")}ce("file number "+he+": "+pe.name+`
`,"color:red;text-decoration:underline;font-weight:bold"),pe.lines.forEach(function(de){if(de.errors.length>0){ce(S(de.number,4)+"|  ","background-color:yellow; font-weight:bold"),ce(de.line+s,"color:red; background-color:yellow; font-weight:bold");var D=0;de.errors.forEach(function(H){var ue=H.message,Te=/^\s*'(.*)'\s*:\s*(.*)$/.exec(ue);if(Te){var se=Te[1];switch(ue=Te[2],se){case"assign":se="=";break}D=Math.max(de.line.indexOf(se,D),0)}else D=0;ce(S("| ",6)),ce(S("^^^",D+3)+s,"font-weight:bold"),ce(S("| ",6)),ce(ue+s,"font-weight:bold")}),ce(S("| ",6)+s)}else ce(S(de.number,4)+"|  "),ce(de.line+s,"color:red")}),typeof document<"u"&&!window.chrome?(ye[0]=me.join("%c"),console.log.apply(console,ye)):console.log(me.join(""))}),i.raise("Error compiling "+Y+" shader, "+ie[0].name)}}function le(f,v,T,X,K){if(!f.getProgramParameter(v,f.LINK_STATUS)){var q=f.getProgramInfoLog(v),Y=z(T,K),ie=z(X,K),ae='Error linking program with vertex shader, "'+ie[0].name+'", and fragment shader "'+Y[0].name+'"';typeof document<"u"?console.log("%c"+ae+s+"%c"+q,"color:red;text-decoration:underline;font-weight:bold","color:red"):console.log(ae+s+q),i.raise(ae)}}function Pe(f){f._commandRef=R()}function Xe(f,v,T,X){Pe(f);function K(ae){return ae?X.id(ae):0}f._fragId=K(f.static.frag),f._vertId=K(f.static.vert);function q(ae,he){Object.keys(he).forEach(function(pe){ae[X.id(pe)]=!0})}var Y=f._uniformSet={};q(Y,v.static),q(Y,v.dynamic);var ie=f._attributeSet={};q(ie,T.static),q(ie,T.dynamic),f._hasCount="count"in f.static||"count"in f.dynamic||"elements"in f.static||"elements"in f.dynamic}function ne(f,v){var T=F();a(f+" in command "+(v||R())+(T==="unknown"?"":" called from "+T))}function Ne(f,v,T){f||ne(v,T||R())}function Ge(f,v,T,X){f in v||ne("unknown parameter ("+f+")"+c(T)+". possible values: "+Object.keys(v).join(),X||R())}function bt(f,v,T,X){d(f,v)||ne("invalid parameter type"+c(T)+". expected "+v+", got "+typeof f,X||R())}function xt(f){f()}function vr(f,v,T){f.texture?$(f.texture._texture.internalformat,v,"unsupported texture format for attachment"):$(f.renderbuffer._renderbuffer.format,T,"unsupported renderbuffer format for attachment")}var Kt=33071,gr=9728,Jt=9984,Mp=9985,Op=9986,Lp=9987,Rp=5120,Fp=5121,Np=5122,Gp=5123,kp=5124,Dp=5125,sf=5126,of=32819,af=32820,cf=33635,lf=34042,Bp=36193,er={};er[Rp]=er[Fp]=1,er[Np]=er[Gp]=er[Bp]=er[cf]=er[of]=er[af]=2,er[kp]=er[Dp]=er[sf]=er[lf]=4;function ff(f,v){return f===af||f===of||f===cf?2:f===lf?4:er[f]*v}function Ao(f){return!(f&f-1)&&!!f}function Ip(f,v,T){var X,K=v.width,q=v.height,Y=v.channels;i(K>0&&K<=T.maxTextureSize&&q>0&&q<=T.maxTextureSize,"invalid texture shape"),(f.wrapS!==Kt||f.wrapT!==Kt)&&i(Ao(K)&&Ao(q),"incompatible wrap mode for texture, both width and height must be power of 2"),v.mipmask===1?K!==1&&q!==1&&i(f.minFilter!==Jt&&f.minFilter!==Op&&f.minFilter!==Mp&&f.minFilter!==Lp,"min filter requires mipmap"):(i(Ao(K)&&Ao(q),"texture must be a square power of 2 to support mipmapping"),i(v.mipmask===(K<<1)-1,"missing or incomplete mipmap data")),v.type===sf&&(T.extensions.indexOf("oes_texture_float_linear")<0&&i(f.minFilter===gr&&f.magFilter===gr,"filter not supported, must enable oes_texture_float_linear"),i(!f.genMipmaps,"mipmap generation not supported with float textures"));var ie=v.images;for(X=0;X<16;++X)if(ie[X]){var ae=K>>X,he=q>>X;i(v.mipmask&1<<X,"missing mipmap data");var pe=ie[X];if(i(pe.width===ae&&pe.height===he,"invalid shape for mip images"),i(pe.format===v.format&&pe.internalformat===v.internalformat&&pe.type===v.type,"incompatible type for mip image"),!pe.compressed)if(pe.data){var me=Math.ceil(ff(pe.type,Y)*ae/pe.unpackAlignment)*pe.unpackAlignment;i(pe.data.byteLength===me*he,"invalid data for image, buffer size is inconsistent with image format")}else pe.element||pe.copy}else f.genMipmaps||i((v.mipmask&1<<X)===0,"extra mipmap data");v.compressed&&i(!f.genMipmaps,"mipmap generation for compressed images not supported")}function Vp(f,v,T,X){var K=f.width,q=f.height,Y=f.channels;i(K>0&&K<=X.maxTextureSize&&q>0&&q<=X.maxTextureSize,"invalid texture shape"),i(K===q,"cube map must be square"),i(v.wrapS===Kt&&v.wrapT===Kt,"wrap mode not supported by cube map");for(var ie=0;ie<T.length;++ie){var ae=T[ie];i(ae.width===K&&ae.height===q,"inconsistent cube map face shape"),v.genMipmaps&&(i(!ae.compressed,"can not generate mipmap for compressed textures"),i(ae.mipmask===1,"can not specify mipmaps and generate mipmaps"));for(var he=ae.images,pe=0;pe<16;++pe){var me=he[pe];if(me){var ye=K>>pe,ce=q>>pe;i(ae.mipmask&1<<pe,"missing mipmap data"),i(me.width===ye&&me.height===ce,"invalid shape for mip images"),i(me.format===f.format&&me.internalformat===f.internalformat&&me.type===f.type,"incompatible type for mip image"),me.compressed||(me.data?i(me.data.byteLength===ye*ce*Math.max(ff(me.type,Y),me.unpackAlignment),"invalid data for image, buffer size is inconsistent with image format"):me.element||me.copy)}}}}var b=n(i,{optional:xt,raise:a,commandRaise:ne,command:Ne,parameter:l,commandParameter:Ge,constructor:y,type:h,commandType:bt,isTypedArray:u,nni:m,oneOf:$,shaderError:ve,linkError:le,callSite:F,saveCommandRef:Pe,saveDrawInfo:Xe,framebufferFormat:vr,guessCommand:R,texture2D:Ip,textureCube:Vp}),zp=0,Up=0,qp=5,Xp=6;function ln(f,v){this.id=zp++,this.type=f,this.data=v}function uf(f){return f.replace(/\\/g,"\\\\").replace(/"/g,'\\"')}function Ps(f){if(f.length===0)return[];var v=f.charAt(0),T=f.charAt(f.length-1);if(f.length>1&&v===T&&(v==='"'||v==="'"))return['"'+uf(f.substr(1,f.length-2))+'"'];var X=/\[(false|true|null|\d+|'[^']*'|"[^"]*")\]/.exec(f);if(X)return Ps(f.substr(0,X.index)).concat(Ps(X[1])).concat(Ps(f.substr(X.index+X[0].length)));var K=f.split(".");if(K.length===1)return['"'+uf(f)+'"'];for(var q=[],Y=0;Y<K.length;++Y)q=q.concat(Ps(K[Y]));return q}function df(f){return"["+Ps(f).join("][")+"]"}function jp(f,v){return new ln(f,df(v+""))}function Hp(f){return typeof f=="function"&&!f._reglType||f instanceof ln}function hf(f,v){if(typeof f=="function")return new ln(Up,f);if(typeof f=="number"||typeof f=="boolean")return new ln(qp,f);if(Array.isArray(f))return new ln(Xp,f.map(function(T,X){return hf(T,v+"["+X+"]")}));if(f instanceof ln)return f;b(!1,"invalid option type in uniform "+v)}var tr={DynamicVariable:ln,define:jp,isDynamic:Hp,unbox:hf,accessor:df},ai={next:typeof requestAnimationFrame=="function"?function(f){return requestAnimationFrame(f)}:function(f){return setTimeout(f,16)},cancel:typeof cancelAnimationFrame=="function"?function(f){return cancelAnimationFrame(f)}:clearTimeout},mf=typeof performance<"u"&&performance.now?function(){return performance.now()}:function(){return+new Date};function Yp(){var f={"":0},v=[""];return{id:function(T){var X=f[T];return X||(X=f[T]=v.length,v.push(T),X)},str:function(T){return v[T]}}}function Wp(f,v,T){var X=document.createElement("canvas");n(X.style,{border:0,margin:0,padding:0,top:0,left:0,width:"100%",height:"100%"}),f.appendChild(X),f===document.body&&(X.style.position="absolute",n(f.style,{margin:0,padding:0}));function K(){var ie=window.innerWidth,ae=window.innerHeight;if(f!==document.body){var he=X.getBoundingClientRect();ie=he.right-he.left,ae=he.bottom-he.top}X.width=T*ie,X.height=T*ae}var q;f!==document.body&&typeof ResizeObserver=="function"?(q=new ResizeObserver(function(){setTimeout(K)}),q.observe(f)):window.addEventListener("resize",K,!1);function Y(){q?q.disconnect():window.removeEventListener("resize",K),f.removeChild(X)}return K(),{canvas:X,onDestroy:Y}}function Zp(f,v){function T(X){try{return f.getContext(X,v)}catch{return null}}return T("webgl")||T("experimental-webgl")||T("webgl-experimental")}function Qp(f){return typeof f.nodeName=="string"&&typeof f.appendChild=="function"&&typeof f.getBoundingClientRect=="function"}function Kp(f){return typeof f.drawArrays=="function"||typeof f.drawElements=="function"}function pf(f){return typeof f=="string"?f.split():(b(Array.isArray(f),"invalid extension array"),f)}function vf(f){return typeof f=="string"?(b(typeof document<"u","not supported outside of DOM"),document.querySelector(f)):f}function Jp(f){var v=f||{},T,X,K,q,Y={},ie=[],ae=[],he=typeof window>"u"?1:window.devicePixelRatio,pe=!1,me=function(de){de&&b.raise(de)},ye=function(){};if(typeof v=="string"?(b(typeof document<"u","selector queries only supported in DOM enviroments"),T=document.querySelector(v),b(T,"invalid query string for element")):typeof v=="object"?Qp(v)?T=v:Kp(v)?(q=v,K=q.canvas):(b.constructor(v),"gl"in v?q=v.gl:"canvas"in v?K=vf(v.canvas):"container"in v&&(X=vf(v.container)),"attributes"in v&&(Y=v.attributes,b.type(Y,"object","invalid context attributes")),"extensions"in v&&(ie=pf(v.extensions)),"optionalExtensions"in v&&(ae=pf(v.optionalExtensions)),"onDone"in v&&(b.type(v.onDone,"function","invalid or missing onDone callback"),me=v.onDone),"profile"in v&&(pe=!!v.profile),"pixelRatio"in v&&(he=+v.pixelRatio,b(he>0,"invalid pixel ratio"))):b.raise("invalid arguments to regl"),T&&(T.nodeName.toLowerCase()==="canvas"?K=T:X=T),!q){if(!K){b(typeof document<"u","must manually specify webgl context outside of DOM environments");var ce=Wp(X||document.body,me,he);if(!ce)return null;K=ce.canvas,ye=ce.onDestroy}Y.premultipliedAlpha===void 0&&(Y.premultipliedAlpha=!0),q=Zp(K,Y)}return q?{gl:q,canvas:K,container:X,extensions:ie,optionalExtensions:ae,pixelRatio:he,profile:pe,onDone:me,onDestroy:ye}:(ye(),me("webgl not supported, try upgrading your browser or graphics drivers http://get.webgl.org"),null)}function ev(f,v){var T={};function X(Y){b.type(Y,"string","extension name must be string");var ie=Y.toLowerCase(),ae;try{ae=T[ie]=f.getExtension(ie)}catch{}return!!ae}for(var K=0;K<v.extensions.length;++K){var q=v.extensions[K];if(!X(q))return v.onDestroy(),v.onDone('"'+q+'" extension is not supported by the current WebGL context, try upgrading your system or a different browser'),null}return v.optionalExtensions.forEach(X),{extensions:T,restore:function(){Object.keys(T).forEach(function(Y){if(T[Y]&&!X(Y))throw new Error("(regl): error restoring extension "+Y)})}}}function rr(f,v){for(var T=Array(f),X=0;X<f;++X)T[X]=v(X);return T}var tv=5120,rv=5121,nv=5122,sv=5123,ov=5124,av=5125,iv=5126;function cv(f){for(var v=16;v<=1<<28;v*=16)if(f<=v)return v;return 0}function gf(f){var v,T;return v=(f>65535)<<4,f>>>=v,T=(f>255)<<3,f>>>=T,v|=T,T=(f>15)<<2,f>>>=T,v|=T,T=(f>3)<<1,f>>>=T,v|=T,v|f>>1}function yf(){var f=rr(8,function(){return[]});function v(q){var Y=cv(q),ie=f[gf(Y)>>2];return ie.length>0?ie.pop():new ArrayBuffer(Y)}function T(q){f[gf(q.byteLength)>>2].push(q)}function X(q,Y){var ie=null;switch(q){case tv:ie=new Int8Array(v(Y),0,Y);break;case rv:ie=new Uint8Array(v(Y),0,Y);break;case nv:ie=new Int16Array(v(2*Y),0,Y);break;case sv:ie=new Uint16Array(v(2*Y),0,Y);break;case ov:ie=new Int32Array(v(4*Y),0,Y);break;case av:ie=new Uint32Array(v(4*Y),0,Y);break;case iv:ie=new Float32Array(v(4*Y),0,Y);break;default:return null}return ie.length!==Y?ie.subarray(0,Y):ie}function K(q){T(q.buffer)}return{alloc:v,free:T,allocType:X,freeType:K}}var _t=yf();_t.zero=yf();var lv=3408,fv=3410,uv=3411,dv=3412,hv=3413,mv=3414,pv=3415,vv=33901,gv=33902,yv=3379,bv=3386,_v=34921,wv=36347,$v=36348,xv=35661,Ev=35660,Av=34930,Tv=36349,Sv=34076,Pv=34024,Cv=7936,Mv=7937,Ov=7938,Lv=35724,Rv=34047,Fv=36063,Nv=34852,To=3553,bf=34067,Gv=34069,kv=33984,Cs=6408,ii=5126,_f=5121,ci=36160,Dv=36053,Bv=36064,Iv=16384,Vv=function(f,v){var T=1;v.ext_texture_filter_anisotropic&&(T=f.getParameter(Rv));var X=1,K=1;v.webgl_draw_buffers&&(X=f.getParameter(Nv),K=f.getParameter(Fv));var q=!!v.oes_texture_float;if(q){var Y=f.createTexture();f.bindTexture(To,Y),f.texImage2D(To,0,Cs,1,1,0,Cs,ii,null);var ie=f.createFramebuffer();if(f.bindFramebuffer(ci,ie),f.framebufferTexture2D(ci,Bv,To,Y,0),f.bindTexture(To,null),f.checkFramebufferStatus(ci)!==Dv)q=!1;else{f.viewport(0,0,1,1),f.clearColor(1,0,0,1),f.clear(Iv);var ae=_t.allocType(ii,4);f.readPixels(0,0,1,1,Cs,ii,ae),f.getError()?q=!1:(f.deleteFramebuffer(ie),f.deleteTexture(Y),q=ae[0]===1),_t.freeType(ae)}}var he=typeof navigator<"u"&&(/MSIE/.test(navigator.userAgent)||/Trident\//.test(navigator.appVersion)||/Edge/.test(navigator.userAgent)),pe=!0;if(!he){var me=f.createTexture(),ye=_t.allocType(_f,36);f.activeTexture(kv),f.bindTexture(bf,me),f.texImage2D(Gv,0,Cs,3,3,0,Cs,_f,ye),_t.freeType(ye),f.bindTexture(bf,null),f.deleteTexture(me),pe=!f.getError()}return{colorBits:[f.getParameter(fv),f.getParameter(uv),f.getParameter(dv),f.getParameter(hv)],depthBits:f.getParameter(mv),stencilBits:f.getParameter(pv),subpixelBits:f.getParameter(lv),extensions:Object.keys(v).filter(function(ce){return!!v[ce]}),maxAnisotropic:T,maxDrawbuffers:X,maxColorAttachments:K,pointSizeDims:f.getParameter(vv),lineWidthDims:f.getParameter(gv),maxViewportDims:f.getParameter(bv),maxCombinedTextureUnits:f.getParameter(xv),maxCubeMapSize:f.getParameter(Sv),maxRenderbufferSize:f.getParameter(Pv),maxTextureUnits:f.getParameter(Av),maxTextureSize:f.getParameter(yv),maxAttributes:f.getParameter(_v),maxVertexUniforms:f.getParameter(wv),maxVertexTextureUnits:f.getParameter(Ev),maxVaryingVectors:f.getParameter($v),maxFragmentUniforms:f.getParameter(Tv),glsl:f.getParameter(Lv),renderer:f.getParameter(Mv),vendor:f.getParameter(Cv),version:f.getParameter(Ov),readFloat:q,npotTextureCube:pe}};function yr(f){return!!f&&typeof f=="object"&&Array.isArray(f.shape)&&Array.isArray(f.stride)&&typeof f.offset=="number"&&f.shape.length===f.stride.length&&(Array.isArray(f.data)||r(f.data))}var nr=function(f){return Object.keys(f).map(function(v){return f[v]})},So={shape:Xv,flatten:qv};function zv(f,v,T){for(var X=0;X<v;++X)T[X]=f[X]}function Uv(f,v,T,X){for(var K=0,q=0;q<v;++q)for(var Y=f[q],ie=0;ie<T;++ie)X[K++]=Y[ie]}function wf(f,v,T,X,K,q){for(var Y=q,ie=0;ie<v;++ie)for(var ae=f[ie],he=0;he<T;++he)for(var pe=ae[he],me=0;me<X;++me)K[Y++]=pe[me]}function $f(f,v,T,X,K){for(var q=1,Y=T+1;Y<v.length;++Y)q*=v[Y];var ie=v[T];if(v.length-T===4){var ae=v[T+1],he=v[T+2],pe=v[T+3];for(Y=0;Y<ie;++Y)wf(f[Y],ae,he,pe,X,K),K+=q}else for(Y=0;Y<ie;++Y)$f(f[Y],v,T+1,X,K),K+=q}function qv(f,v,T,X){var K=1;if(v.length)for(var q=0;q<v.length;++q)K*=v[q];else K=0;var Y=X||_t.allocType(T,K);switch(v.length){case 0:break;case 1:zv(f,v[0],Y);break;case 2:Uv(f,v[0],v[1],Y);break;case 3:wf(f,v[0],v[1],v[2],Y,0);break;default:$f(f,v,0,Y,0)}return Y}function Xv(f){for(var v=[],T=f;T.length;T=T[0])v.push(T.length);return v}var li={"[object Int8Array]":5120,"[object Int16Array]":5122,"[object Int32Array]":5124,"[object Uint8Array]":5121,"[object Uint8ClampedArray]":5121,"[object Uint16Array]":5123,"[object Uint32Array]":5125,"[object Float32Array]":5126,"[object Float64Array]":5121,"[object ArrayBuffer]":5121},jv=5120,Hv=5122,Yv=5124,Wv=5121,Zv=5123,Qv=5125,Kv=5126,Jv=5126,fn={int8:jv,int16:Hv,int32:Yv,uint8:Wv,uint16:Zv,uint32:Qv,float:Kv,float32:Jv},e2=35048,t2=35040,Po={dynamic:e2,stream:t2,static:35044},fi=So.flatten,xf=So.shape,Ef=35044,r2=35040,ui=5121,di=5126,Ur=[];Ur[5120]=1,Ur[5122]=2,Ur[5124]=4,Ur[5121]=1,Ur[5123]=2,Ur[5125]=4,Ur[5126]=4;function Co(f){return li[Object.prototype.toString.call(f)]|0}function Af(f,v){for(var T=0;T<v.length;++T)f[T]=v[T]}function Tf(f,v,T,X,K,q,Y){for(var ie=0,ae=0;ae<T;++ae)for(var he=0;he<X;++he)f[ie++]=v[K*ae+q*he+Y]}function n2(f,v,T,X){var K=0,q={};function Y(D){this.id=K++,this.buffer=f.createBuffer(),this.type=D,this.usage=Ef,this.byteLength=0,this.dimension=1,this.dtype=ui,this.persistentData=null,T.profile&&(this.stats={size:0})}Y.prototype.bind=function(){f.bindBuffer(this.type,this.buffer)},Y.prototype.destroy=function(){ye(this)};var ie=[];function ae(D,H){var ue=ie.pop();return ue||(ue=new Y(D)),ue.bind(),me(ue,H,r2,0,1,!1),ue}function he(D){ie.push(D)}function pe(D,H,ue){D.byteLength=H.byteLength,f.bufferData(D.type,H,ue)}function me(D,H,ue,Te,se,Ee){var $e;if(D.usage=ue,Array.isArray(H)){if(D.dtype=Te||di,H.length>0){var ke;if(Array.isArray(H[0])){$e=xf(H);for(var ee=1,Q=1;Q<$e.length;++Q)ee*=$e[Q];D.dimension=ee,ke=fi(H,$e,D.dtype),pe(D,ke,ue),Ee?D.persistentData=ke:_t.freeType(ke)}else if(typeof H[0]=="number"){D.dimension=se;var Me=_t.allocType(D.dtype,H.length);Af(Me,H),pe(D,Me,ue),Ee?D.persistentData=Me:_t.freeType(Me)}else r(H[0])?(D.dimension=H[0].length,D.dtype=Te||Co(H[0])||di,ke=fi(H,[H.length,H[0].length],D.dtype),pe(D,ke,ue),Ee?D.persistentData=ke:_t.freeType(ke)):b.raise("invalid buffer data")}}else if(r(H))D.dtype=Te||Co(H),D.dimension=se,pe(D,H,ue),Ee&&(D.persistentData=new Uint8Array(new Uint8Array(H.buffer)));else if(yr(H)){$e=H.shape;var be=H.stride,fe=H.offset,_e=0,we=0,je=0,qe=0;$e.length===1?(_e=$e[0],we=1,je=be[0],qe=0):$e.length===2?(_e=$e[0],we=$e[1],je=be[0],qe=be[1]):b.raise("invalid shape"),D.dtype=Te||Co(H.data)||di,D.dimension=we;var xe=_t.allocType(D.dtype,_e*we);Tf(xe,H.data,_e,we,je,qe,fe),pe(D,xe,ue),Ee?D.persistentData=xe:_t.freeType(xe)}else H instanceof ArrayBuffer?(D.dtype=ui,D.dimension=se,pe(D,H,ue),Ee&&(D.persistentData=new Uint8Array(new Uint8Array(H)))):b.raise("invalid buffer data")}function ye(D){v.bufferCount--,X(D);var H=D.buffer;b(H,"buffer must not be deleted already"),f.deleteBuffer(H),D.buffer=null,delete q[D.id]}function ce(D,H,ue,Te){v.bufferCount++;var se=new Y(H);q[se.id]=se;function Ee(ee){var Q=Ef,Me=null,be=0,fe=0,_e=1;return Array.isArray(ee)||r(ee)||yr(ee)||ee instanceof ArrayBuffer?Me=ee:typeof ee=="number"?be=ee|0:ee&&(b.type(ee,"object","buffer arguments must be an object, a number or an array"),"data"in ee&&(b(Me===null||Array.isArray(Me)||r(Me)||yr(Me),"invalid data for buffer"),Me=ee.data),"usage"in ee&&(b.parameter(ee.usage,Po,"invalid buffer usage"),Q=Po[ee.usage]),"type"in ee&&(b.parameter(ee.type,fn,"invalid buffer type"),fe=fn[ee.type]),"dimension"in ee&&(b.type(ee.dimension,"number","invalid dimension"),_e=ee.dimension|0),"length"in ee&&(b.nni(be,"buffer length must be a nonnegative integer"),be=ee.length|0)),se.bind(),Me?me(se,Me,Q,fe,_e,Te):(be&&f.bufferData(se.type,be,Q),se.dtype=fe||ui,se.usage=Q,se.dimension=_e,se.byteLength=be),T.profile&&(se.stats.size=se.byteLength*Ur[se.dtype]),Ee}function $e(ee,Q){b(Q+ee.byteLength<=se.byteLength,"invalid buffer subdata call, buffer is too small.  Can't write data of size "+ee.byteLength+" starting from offset "+Q+" to a buffer of size "+se.byteLength),f.bufferSubData(se.type,Q,ee)}function ke(ee,Q){var Me=(Q||0)|0,be;if(se.bind(),r(ee)||ee instanceof ArrayBuffer)$e(ee,Me);else if(Array.isArray(ee)){if(ee.length>0)if(typeof ee[0]=="number"){var fe=_t.allocType(se.dtype,ee.length);Af(fe,ee),$e(fe,Me),_t.freeType(fe)}else if(Array.isArray(ee[0])||r(ee[0])){be=xf(ee);var _e=fi(ee,be,se.dtype);$e(_e,Me),_t.freeType(_e)}else b.raise("invalid buffer data")}else if(yr(ee)){be=ee.shape;var we=ee.stride,je=0,qe=0,xe=0,Ae=0;be.length===1?(je=be[0],qe=1,xe=we[0],Ae=0):be.length===2?(je=be[0],qe=be[1],xe=we[0],Ae=we[1]):b.raise("invalid shape");var Be=Array.isArray(ee.data)?se.dtype:Co(ee.data),He=_t.allocType(Be,je*qe);Tf(He,ee.data,je,qe,xe,Ae,ee.offset),$e(He,Me),_t.freeType(He)}else b.raise("invalid data for buffer subdata");return Ee}return ue||Ee(D),Ee._reglType="buffer",Ee._buffer=se,Ee.subdata=ke,T.profile&&(Ee.stats=se.stats),Ee.destroy=function(){ye(se)},Ee}function de(){nr(q).forEach(function(D){D.buffer=f.createBuffer(),f.bindBuffer(D.type,D.buffer),f.bufferData(D.type,D.persistentData||D.byteLength,D.usage)})}return T.profile&&(v.getTotalBufferSize=function(){var D=0;return Object.keys(q).forEach(function(H){D+=q[H].stats.size}),D}),{create:ce,createStream:ae,destroyStream:he,clear:function(){nr(q).forEach(ye),ie.forEach(ye)},getBuffer:function(D){return D&&D._buffer instanceof Y?D._buffer:null},restore:de,_initBuffer:me}}var s2=0,o2=0,a2=1,i2=1,c2=4,l2=4,qr={points:s2,point:o2,lines:a2,line:i2,triangles:c2,triangle:l2,"line loop":2,"line strip":3,"triangle strip":5,"triangle fan":6},f2=0,u2=1,Ms=4,d2=5120,Vn=5121,Sf=5122,zn=5123,Pf=5124,un=5125,hi=34963,h2=35040,m2=35044;function p2(f,v,T,X){var K={},q=0,Y={uint8:Vn,uint16:zn};v.oes_element_index_uint&&(Y.uint32=un);function ie(de){this.id=q++,K[this.id]=this,this.buffer=de,this.primType=Ms,this.vertCount=0,this.type=0}ie.prototype.bind=function(){this.buffer.bind()};var ae=[];function he(de){var D=ae.pop();return D||(D=new ie(T.create(null,hi,!0,!1)._buffer)),me(D,de,h2,-1,-1,0,0),D}function pe(de){ae.push(de)}function me(de,D,H,ue,Te,se,Ee){de.buffer.bind();var $e;if(D){var ke=Ee;!Ee&&(!r(D)||yr(D)&&!r(D.data))&&(ke=v.oes_element_index_uint?un:zn),T._initBuffer(de.buffer,D,H,ke,3)}else f.bufferData(hi,se,H),de.buffer.dtype=$e||Vn,de.buffer.usage=H,de.buffer.dimension=3,de.buffer.byteLength=se;if($e=Ee,!Ee){switch(de.buffer.dtype){case Vn:case d2:$e=Vn;break;case zn:case Sf:$e=zn;break;case un:case Pf:$e=un;break;default:b.raise("unsupported type for element array")}de.buffer.dtype=$e}de.type=$e,b($e!==un||!!v.oes_element_index_uint,"32 bit element buffers not supported, enable oes_element_index_uint first");var ee=Te;ee<0&&(ee=de.buffer.byteLength,$e===zn?ee>>=1:$e===un&&(ee>>=2)),de.vertCount=ee;var Q=ue;if(ue<0){Q=Ms;var Me=de.buffer.dimension;Me===1&&(Q=f2),Me===2&&(Q=u2),Me===3&&(Q=Ms)}de.primType=Q}function ye(de){X.elementsCount--,b(de.buffer!==null,"must not double destroy elements"),delete K[de.id],de.buffer.destroy(),de.buffer=null}function ce(de,D){var H=T.create(null,hi,!0),ue=new ie(H._buffer);X.elementsCount++;function Te(se){if(!se)H(),ue.primType=Ms,ue.vertCount=0,ue.type=Vn;else if(typeof se=="number")H(se),ue.primType=Ms,ue.vertCount=se|0,ue.type=Vn;else{var Ee=null,$e=m2,ke=-1,ee=-1,Q=0,Me=0;Array.isArray(se)||r(se)||yr(se)?Ee=se:(b.type(se,"object","invalid arguments for elements"),"data"in se&&(Ee=se.data,b(Array.isArray(Ee)||r(Ee)||yr(Ee),"invalid data for element buffer")),"usage"in se&&(b.parameter(se.usage,Po,"invalid element buffer usage"),$e=Po[se.usage]),"primitive"in se&&(b.parameter(se.primitive,qr,"invalid element buffer primitive"),ke=qr[se.primitive]),"count"in se&&(b(typeof se.count=="number"&&se.count>=0,"invalid vertex count for elements"),ee=se.count|0),"type"in se&&(b.parameter(se.type,Y,"invalid buffer type"),Me=Y[se.type]),"length"in se?Q=se.length|0:(Q=ee,Me===zn||Me===Sf?Q*=2:(Me===un||Me===Pf)&&(Q*=4))),me(ue,Ee,$e,ke,ee,Q,Me)}return Te}return Te(de),Te._reglType="elements",Te._elements=ue,Te.subdata=function(se,Ee){return H.subdata(se,Ee),Te},Te.destroy=function(){ye(ue)},Te}return{create:ce,createStream:he,destroyStream:pe,getElements:function(de){return typeof de=="function"&&de._elements instanceof ie?de._elements:null},clear:function(){nr(K).forEach(ye)}}}var Cf=new Float32Array(1),v2=new Uint32Array(Cf.buffer),g2=5123;function Mf(f){for(var v=_t.allocType(g2,f.length),T=0;T<f.length;++T)if(isNaN(f[T]))v[T]=65535;else if(f[T]===1/0)v[T]=31744;else if(f[T]===-1/0)v[T]=64512;else{Cf[0]=f[T];var X=v2[0],K=X>>>31<<15,q=(X<<1>>>24)-127,Y=X>>13&1024-1;if(q<-24)v[T]=K;else if(q<-14){var ie=-14-q;v[T]=K+(Y+1024>>ie)}else q>15?v[T]=K+31744:v[T]=K+(q+15<<10)+Y}return v}function dt(f){return Array.isArray(f)||r(f)}var Of=function(f){return!(f&f-1)&&!!f},y2=34467,Er=3553,mi=34067,Mo=34069,dn=6408,pi=6406,Oo=6407,Os=6409,Lo=6410,Lf=32854,vi=32855,Rf=36194,b2=32819,_2=32820,w2=33635,$2=34042,gi=6402,Ro=34041,yi=35904,bi=35906,Un=36193,_i=33776,wi=33777,$i=33778,xi=33779,Ff=35986,Nf=35987,Gf=34798,kf=35840,Df=35841,Bf=35842,If=35843,Vf=36196,qn=5121,Ei=5123,Ai=5125,Ls=5126,x2=10242,E2=10243,A2=10497,Ti=33071,T2=33648,S2=10240,P2=10241,Si=9728,C2=9729,Pi=9984,zf=9985,Uf=9986,Ci=9987,M2=33170,Fo=4352,O2=4353,L2=4354,R2=34046,F2=3317,N2=37440,G2=37441,k2=37443,qf=37444,Rs=33984,D2=[Pi,Uf,zf,Ci],No=[0,Os,Lo,Oo,dn],fr={};fr[Os]=fr[pi]=fr[gi]=1,fr[Ro]=fr[Lo]=2,fr[Oo]=fr[yi]=3,fr[dn]=fr[bi]=4;function Xn(f){return"[object "+f+"]"}var Xf=Xn("HTMLCanvasElement"),jf=Xn("OffscreenCanvas"),Hf=Xn("CanvasRenderingContext2D"),Yf=Xn("ImageBitmap"),Wf=Xn("HTMLImageElement"),Zf=Xn("HTMLVideoElement"),B2=Object.keys(li).concat([Xf,jf,Hf,Yf,Wf,Zf]),jn=[];jn[qn]=1,jn[Ls]=4,jn[Un]=2,jn[Ei]=2,jn[Ai]=4;var Ft=[];Ft[Lf]=2,Ft[vi]=2,Ft[Rf]=2,Ft[Ro]=4,Ft[_i]=.5,Ft[wi]=.5,Ft[$i]=1,Ft[xi]=1,Ft[Ff]=.5,Ft[Nf]=1,Ft[Gf]=1,Ft[kf]=.5,Ft[Df]=.25,Ft[Bf]=.5,Ft[If]=.25,Ft[Vf]=.5;function Qf(f){return Array.isArray(f)&&(f.length===0||typeof f[0]=="number")}function Kf(f){if(!Array.isArray(f))return!1;var v=f.length;return!(v===0||!dt(f[0]))}function hn(f){return Object.prototype.toString.call(f)}function Jf(f){return hn(f)===Xf}function eu(f){return hn(f)===jf}function I2(f){return hn(f)===Hf}function V2(f){return hn(f)===Yf}function z2(f){return hn(f)===Wf}function U2(f){return hn(f)===Zf}function Mi(f){if(!f)return!1;var v=hn(f);return B2.indexOf(v)>=0?!0:Qf(f)||Kf(f)||yr(f)}function tu(f){return li[Object.prototype.toString.call(f)]|0}function q2(f,v){var T=v.length;switch(f.type){case qn:case Ei:case Ai:case Ls:var X=_t.allocType(f.type,T);X.set(v),f.data=X;break;case Un:f.data=Mf(v);break;default:b.raise("unsupported texture type, must specify a typed array")}}function ru(f,v){return _t.allocType(f.type===Un?Ls:f.type,v)}function nu(f,v){f.type===Un?(f.data=Mf(v),_t.freeType(v)):f.data=v}function X2(f,v,T,X,K,q){for(var Y=f.width,ie=f.height,ae=f.channels,he=Y*ie*ae,pe=ru(f,he),me=0,ye=0;ye<ie;++ye)for(var ce=0;ce<Y;++ce)for(var de=0;de<ae;++de)pe[me++]=v[T*ce+X*ye+K*de+q];nu(f,pe)}function Go(f,v,T,X,K,q){var Y;if(typeof Ft[f]<"u"?Y=Ft[f]:Y=fr[f]*jn[v],q&&(Y*=6),K){for(var ie=0,ae=T;ae>=1;)ie+=Y*ae*ae,ae/=2;return ie}else return Y*T*X}function j2(f,v,T,X,K,q,Y){var ie={"don't care":Fo,"dont care":Fo,nice:L2,fast:O2},ae={repeat:A2,clamp:Ti,mirror:T2},he={nearest:Si,linear:C2},pe=n({mipmap:Ci,"nearest mipmap nearest":Pi,"linear mipmap nearest":zf,"nearest mipmap linear":Uf,"linear mipmap linear":Ci},he),me={none:0,browser:qf},ye={uint8:qn,rgba4:b2,rgb565:w2,"rgb5 a1":_2},ce={alpha:pi,luminance:Os,"luminance alpha":Lo,rgb:Oo,rgba:dn,rgba4:Lf,"rgb5 a1":vi,rgb565:Rf},de={};v.ext_srgb&&(ce.srgb=yi,ce.srgba=bi),v.oes_texture_float&&(ye.float32=ye.float=Ls),v.oes_texture_half_float&&(ye.float16=ye["half float"]=Un),v.webgl_depth_texture&&(n(ce,{depth:gi,"depth stencil":Ro}),n(ye,{uint16:Ei,uint32:Ai,"depth stencil":$2})),v.webgl_compressed_texture_s3tc&&n(de,{"rgb s3tc dxt1":_i,"rgba s3tc dxt1":wi,"rgba s3tc dxt3":$i,"rgba s3tc dxt5":xi}),v.webgl_compressed_texture_atc&&n(de,{"rgb atc":Ff,"rgba atc explicit alpha":Nf,"rgba atc interpolated alpha":Gf}),v.webgl_compressed_texture_pvrtc&&n(de,{"rgb pvrtc 4bppv1":kf,"rgb pvrtc 2bppv1":Df,"rgba pvrtc 4bppv1":Bf,"rgba pvrtc 2bppv1":If}),v.webgl_compressed_texture_etc1&&(de["rgb etc1"]=Vf);var D=Array.prototype.slice.call(f.getParameter(y2));Object.keys(de).forEach(function(E){var j=de[E];D.indexOf(j)>=0&&(ce[E]=j)});var H=Object.keys(ce);T.textureFormats=H;var ue=[];Object.keys(ce).forEach(function(E){var j=ce[E];ue[j]=E});var Te=[];Object.keys(ye).forEach(function(E){var j=ye[E];Te[j]=E});var se=[];Object.keys(he).forEach(function(E){var j=he[E];se[j]=E});var Ee=[];Object.keys(pe).forEach(function(E){var j=pe[E];Ee[j]=E});var $e=[];Object.keys(ae).forEach(function(E){var j=ae[E];$e[j]=E});var ke=H.reduce(function(E,j){var U=ce[j];return U===Os||U===pi||U===Os||U===Lo||U===gi||U===Ro||v.ext_srgb&&(U===yi||U===bi)?E[U]=U:U===vi||j.indexOf("rgba")>=0?E[U]=dn:E[U]=Oo,E},{});function ee(){this.internalformat=dn,this.format=dn,this.type=qn,this.compressed=!1,this.premultiplyAlpha=!1,this.flipY=!1,this.unpackAlignment=1,this.colorSpace=qf,this.width=0,this.height=0,this.channels=0}function Q(E,j){E.internalformat=j.internalformat,E.format=j.format,E.type=j.type,E.compressed=j.compressed,E.premultiplyAlpha=j.premultiplyAlpha,E.flipY=j.flipY,E.unpackAlignment=j.unpackAlignment,E.colorSpace=j.colorSpace,E.width=j.width,E.height=j.height,E.channels=j.channels}function Me(E,j){if(!(typeof j!="object"||!j)){if("premultiplyAlpha"in j&&(b.type(j.premultiplyAlpha,"boolean","invalid premultiplyAlpha"),E.premultiplyAlpha=j.premultiplyAlpha),"flipY"in j&&(b.type(j.flipY,"boolean","invalid texture flip"),E.flipY=j.flipY),"alignment"in j&&(b.oneOf(j.alignment,[1,2,4,8],"invalid texture unpack alignment"),E.unpackAlignment=j.alignment),"colorSpace"in j&&(b.parameter(j.colorSpace,me,"invalid colorSpace"),E.colorSpace=me[j.colorSpace]),"type"in j){var U=j.type;b(v.oes_texture_float||!(U==="float"||U==="float32"),"you must enable the OES_texture_float extension in order to use floating point textures."),b(v.oes_texture_half_float||!(U==="half float"||U==="float16"),"you must enable the OES_texture_half_float extension in order to use 16-bit floating point textures."),b(v.webgl_depth_texture||!(U==="uint16"||U==="uint32"||U==="depth stencil"),"you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."),b.parameter(U,ye,"invalid texture type"),E.type=ye[U]}var Ce=E.width,Ze=E.height,_=E.channels,p=!1;"shape"in j?(b(Array.isArray(j.shape)&&j.shape.length>=2,"shape must be an array"),Ce=j.shape[0],Ze=j.shape[1],j.shape.length===3&&(_=j.shape[2],b(_>0&&_<=4,"invalid number of channels"),p=!0),b(Ce>=0&&Ce<=T.maxTextureSize,"invalid width"),b(Ze>=0&&Ze<=T.maxTextureSize,"invalid height")):("radius"in j&&(Ce=Ze=j.radius,b(Ce>=0&&Ce<=T.maxTextureSize,"invalid radius")),"width"in j&&(Ce=j.width,b(Ce>=0&&Ce<=T.maxTextureSize,"invalid width")),"height"in j&&(Ze=j.height,b(Ze>=0&&Ze<=T.maxTextureSize,"invalid height")),"channels"in j&&(_=j.channels,b(_>0&&_<=4,"invalid number of channels"),p=!0)),E.width=Ce|0,E.height=Ze|0,E.channels=_|0;var P=!1;if("format"in j){var k=j.format;b(v.webgl_depth_texture||!(k==="depth"||k==="depth stencil"),"you must enable the WEBGL_depth_texture extension in order to use depth/stencil textures."),b.parameter(k,ce,"invalid texture format");var B=E.internalformat=ce[k];E.format=ke[B],k in ye&&("type"in j||(E.type=ye[k])),k in de&&(E.compressed=!0),P=!0}!p&&P?E.channels=fr[E.format]:p&&!P?E.channels!==No[E.format]&&(E.format=E.internalformat=No[E.channels]):P&&p&&b(E.channels===fr[E.format],"number of channels inconsistent with specified format")}}function be(E){f.pixelStorei(N2,E.flipY),f.pixelStorei(G2,E.premultiplyAlpha),f.pixelStorei(k2,E.colorSpace),f.pixelStorei(F2,E.unpackAlignment)}function fe(){ee.call(this),this.xOffset=0,this.yOffset=0,this.data=null,this.needsFree=!1,this.element=null,this.needsCopy=!1}function _e(E,j){var U=null;if(Mi(j)?U=j:j&&(b.type(j,"object","invalid pixel data type"),Me(E,j),"x"in j&&(E.xOffset=j.x|0),"y"in j&&(E.yOffset=j.y|0),Mi(j.data)&&(U=j.data)),b(!E.compressed||U instanceof Uint8Array,"compressed texture data must be stored in a uint8array"),j.copy){b(!U,"can not specify copy and data field for the same texture");var Ce=K.viewportWidth,Ze=K.viewportHeight;E.width=E.width||Ce-E.xOffset,E.height=E.height||Ze-E.yOffset,E.needsCopy=!0,b(E.xOffset>=0&&E.xOffset<Ce&&E.yOffset>=0&&E.yOffset<Ze&&E.width>0&&E.width<=Ce&&E.height>0&&E.height<=Ze,"copy texture read out of bounds")}else if(!U)E.width=E.width||1,E.height=E.height||1,E.channels=E.channels||4;else if(r(U))E.channels=E.channels||4,E.data=U,!("type"in j)&&E.type===qn&&(E.type=tu(U));else if(Qf(U))E.channels=E.channels||4,q2(E,U),E.alignment=1,E.needsFree=!0;else if(yr(U)){var _=U.data;!Array.isArray(_)&&E.type===qn&&(E.type=tu(_));var p=U.shape,P=U.stride,k,B,M,C,G,w;p.length===3?(M=p[2],w=P[2]):(b(p.length===2,"invalid ndarray pixel data, must be 2 or 3D"),M=1,w=1),k=p[0],B=p[1],C=P[0],G=P[1],E.alignment=1,E.width=k,E.height=B,E.channels=M,E.format=E.internalformat=No[M],E.needsFree=!0,X2(E,_,C,G,w,U.offset)}else if(Jf(U)||eu(U)||I2(U))Jf(U)||eu(U)?E.element=U:E.element=U.canvas,E.width=E.element.width,E.height=E.element.height,E.channels=4;else if(V2(U))E.element=U,E.width=U.width,E.height=U.height,E.channels=4;else if(z2(U))E.element=U,E.width=U.naturalWidth,E.height=U.naturalHeight,E.channels=4;else if(U2(U))E.element=U,E.width=U.videoWidth,E.height=U.videoHeight,E.channels=4;else if(Kf(U)){var A=E.width||U[0].length,x=E.height||U.length,V=E.channels;dt(U[0][0])?V=V||U[0][0].length:V=V||1;for(var I=So.shape(U),Z=1,te=0;te<I.length;++te)Z*=I[te];var ge=ru(E,Z);So.flatten(U,I,"",ge),nu(E,ge),E.alignment=1,E.width=A,E.height=x,E.channels=V,E.format=E.internalformat=No[V],E.needsFree=!0}E.type===Ls?b(T.extensions.indexOf("oes_texture_float")>=0,"oes_texture_float extension not enabled"):E.type===Un&&b(T.extensions.indexOf("oes_texture_half_float")>=0,"oes_texture_half_float extension not enabled")}function we(E,j,U){var Ce=E.element,Ze=E.data,_=E.internalformat,p=E.format,P=E.type,k=E.width,B=E.height;be(E),Ce?f.texImage2D(j,U,p,p,P,Ce):E.compressed?f.compressedTexImage2D(j,U,_,k,B,0,Ze):E.needsCopy?(X(),f.copyTexImage2D(j,U,p,E.xOffset,E.yOffset,k,B,0)):f.texImage2D(j,U,p,k,B,0,p,P,Ze||null)}function je(E,j,U,Ce,Ze){var _=E.element,p=E.data,P=E.internalformat,k=E.format,B=E.type,M=E.width,C=E.height;be(E),_?f.texSubImage2D(j,Ze,U,Ce,k,B,_):E.compressed?f.compressedTexSubImage2D(j,Ze,U,Ce,P,M,C,p):E.needsCopy?(X(),f.copyTexSubImage2D(j,Ze,U,Ce,E.xOffset,E.yOffset,M,C)):f.texSubImage2D(j,Ze,U,Ce,M,C,k,B,p)}var qe=[];function xe(){return qe.pop()||new fe}function Ae(E){E.needsFree&&_t.freeType(E.data),fe.call(E),qe.push(E)}function Be(){ee.call(this),this.genMipmaps=!1,this.mipmapHint=Fo,this.mipmask=0,this.images=Array(16)}function He(E,j,U){var Ce=E.images[0]=xe();E.mipmask=1,Ce.width=E.width=j,Ce.height=E.height=U,Ce.channels=E.channels=4}function Je(E,j){var U=null;if(Mi(j))U=E.images[0]=xe(),Q(U,E),_e(U,j),E.mipmask=1;else if(Me(E,j),Array.isArray(j.mipmap))for(var Ce=j.mipmap,Ze=0;Ze<Ce.length;++Ze)U=E.images[Ze]=xe(),Q(U,E),U.width>>=Ze,U.height>>=Ze,_e(U,Ce[Ze]),E.mipmask|=1<<Ze;else U=E.images[0]=xe(),Q(U,E),_e(U,j),E.mipmask=1;Q(E,E.images[0]),E.compressed&&(E.internalformat===_i||E.internalformat===wi||E.internalformat===$i||E.internalformat===xi)&&b(E.width%4===0&&E.height%4===0,"for compressed texture formats, mipmap level 0 must have width and height that are a multiple of 4")}function ht(E,j){for(var U=E.images,Ce=0;Ce<U.length;++Ce){if(!U[Ce])return;we(U[Ce],j,Ce)}}var mt=[];function tt(){var E=mt.pop()||new Be;ee.call(E),E.mipmask=0;for(var j=0;j<16;++j)E.images[j]=null;return E}function Et(E){for(var j=E.images,U=0;U<j.length;++U)j[U]&&Ae(j[U]),j[U]=null;mt.push(E)}function lt(){this.minFilter=Si,this.magFilter=Si,this.wrapS=Ti,this.wrapT=Ti,this.anisotropic=1,this.genMipmaps=!1,this.mipmapHint=Fo}function $t(E,j){if("min"in j){var U=j.min;b.parameter(U,pe),E.minFilter=pe[U],D2.indexOf(E.minFilter)>=0&&!("faces"in j)&&(E.genMipmaps=!0)}if("mag"in j){var Ce=j.mag;b.parameter(Ce,he),E.magFilter=he[Ce]}var Ze=E.wrapS,_=E.wrapT;if("wrap"in j){var p=j.wrap;typeof p=="string"?(b.parameter(p,ae),Ze=_=ae[p]):Array.isArray(p)&&(b.parameter(p[0],ae),b.parameter(p[1],ae),Ze=ae[p[0]],_=ae[p[1]])}else{if("wrapS"in j){var P=j.wrapS;b.parameter(P,ae),Ze=ae[P]}if("wrapT"in j){var k=j.wrapT;b.parameter(k,ae),_=ae[k]}}if(E.wrapS=Ze,E.wrapT=_,"anisotropic"in j){var B=j.anisotropic;b(typeof B=="number"&&B>=1&&B<=T.maxAnisotropic,"aniso samples must be between 1 and "),E.anisotropic=j.anisotropic}if("mipmap"in j){var M=!1;switch(typeof j.mipmap){case"string":b.parameter(j.mipmap,ie,"invalid mipmap hint"),E.mipmapHint=ie[j.mipmap],E.genMipmaps=!0,M=!0;break;case"boolean":M=E.genMipmaps=j.mipmap;break;case"object":b(Array.isArray(j.mipmap),"invalid mipmap type"),E.genMipmaps=!1,M=!0;break;default:b.raise("invalid mipmap type")}M&&!("min"in j)&&(E.minFilter=Pi)}}function At(E,j){f.texParameteri(j,P2,E.minFilter),f.texParameteri(j,S2,E.magFilter),f.texParameteri(j,x2,E.wrapS),f.texParameteri(j,E2,E.wrapT),v.ext_texture_filter_anisotropic&&f.texParameteri(j,R2,E.anisotropic),E.genMipmaps&&(f.hint(M2,E.mipmapHint),f.generateMipmap(j))}var Tt=0,Lt={},Nt=T.maxTextureUnits,vt=Array(Nt).map(function(){return null});function Ye(E){ee.call(this),this.mipmask=0,this.internalformat=dn,this.id=Tt++,this.refCount=1,this.target=E,this.texture=f.createTexture(),this.unit=-1,this.bindCount=0,this.texInfo=new lt,Y.profile&&(this.stats={size:0})}function Gt(E){f.activeTexture(Rs),f.bindTexture(E.target,E.texture)}function at(){var E=vt[0];E?f.bindTexture(E.target,E.texture):f.bindTexture(Er,null)}function De(E){var j=E.texture;b(j,"must not double destroy texture");var U=E.unit,Ce=E.target;U>=0&&(f.activeTexture(Rs+U),f.bindTexture(Ce,null),vt[U]=null),f.deleteTexture(j),E.texture=null,E.params=null,E.pixels=null,E.refCount=0,delete Lt[E.id],q.textureCount--}n(Ye.prototype,{bind:function(){var E=this;E.bindCount+=1;var j=E.unit;if(j<0){for(var U=0;U<Nt;++U){var Ce=vt[U];if(Ce){if(Ce.bindCount>0)continue;Ce.unit=-1}vt[U]=E,j=U;break}j>=Nt&&b.raise("insufficient number of texture units"),Y.profile&&q.maxTextureUnits<j+1&&(q.maxTextureUnits=j+1),E.unit=j,f.activeTexture(Rs+j),f.bindTexture(E.target,E.texture)}return j},unbind:function(){this.bindCount-=1},decRef:function(){--this.refCount<=0&&De(this)}});function et(E,j){var U=new Ye(Er);Lt[U.id]=U,q.textureCount++;function Ce(p,P){var k=U.texInfo;lt.call(k);var B=tt();return typeof p=="number"?typeof P=="number"?He(B,p|0,P|0):He(B,p|0,p|0):p?(b.type(p,"object","invalid arguments to regl.texture"),$t(k,p),Je(B,p)):He(B,1,1),k.genMipmaps&&(B.mipmask=(B.width<<1)-1),U.mipmask=B.mipmask,Q(U,B),b.texture2D(k,B,T),U.internalformat=B.internalformat,Ce.width=B.width,Ce.height=B.height,Gt(U),ht(B,Er),At(k,Er),at(),Et(B),Y.profile&&(U.stats.size=Go(U.internalformat,U.type,B.width,B.height,k.genMipmaps,!1)),Ce.format=ue[U.internalformat],Ce.type=Te[U.type],Ce.mag=se[k.magFilter],Ce.min=Ee[k.minFilter],Ce.wrapS=$e[k.wrapS],Ce.wrapT=$e[k.wrapT],Ce}function Ze(p,P,k,B){b(!!p,"must specify image data");var M=P|0,C=k|0,G=B|0,w=xe();return Q(w,U),w.width=0,w.height=0,_e(w,p),w.width=w.width||(U.width>>G)-M,w.height=w.height||(U.height>>G)-C,b(U.type===w.type&&U.format===w.format&&U.internalformat===w.internalformat,"incompatible format for texture.subimage"),b(M>=0&&C>=0&&M+w.width<=U.width&&C+w.height<=U.height,"texture.subimage write out of bounds"),b(U.mipmask&1<<G,"missing mipmap data"),b(w.data||w.element||w.needsCopy,"missing image data"),Gt(U),je(w,Er,M,C,G),at(),Ae(w),Ce}function _(p,P){var k=p|0,B=P|0||k;if(k===U.width&&B===U.height)return Ce;Ce.width=U.width=k,Ce.height=U.height=B,Gt(U);for(var M=0;U.mipmask>>M;++M){var C=k>>M,G=B>>M;if(!C||!G)break;f.texImage2D(Er,M,U.format,C,G,0,U.format,U.type,null)}return at(),Y.profile&&(U.stats.size=Go(U.internalformat,U.type,k,B,!1,!1)),Ce}return Ce(E,j),Ce.subimage=Ze,Ce.resize=_,Ce._reglType="texture2d",Ce._texture=U,Y.profile&&(Ce.stats=U.stats),Ce.destroy=function(){U.decRef()},Ce}function nt(E,j,U,Ce,Ze,_){var p=new Ye(mi);Lt[p.id]=p,q.cubeCount++;var P=new Array(6);function k(C,G,w,A,x,V){var I,Z=p.texInfo;for(lt.call(Z),I=0;I<6;++I)P[I]=tt();if(typeof C=="number"||!C){var te=C|0||1;for(I=0;I<6;++I)He(P[I],te,te)}else if(typeof C=="object")if(G)Je(P[0],C),Je(P[1],G),Je(P[2],w),Je(P[3],A),Je(P[4],x),Je(P[5],V);else if($t(Z,C),Me(p,C),"faces"in C){var ge=C.faces;for(b(Array.isArray(ge)&&ge.length===6,"cube faces must be a length 6 array"),I=0;I<6;++I)b(typeof ge[I]=="object"&&!!ge[I],"invalid input for cube map face"),Q(P[I],p),Je(P[I],ge[I])}else for(I=0;I<6;++I)Je(P[I],C);else b.raise("invalid arguments to cube map");for(Q(p,P[0]),b.optional(function(){T.npotTextureCube||b(Of(p.width)&&Of(p.height),"your browser does not support non power or two texture dimensions")}),Z.genMipmaps?p.mipmask=(P[0].width<<1)-1:p.mipmask=P[0].mipmask,b.textureCube(p,Z,P,T),p.internalformat=P[0].internalformat,k.width=P[0].width,k.height=P[0].height,Gt(p),I=0;I<6;++I)ht(P[I],Mo+I);for(At(Z,mi),at(),Y.profile&&(p.stats.size=Go(p.internalformat,p.type,k.width,k.height,Z.genMipmaps,!0)),k.format=ue[p.internalformat],k.type=Te[p.type],k.mag=se[Z.magFilter],k.min=Ee[Z.minFilter],k.wrapS=$e[Z.wrapS],k.wrapT=$e[Z.wrapT],I=0;I<6;++I)Et(P[I]);return k}function B(C,G,w,A,x){b(!!G,"must specify image data"),b(typeof C=="number"&&C===(C|0)&&C>=0&&C<6,"invalid face");var V=w|0,I=A|0,Z=x|0,te=xe();return Q(te,p),te.width=0,te.height=0,_e(te,G),te.width=te.width||(p.width>>Z)-V,te.height=te.height||(p.height>>Z)-I,b(p.type===te.type&&p.format===te.format&&p.internalformat===te.internalformat,"incompatible format for texture.subimage"),b(V>=0&&I>=0&&V+te.width<=p.width&&I+te.height<=p.height,"texture.subimage write out of bounds"),b(p.mipmask&1<<Z,"missing mipmap data"),b(te.data||te.element||te.needsCopy,"missing image data"),Gt(p),je(te,Mo+C,V,I,Z),at(),Ae(te),k}function M(C){var G=C|0;if(G!==p.width){k.width=p.width=G,k.height=p.height=G,Gt(p);for(var w=0;w<6;++w)for(var A=0;p.mipmask>>A;++A)f.texImage2D(Mo+w,A,p.format,G>>A,G>>A,0,p.format,p.type,null);return at(),Y.profile&&(p.stats.size=Go(p.internalformat,p.type,k.width,k.height,!1,!0)),k}}return k(E,j,U,Ce,Ze,_),k.subimage=B,k.resize=M,k._reglType="textureCube",k._texture=p,Y.profile&&(k.stats=p.stats),k.destroy=function(){p.decRef()},k}function gt(){for(var E=0;E<Nt;++E)f.activeTexture(Rs+E),f.bindTexture(Er,null),vt[E]=null;nr(Lt).forEach(De),q.cubeCount=0,q.textureCount=0}Y.profile&&(q.getTotalTextureSize=function(){var E=0;return Object.keys(Lt).forEach(function(j){E+=Lt[j].stats.size}),E});function Tr(){for(var E=0;E<Nt;++E){var j=vt[E];j&&(j.bindCount=0,j.unit=-1,vt[E]=null)}nr(Lt).forEach(function(U){U.texture=f.createTexture(),f.bindTexture(U.target,U.texture);for(var Ce=0;Ce<32;++Ce)if(U.mipmask&1<<Ce)if(U.target===Er)f.texImage2D(Er,Ce,U.internalformat,U.width>>Ce,U.height>>Ce,0,U.internalformat,U.type,null);else for(var Ze=0;Ze<6;++Ze)f.texImage2D(Mo+Ze,Ce,U.internalformat,U.width>>Ce,U.height>>Ce,0,U.internalformat,U.type,null);At(U.texInfo,U.target)})}function _n(){for(var E=0;E<Nt;++E){var j=vt[E];j&&(j.bindCount=0,j.unit=-1,vt[E]=null),f.activeTexture(Rs+E),f.bindTexture(Er,null),f.bindTexture(mi,null)}}return{create2D:et,createCube:nt,clear:gt,getTexture:function(E){return null},restore:Tr,refresh:_n}}var Xr=36161,ko=32854,su=32855,ou=36194,au=33189,iu=36168,cu=34041,lu=35907,fu=34836,uu=34842,du=34843,br=[];br[ko]=2,br[su]=2,br[ou]=2,br[au]=2,br[iu]=1,br[cu]=4,br[lu]=4,br[fu]=16,br[uu]=8,br[du]=6;function hu(f,v,T){return br[f]*v*T}var H2=function(f,v,T,X,K){var q={rgba4:ko,rgb565:ou,"rgb5 a1":su,depth:au,stencil:iu,"depth stencil":cu};v.ext_srgb&&(q.srgba=lu),v.ext_color_buffer_half_float&&(q.rgba16f=uu,q.rgb16f=du),v.webgl_color_buffer_float&&(q.rgba32f=fu);var Y=[];Object.keys(q).forEach(function(ce){var de=q[ce];Y[de]=ce});var ie=0,ae={};function he(ce){this.id=ie++,this.refCount=1,this.renderbuffer=ce,this.format=ko,this.width=0,this.height=0,K.profile&&(this.stats={size:0})}he.prototype.decRef=function(){--this.refCount<=0&&pe(this)};function pe(ce){var de=ce.renderbuffer;b(de,"must not double destroy renderbuffer"),f.bindRenderbuffer(Xr,null),f.deleteRenderbuffer(de),ce.renderbuffer=null,ce.refCount=0,delete ae[ce.id],X.renderbufferCount--}function me(ce,de){var D=new he(f.createRenderbuffer());ae[D.id]=D,X.renderbufferCount++;function H(Te,se){var Ee=0,$e=0,ke=ko;if(typeof Te=="object"&&Te){var ee=Te;if("shape"in ee){var Q=ee.shape;b(Array.isArray(Q)&&Q.length>=2,"invalid renderbuffer shape"),Ee=Q[0]|0,$e=Q[1]|0}else"radius"in ee&&(Ee=$e=ee.radius|0),"width"in ee&&(Ee=ee.width|0),"height"in ee&&($e=ee.height|0);"format"in ee&&(b.parameter(ee.format,q,"invalid renderbuffer format"),ke=q[ee.format])}else typeof Te=="number"?(Ee=Te|0,typeof se=="number"?$e=se|0:$e=Ee):Te?b.raise("invalid arguments to renderbuffer constructor"):Ee=$e=1;if(b(Ee>0&&$e>0&&Ee<=T.maxRenderbufferSize&&$e<=T.maxRenderbufferSize,"invalid renderbuffer size"),!(Ee===D.width&&$e===D.height&&ke===D.format))return H.width=D.width=Ee,H.height=D.height=$e,D.format=ke,f.bindRenderbuffer(Xr,D.renderbuffer),f.renderbufferStorage(Xr,ke,Ee,$e),b(f.getError()===0,"invalid render buffer format"),K.profile&&(D.stats.size=hu(D.format,D.width,D.height)),H.format=Y[D.format],H}function ue(Te,se){var Ee=Te|0,$e=se|0||Ee;return Ee===D.width&&$e===D.height||(b(Ee>0&&$e>0&&Ee<=T.maxRenderbufferSize&&$e<=T.maxRenderbufferSize,"invalid renderbuffer size"),H.width=D.width=Ee,H.height=D.height=$e,f.bindRenderbuffer(Xr,D.renderbuffer),f.renderbufferStorage(Xr,D.format,Ee,$e),b(f.getError()===0,"invalid render buffer format"),K.profile&&(D.stats.size=hu(D.format,D.width,D.height))),H}return H(ce,de),H.resize=ue,H._reglType="renderbuffer",H._renderbuffer=D,K.profile&&(H.stats=D.stats),H.destroy=function(){D.decRef()},H}K.profile&&(X.getTotalRenderbufferSize=function(){var ce=0;return Object.keys(ae).forEach(function(de){ce+=ae[de].stats.size}),ce});function ye(){nr(ae).forEach(function(ce){ce.renderbuffer=f.createRenderbuffer(),f.bindRenderbuffer(Xr,ce.renderbuffer),f.renderbufferStorage(Xr,ce.format,ce.width,ce.height)}),f.bindRenderbuffer(Xr,null)}return{create:me,clear:function(){nr(ae).forEach(pe)},restore:ye}},Gr=36160,Oi=36161,mn=3553,Do=34069,mu=36064,pu=36096,vu=36128,gu=33306,yu=36053,Y2=36054,W2=36055,Z2=36057,Q2=36061,K2=36193,J2=5121,eg=5126,bu=6407,_u=6408,tg=6402,rg=[bu,_u],Li=[];Li[_u]=4,Li[bu]=3;var Bo=[];Bo[J2]=1,Bo[eg]=4,Bo[K2]=2;var ng=32854,sg=32855,og=36194,ag=33189,ig=36168,wu=34041,cg=35907,lg=34836,fg=34842,ug=34843,dg=[ng,sg,og,cg,fg,ug,lg],Hn={};Hn[yu]="complete",Hn[Y2]="incomplete attachment",Hn[Z2]="incomplete dimensions",Hn[W2]="incomplete, missing attachment",Hn[Q2]="unsupported";function hg(f,v,T,X,K,q){var Y={cur:null,next:null,dirty:!1,setFBO:null},ie=["rgba"],ae=["rgba4","rgb565","rgb5 a1"];v.ext_srgb&&ae.push("srgba"),v.ext_color_buffer_half_float&&ae.push("rgba16f","rgb16f"),v.webgl_color_buffer_float&&ae.push("rgba32f");var he=["uint8"];v.oes_texture_half_float&&he.push("half float","float16"),v.oes_texture_float&&he.push("float","float32");function pe(fe,_e,we){this.target=fe,this.texture=_e,this.renderbuffer=we;var je=0,qe=0;_e?(je=_e.width,qe=_e.height):we&&(je=we.width,qe=we.height),this.width=je,this.height=qe}function me(fe){fe&&(fe.texture&&fe.texture._texture.decRef(),fe.renderbuffer&&fe.renderbuffer._renderbuffer.decRef())}function ye(fe,_e,we){if(fe)if(fe.texture){var je=fe.texture._texture,qe=Math.max(1,je.width),xe=Math.max(1,je.height);b(qe===_e&&xe===we,"inconsistent width/height for supplied texture"),je.refCount+=1}else{var Ae=fe.renderbuffer._renderbuffer;b(Ae.width===_e&&Ae.height===we,"inconsistent width/height for renderbuffer"),Ae.refCount+=1}}function ce(fe,_e){_e&&(_e.texture?f.framebufferTexture2D(Gr,fe,_e.target,_e.texture._texture.texture,0):f.framebufferRenderbuffer(Gr,fe,Oi,_e.renderbuffer._renderbuffer.renderbuffer))}function de(fe){var _e=mn,we=null,je=null,qe=fe;typeof fe=="object"&&(qe=fe.data,"target"in fe&&(_e=fe.target|0)),b.type(qe,"function","invalid attachment data");var xe=qe._reglType;return xe==="texture2d"?(we=qe,b(_e===mn)):xe==="textureCube"?(we=qe,b(_e>=Do&&_e<Do+6,"invalid cube map target")):xe==="renderbuffer"?(je=qe,_e=Oi):b.raise("invalid regl object for attachment"),new pe(_e,we,je)}function D(fe,_e,we,je,qe){if(we){var xe=X.create2D({width:fe,height:_e,format:je,type:qe});return xe._texture.refCount=0,new pe(mn,xe,null)}else{var Ae=K.create({width:fe,height:_e,format:je});return Ae._renderbuffer.refCount=0,new pe(Oi,null,Ae)}}function H(fe){return fe&&(fe.texture||fe.renderbuffer)}function ue(fe,_e,we){fe&&(fe.texture?fe.texture.resize(_e,we):fe.renderbuffer&&fe.renderbuffer.resize(_e,we),fe.width=_e,fe.height=we)}var Te=0,se={};function Ee(){this.id=Te++,se[this.id]=this,this.framebuffer=f.createFramebuffer(),this.width=0,this.height=0,this.colorAttachments=[],this.depthAttachment=null,this.stencilAttachment=null,this.depthStencilAttachment=null}function $e(fe){fe.colorAttachments.forEach(me),me(fe.depthAttachment),me(fe.stencilAttachment),me(fe.depthStencilAttachment)}function ke(fe){var _e=fe.framebuffer;b(_e,"must not double destroy framebuffer"),f.deleteFramebuffer(_e),fe.framebuffer=null,q.framebufferCount--,delete se[fe.id]}function ee(fe){var _e;f.bindFramebuffer(Gr,fe.framebuffer);var we=fe.colorAttachments;for(_e=0;_e<we.length;++_e)ce(mu+_e,we[_e]);for(_e=we.length;_e<T.maxColorAttachments;++_e)f.framebufferTexture2D(Gr,mu+_e,mn,null,0);f.framebufferTexture2D(Gr,gu,mn,null,0),f.framebufferTexture2D(Gr,pu,mn,null,0),f.framebufferTexture2D(Gr,vu,mn,null,0),ce(pu,fe.depthAttachment),ce(vu,fe.stencilAttachment),ce(gu,fe.depthStencilAttachment);var je=f.checkFramebufferStatus(Gr);!f.isContextLost()&&je!==yu&&b.raise("framebuffer configuration not supported, status = "+Hn[je]),f.bindFramebuffer(Gr,Y.next?Y.next.framebuffer:null),Y.cur=Y.next,f.getError()}function Q(fe,_e){var we=new Ee;q.framebufferCount++;function je(xe,Ae){var Be;b(Y.next!==we,"can not update framebuffer which is currently in use");var He=0,Je=0,ht=!0,mt=!0,tt=null,Et=!0,lt="rgba",$t="uint8",At=1,Tt=null,Lt=null,Nt=null,vt=!1;if(typeof xe=="number")He=xe|0,Je=Ae|0||He;else if(!xe)He=Je=1;else{b.type(xe,"object","invalid arguments for framebuffer");var Ye=xe;if("shape"in Ye){var Gt=Ye.shape;b(Array.isArray(Gt)&&Gt.length>=2,"invalid shape for framebuffer"),He=Gt[0],Je=Gt[1]}else"radius"in Ye&&(He=Je=Ye.radius),"width"in Ye&&(He=Ye.width),"height"in Ye&&(Je=Ye.height);("color"in Ye||"colors"in Ye)&&(tt=Ye.color||Ye.colors,Array.isArray(tt)&&b(tt.length===1||v.webgl_draw_buffers,"multiple render targets not supported")),tt||("colorCount"in Ye&&(At=Ye.colorCount|0,b(At>0,"invalid color buffer count")),"colorTexture"in Ye&&(Et=!!Ye.colorTexture,lt="rgba4"),"colorType"in Ye&&($t=Ye.colorType,Et?(b(v.oes_texture_float||!($t==="float"||$t==="float32"),"you must enable OES_texture_float in order to use floating point framebuffer objects"),b(v.oes_texture_half_float||!($t==="half float"||$t==="float16"),"you must enable OES_texture_half_float in order to use 16-bit floating point framebuffer objects")):$t==="half float"||$t==="float16"?(b(v.ext_color_buffer_half_float,"you must enable EXT_color_buffer_half_float to use 16-bit render buffers"),lt="rgba16f"):($t==="float"||$t==="float32")&&(b(v.webgl_color_buffer_float,"you must enable WEBGL_color_buffer_float in order to use 32-bit floating point renderbuffers"),lt="rgba32f"),b.oneOf($t,he,"invalid color type")),"colorFormat"in Ye&&(lt=Ye.colorFormat,ie.indexOf(lt)>=0?Et=!0:ae.indexOf(lt)>=0?Et=!1:b.optional(function(){Et?b.oneOf(Ye.colorFormat,ie,"invalid color format for texture"):b.oneOf(Ye.colorFormat,ae,"invalid color format for renderbuffer")}))),("depthTexture"in Ye||"depthStencilTexture"in Ye)&&(vt=!!(Ye.depthTexture||Ye.depthStencilTexture),b(!vt||v.webgl_depth_texture,"webgl_depth_texture extension not supported")),"depth"in Ye&&(typeof Ye.depth=="boolean"?ht=Ye.depth:(Tt=Ye.depth,mt=!1)),"stencil"in Ye&&(typeof Ye.stencil=="boolean"?mt=Ye.stencil:(Lt=Ye.stencil,ht=!1)),"depthStencil"in Ye&&(typeof Ye.depthStencil=="boolean"?ht=mt=Ye.depthStencil:(Nt=Ye.depthStencil,ht=!1,mt=!1))}var at=null,De=null,et=null,nt=null;if(Array.isArray(tt))at=tt.map(de);else if(tt)at=[de(tt)];else for(at=new Array(At),Be=0;Be<At;++Be)at[Be]=D(He,Je,Et,lt,$t);b(v.webgl_draw_buffers||at.length<=1,"you must enable the WEBGL_draw_buffers extension in order to use multiple color buffers."),b(at.length<=T.maxColorAttachments,"too many color attachments, not supported"),He=He||at[0].width,Je=Je||at[0].height,Tt?De=de(Tt):ht&&!mt&&(De=D(He,Je,vt,"depth","uint32")),Lt?et=de(Lt):mt&&!ht&&(et=D(He,Je,!1,"stencil","uint8")),Nt?nt=de(Nt):!Tt&&!Lt&&mt&&ht&&(nt=D(He,Je,vt,"depth stencil","depth stencil")),b(!!Tt+!!Lt+!!Nt<=1,"invalid framebuffer configuration, can specify exactly one depth/stencil attachment");var gt=null;for(Be=0;Be<at.length;++Be)if(ye(at[Be],He,Je),b(!at[Be]||at[Be].texture&&rg.indexOf(at[Be].texture._texture.format)>=0||at[Be].renderbuffer&&dg.indexOf(at[Be].renderbuffer._renderbuffer.format)>=0,"framebuffer color attachment "+Be+" is invalid"),at[Be]&&at[Be].texture){var Tr=Li[at[Be].texture._texture.format]*Bo[at[Be].texture._texture.type];gt===null?gt=Tr:b(gt===Tr,"all color attachments much have the same number of bits per pixel.")}return ye(De,He,Je),b(!De||De.texture&&De.texture._texture.format===tg||De.renderbuffer&&De.renderbuffer._renderbuffer.format===ag,"invalid depth attachment for framebuffer object"),ye(et,He,Je),b(!et||et.renderbuffer&&et.renderbuffer._renderbuffer.format===ig,"invalid stencil attachment for framebuffer object"),ye(nt,He,Je),b(!nt||nt.texture&&nt.texture._texture.format===wu||nt.renderbuffer&&nt.renderbuffer._renderbuffer.format===wu,"invalid depth-stencil attachment for framebuffer object"),$e(we),we.width=He,we.height=Je,we.colorAttachments=at,we.depthAttachment=De,we.stencilAttachment=et,we.depthStencilAttachment=nt,je.color=at.map(H),je.depth=H(De),je.stencil=H(et),je.depthStencil=H(nt),je.width=we.width,je.height=we.height,ee(we),je}function qe(xe,Ae){b(Y.next!==we,"can not resize a framebuffer which is currently in use");var Be=Math.max(xe|0,1),He=Math.max(Ae|0||Be,1);if(Be===we.width&&He===we.height)return je;for(var Je=we.colorAttachments,ht=0;ht<Je.length;++ht)ue(Je[ht],Be,He);return ue(we.depthAttachment,Be,He),ue(we.stencilAttachment,Be,He),ue(we.depthStencilAttachment,Be,He),we.width=je.width=Be,we.height=je.height=He,ee(we),je}return je(fe,_e),n(je,{resize:qe,_reglType:"framebuffer",_framebuffer:we,destroy:function(){ke(we),$e(we)},use:function(xe){Y.setFBO({framebuffer:je},xe)}})}function Me(fe){var _e=Array(6);function we(qe){var xe;b(_e.indexOf(Y.next)<0,"can not update framebuffer which is currently in use");var Ae={color:null},Be=0,He=null,Je="rgba",ht="uint8",mt=1;if(typeof qe=="number")Be=qe|0;else if(!qe)Be=1;else{b.type(qe,"object","invalid arguments for framebuffer");var tt=qe;if("shape"in tt){var Et=tt.shape;b(Array.isArray(Et)&&Et.length>=2,"invalid shape for framebuffer"),b(Et[0]===Et[1],"cube framebuffer must be square"),Be=Et[0]}else"radius"in tt&&(Be=tt.radius|0),"width"in tt?(Be=tt.width|0,"height"in tt&&b(tt.height===Be,"must be square")):"height"in tt&&(Be=tt.height|0);("color"in tt||"colors"in tt)&&(He=tt.color||tt.colors,Array.isArray(He)&&b(He.length===1||v.webgl_draw_buffers,"multiple render targets not supported")),He||("colorCount"in tt&&(mt=tt.colorCount|0,b(mt>0,"invalid color buffer count")),"colorType"in tt&&(b.oneOf(tt.colorType,he,"invalid color type"),ht=tt.colorType),"colorFormat"in tt&&(Je=tt.colorFormat,b.oneOf(tt.colorFormat,ie,"invalid color format for texture"))),"depth"in tt&&(Ae.depth=tt.depth),"stencil"in tt&&(Ae.stencil=tt.stencil),"depthStencil"in tt&&(Ae.depthStencil=tt.depthStencil)}var lt;if(He)if(Array.isArray(He))for(lt=[],xe=0;xe<He.length;++xe)lt[xe]=He[xe];else lt=[He];else{lt=Array(mt);var $t={radius:Be,format:Je,type:ht};for(xe=0;xe<mt;++xe)lt[xe]=X.createCube($t)}for(Ae.color=Array(lt.length),xe=0;xe<lt.length;++xe){var At=lt[xe];b(typeof At=="function"&&At._reglType==="textureCube","invalid cube map"),Be=Be||At.width,b(At.width===Be&&At.height===Be,"invalid cube map shape"),Ae.color[xe]={target:Do,data:lt[xe]}}for(xe=0;xe<6;++xe){for(var Tt=0;Tt<lt.length;++Tt)Ae.color[Tt].target=Do+xe;xe>0&&(Ae.depth=_e[0].depth,Ae.stencil=_e[0].stencil,Ae.depthStencil=_e[0].depthStencil),_e[xe]?_e[xe](Ae):_e[xe]=Q(Ae)}return n(we,{width:Be,height:Be,color:lt})}function je(qe){var xe,Ae=qe|0;if(b(Ae>0&&Ae<=T.maxCubeMapSize,"invalid radius for cube fbo"),Ae===we.width)return we;var Be=we.color;for(xe=0;xe<Be.length;++xe)Be[xe].resize(Ae);for(xe=0;xe<6;++xe)_e[xe].resize(Ae);return we.width=we.height=Ae,we}return we(fe),n(we,{faces:_e,resize:je,_reglType:"framebufferCube",destroy:function(){_e.forEach(function(qe){qe.destroy()})}})}function be(){Y.cur=null,Y.next=null,Y.dirty=!0,nr(se).forEach(function(fe){fe.framebuffer=f.createFramebuffer(),ee(fe)})}return n(Y,{getFramebuffer:function(fe){if(typeof fe=="function"&&fe._reglType==="framebuffer"){var _e=fe._framebuffer;if(_e instanceof Ee)return _e}return null},create:Q,createCube:Me,clear:function(){nr(se).forEach(ke)},restore:be})}var mg=5126,$u=34962,Io=34963,xu=["attributes","elements","offset","count","primitive","instances"];function Ri(){this.state=0,this.x=0,this.y=0,this.z=0,this.w=0,this.buffer=null,this.size=0,this.normalized=!1,this.type=mg,this.offset=0,this.stride=0,this.divisor=0}function pg(f,v,T,X,K,q,Y){for(var ie=T.maxAttributes,ae=new Array(ie),he=0;he<ie;++he)ae[he]=new Ri;var pe=0,me={},ye={Record:Ri,scope:{},state:ae,currentVAO:null,targetVAO:null,restore:de()?$e:function(){},createVAO:ke,getVAO:H,destroyBuffer:ce,setVAO:de()?ue:Te,clear:de()?se:function(){}};function ce(ee){for(var Q=0;Q<ae.length;++Q){var Me=ae[Q];Me.buffer===ee&&(f.disableVertexAttribArray(Q),Me.buffer=null)}}function de(){return v.oes_vertex_array_object}function D(){return v.angle_instanced_arrays}function H(ee){return typeof ee=="function"&&ee._vao?ee._vao:null}function ue(ee){if(ee!==ye.currentVAO){var Q=de();ee?Q.bindVertexArrayOES(ee.vao):Q.bindVertexArrayOES(null),ye.currentVAO=ee}}function Te(ee){if(ee!==ye.currentVAO){if(ee)ee.bindAttrs();else{for(var Q=D(),Me=0;Me<ae.length;++Me){var be=ae[Me];be.buffer?(f.enableVertexAttribArray(Me),be.buffer.bind(),f.vertexAttribPointer(Me,be.size,be.type,be.normalized,be.stride,be.offfset),Q&&be.divisor&&Q.vertexAttribDivisorANGLE(Me,be.divisor)):(f.disableVertexAttribArray(Me),f.vertexAttrib4f(Me,be.x,be.y,be.z,be.w))}Y.elements?f.bindBuffer(Io,Y.elements.buffer.buffer):f.bindBuffer(Io,null)}ye.currentVAO=ee}}function se(){nr(me).forEach(function(ee){ee.destroy()})}function Ee(){this.id=++pe,this.attributes=[],this.elements=null,this.ownsElements=!1,this.count=0,this.offset=0,this.instances=-1,this.primitive=4;var ee=de();ee?this.vao=ee.createVertexArrayOES():this.vao=null,me[this.id]=this,this.buffers=[]}Ee.prototype.bindAttrs=function(){for(var ee=D(),Q=this.attributes,Me=0;Me<Q.length;++Me){var be=Q[Me];be.buffer?(f.enableVertexAttribArray(Me),f.bindBuffer($u,be.buffer.buffer),f.vertexAttribPointer(Me,be.size,be.type,be.normalized,be.stride,be.offset),ee&&be.divisor&&ee.vertexAttribDivisorANGLE(Me,be.divisor)):(f.disableVertexAttribArray(Me),f.vertexAttrib4f(Me,be.x,be.y,be.z,be.w))}for(var fe=Q.length;fe<ie;++fe)f.disableVertexAttribArray(fe);var _e=q.getElements(this.elements);_e?f.bindBuffer(Io,_e.buffer.buffer):f.bindBuffer(Io,null)},Ee.prototype.refresh=function(){var ee=de();ee&&(ee.bindVertexArrayOES(this.vao),this.bindAttrs(),ye.currentVAO=null,ee.bindVertexArrayOES(null))},Ee.prototype.destroy=function(){if(this.vao){var ee=de();this===ye.currentVAO&&(ye.currentVAO=null,ee.bindVertexArrayOES(null)),ee.deleteVertexArrayOES(this.vao),this.vao=null}this.ownsElements&&(this.elements.destroy(),this.elements=null,this.ownsElements=!1),me[this.id]&&(delete me[this.id],X.vaoCount-=1)};function $e(){var ee=de();ee&&nr(me).forEach(function(Q){Q.refresh()})}function ke(ee){var Q=new Ee;X.vaoCount+=1;function Me(be){var fe;if(Array.isArray(be))fe=be,Q.elements&&Q.ownsElements&&Q.elements.destroy(),Q.elements=null,Q.ownsElements=!1,Q.offset=0,Q.count=0,Q.instances=-1,Q.primitive=4;else{if(b(typeof be=="object","invalid arguments for create vao"),b("attributes"in be,"must specify attributes for vao"),be.elements){var _e=be.elements;Q.ownsElements?typeof _e=="function"&&_e._reglType==="elements"?(Q.elements.destroy(),Q.ownsElements=!1):(Q.elements(_e),Q.ownsElements=!1):q.getElements(be.elements)?(Q.elements=be.elements,Q.ownsElements=!1):(Q.elements=q.create(be.elements),Q.ownsElements=!0)}else Q.elements=null,Q.ownsElements=!1;fe=be.attributes,Q.offset=0,Q.count=-1,Q.instances=-1,Q.primitive=4,Q.elements&&(Q.count=Q.elements._elements.vertCount,Q.primitive=Q.elements._elements.primType),"offset"in be&&(Q.offset=be.offset|0),"count"in be&&(Q.count=be.count|0),"instances"in be&&(Q.instances=be.instances|0),"primitive"in be&&(b(be.primitive in qr,"bad primitive type: "+be.primitive),Q.primitive=qr[be.primitive]),b.optional(()=>{for(var ht=Object.keys(be),mt=0;mt<ht.length;++mt)b(xu.indexOf(ht[mt])>=0,'invalid option for vao: "'+ht[mt]+'" valid options are '+xu)}),b(Array.isArray(fe),"attributes must be an array")}b(fe.length<ie,"too many attributes"),b(fe.length>0,"must specify at least one attribute");var we={},je=Q.attributes;je.length=fe.length;for(var qe=0;qe<fe.length;++qe){var xe=fe[qe],Ae=je[qe]=new Ri,Be=xe.data||xe;if(Array.isArray(Be)||r(Be)||yr(Be)){var He;Q.buffers[qe]&&(He=Q.buffers[qe],r(Be)&&He._buffer.byteLength>=Be.byteLength?He.subdata(Be):(He.destroy(),Q.buffers[qe]=null)),Q.buffers[qe]||(He=Q.buffers[qe]=K.create(xe,$u,!1,!0)),Ae.buffer=K.getBuffer(He),Ae.size=Ae.buffer.dimension|0,Ae.normalized=!1,Ae.type=Ae.buffer.dtype,Ae.offset=0,Ae.stride=0,Ae.divisor=0,Ae.state=1,we[qe]=1}else K.getBuffer(xe)?(Ae.buffer=K.getBuffer(xe),Ae.size=Ae.buffer.dimension|0,Ae.normalized=!1,Ae.type=Ae.buffer.dtype,Ae.offset=0,Ae.stride=0,Ae.divisor=0,Ae.state=1):K.getBuffer(xe.buffer)?(Ae.buffer=K.getBuffer(xe.buffer),Ae.size=(+xe.size||Ae.buffer.dimension)|0,Ae.normalized=!!xe.normalized||!1,"type"in xe?(b.parameter(xe.type,fn,"invalid buffer type"),Ae.type=fn[xe.type]):Ae.type=Ae.buffer.dtype,Ae.offset=(xe.offset||0)|0,Ae.stride=(xe.stride||0)|0,Ae.divisor=(xe.divisor||0)|0,Ae.state=1,b(Ae.size>=1&&Ae.size<=4,"size must be between 1 and 4"),b(Ae.offset>=0,"invalid offset"),b(Ae.stride>=0&&Ae.stride<=255,"stride must be between 0 and 255"),b(Ae.divisor>=0,"divisor must be positive"),b(!Ae.divisor||!!v.angle_instanced_arrays,"ANGLE_instanced_arrays must be enabled to use divisor")):"x"in xe?(b(qe>0,"first attribute must not be a constant"),Ae.x=+xe.x||0,Ae.y=+xe.y||0,Ae.z=+xe.z||0,Ae.w=+xe.w||0,Ae.state=2):b(!1,"invalid attribute spec for location "+qe)}for(var Je=0;Je<Q.buffers.length;++Je)!we[Je]&&Q.buffers[Je]&&(Q.buffers[Je].destroy(),Q.buffers[Je]=null);return Q.refresh(),Me}return Me.destroy=function(){for(var be=0;be<Q.buffers.length;++be)Q.buffers[be]&&Q.buffers[be].destroy();Q.buffers.length=0,Q.ownsElements&&(Q.elements.destroy(),Q.elements=null,Q.ownsElements=!1),Q.destroy()},Me._vao=Q,Me._reglType="vao",Me(ee)}return ye}var Eu=35632,vg=35633,gg=35718,yg=35721;function bg(f,v,T,X){var K={},q={};function Y(D,H,ue,Te){this.name=D,this.id=H,this.location=ue,this.info=Te}function ie(D,H){for(var ue=0;ue<D.length;++ue)if(D[ue].id===H.id){D[ue].location=H.location;return}D.push(H)}function ae(D,H,ue){var Te=D===Eu?K:q,se=Te[H];if(!se){var Ee=v.str(H);se=f.createShader(D),f.shaderSource(se,Ee),f.compileShader(se),b.shaderError(f,se,Ee,D,ue),Te[H]=se}return se}var he={},pe=[],me=0;function ye(D,H){this.id=me++,this.fragId=D,this.vertId=H,this.program=null,this.uniforms=[],this.attributes=[],this.refCount=1,X.profile&&(this.stats={uniformsCount:0,attributesCount:0})}function ce(D,H,ue){var Te,se,Ee=ae(Eu,D.fragId),$e=ae(vg,D.vertId),ke=D.program=f.createProgram();if(f.attachShader(ke,Ee),f.attachShader(ke,$e),ue)for(Te=0;Te<ue.length;++Te){var ee=ue[Te];f.bindAttribLocation(ke,ee[0],ee[1])}f.linkProgram(ke),b.linkError(f,ke,v.str(D.fragId),v.str(D.vertId),H);var Q=f.getProgramParameter(ke,gg);X.profile&&(D.stats.uniformsCount=Q);var Me=D.uniforms;for(Te=0;Te<Q;++Te)if(se=f.getActiveUniform(ke,Te),se){if(se.size>1)for(var be=0;be<se.size;++be){var fe=se.name.replace("[0]","["+be+"]");ie(Me,new Y(fe,v.id(fe),f.getUniformLocation(ke,fe),se))}var _e=se.name;se.size>1&&(_e=_e.replace("[0]","")),ie(Me,new Y(_e,v.id(_e),f.getUniformLocation(ke,_e),se))}var we=f.getProgramParameter(ke,yg);X.profile&&(D.stats.attributesCount=we);var je=D.attributes;for(Te=0;Te<we;++Te)se=f.getActiveAttrib(ke,Te),se&&ie(je,new Y(se.name,v.id(se.name),f.getAttribLocation(ke,se.name),se))}X.profile&&(T.getMaxUniformsCount=function(){var D=0;return pe.forEach(function(H){H.stats.uniformsCount>D&&(D=H.stats.uniformsCount)}),D},T.getMaxAttributesCount=function(){var D=0;return pe.forEach(function(H){H.stats.attributesCount>D&&(D=H.stats.attributesCount)}),D});function de(){K={},q={};for(var D=0;D<pe.length;++D)ce(pe[D],null,pe[D].attributes.map(function(H){return[H.location,H.name]}))}return{clear:function(){var D=f.deleteShader.bind(f);nr(K).forEach(D),K={},nr(q).forEach(D),q={},pe.forEach(function(H){f.deleteProgram(H.program)}),pe.length=0,he={},T.shaderCount=0},program:function(D,H,ue,Te){b.command(D>=0,"missing vertex shader",ue),b.command(H>=0,"missing fragment shader",ue);var se=he[H];se||(se=he[H]={});var Ee=se[D];if(Ee&&(Ee.refCount++,!Te))return Ee;var $e=new ye(H,D);return T.shaderCount++,ce($e,ue,Te),Ee||(se[D]=$e),pe.push($e),n($e,{destroy:function(){if($e.refCount--,$e.refCount<=0){f.deleteProgram($e.program);var ke=pe.indexOf($e);pe.splice(ke,1),T.shaderCount--}se[$e.vertId].refCount<=0&&(f.deleteShader(q[$e.vertId]),delete q[$e.vertId],delete he[$e.fragId][$e.vertId]),Object.keys(he[$e.fragId]).length||(f.deleteShader(K[$e.fragId]),delete K[$e.fragId],delete he[$e.fragId])}})},restore:de,shader:ae,frag:-1,vert:-1}}var _g=6408,Fs=5121,wg=3333,Vo=5126;function $g(f,v,T,X,K,q,Y){function ie(pe){var me;v.next===null?(b(K.preserveDrawingBuffer,'you must create a webgl context with "preserveDrawingBuffer":true in order to read pixels from the drawing buffer'),me=Fs):(b(v.next.colorAttachments[0].texture!==null,"You cannot read from a renderbuffer"),me=v.next.colorAttachments[0].texture._texture.type,b.optional(function(){q.oes_texture_float?(b(me===Fs||me===Vo,"Reading from a framebuffer is only allowed for the types 'uint8' and 'float'"),me===Vo&&b(Y.readFloat,"Reading 'float' values is not permitted in your browser. For a fallback, please see: https://www.npmjs.com/package/glsl-read-float")):b(me===Fs,"Reading from a framebuffer is only allowed for the type 'uint8'")}));var ye=0,ce=0,de=X.framebufferWidth,D=X.framebufferHeight,H=null;r(pe)?H=pe:pe&&(b.type(pe,"object","invalid arguments to regl.read()"),ye=pe.x|0,ce=pe.y|0,b(ye>=0&&ye<X.framebufferWidth,"invalid x offset for regl.read"),b(ce>=0&&ce<X.framebufferHeight,"invalid y offset for regl.read"),de=(pe.width||X.framebufferWidth-ye)|0,D=(pe.height||X.framebufferHeight-ce)|0,H=pe.data||null),H&&(me===Fs?b(H instanceof Uint8Array,"buffer must be 'Uint8Array' when reading from a framebuffer of type 'uint8'"):me===Vo&&b(H instanceof Float32Array,"buffer must be 'Float32Array' when reading from a framebuffer of type 'float'")),b(de>0&&de+ye<=X.framebufferWidth,"invalid width for read pixels"),b(D>0&&D+ce<=X.framebufferHeight,"invalid height for read pixels"),T();var ue=de*D*4;return H||(me===Fs?H=new Uint8Array(ue):me===Vo&&(H=H||new Float32Array(ue))),b.isTypedArray(H,"data buffer for regl.read() must be a typedarray"),b(H.byteLength>=ue,"data buffer for regl.read() too small"),f.pixelStorei(wg,4),f.readPixels(ye,ce,de,D,_g,me,H),H}function ae(pe){var me;return v.setFBO({framebuffer:pe.framebuffer},function(){me=ie(pe)}),me}function he(pe){return!pe||!("framebuffer"in pe)?ie(pe):ae(pe)}return he}function Yn(f){return Array.prototype.slice.call(f)}function Wn(f){return Yn(f).join("")}function xg(){var f=0,v=[],T=[];function X(me){for(var ye=0;ye<T.length;++ye)if(T[ye]===me)return v[ye];var ce="g"+f++;return v.push(ce),T.push(me),ce}function K(){var me=[];function ye(){me.push.apply(me,Yn(arguments))}var ce=[];function de(){var D="v"+f++;return ce.push(D),arguments.length>0&&(me.push(D,"="),me.push.apply(me,Yn(arguments)),me.push(";")),D}return n(ye,{def:de,toString:function(){return Wn([ce.length>0?"var "+ce.join(",")+";":"",Wn(me)])}})}function q(){var me=K(),ye=K(),ce=me.toString,de=ye.toString;function D(H,ue){ye(H,ue,"=",me.def(H,ue),";")}return n(function(){me.apply(me,Yn(arguments))},{def:me.def,entry:me,exit:ye,save:D,set:function(H,ue,Te){D(H,ue),me(H,ue,"=",Te,";")},toString:function(){return ce()+de()}})}function Y(){var me=Wn(arguments),ye=q(),ce=q(),de=ye.toString,D=ce.toString;return n(ye,{then:function(){return ye.apply(ye,Yn(arguments)),this},else:function(){return ce.apply(ce,Yn(arguments)),this},toString:function(){var H=D();return H&&(H="else{"+H+"}"),Wn(["if(",me,"){",de(),"}",H])}})}var ie=K(),ae={};function he(me,ye){var ce=[];function de(){var se="a"+ce.length;return ce.push(se),se}ye=ye||0;for(var D=0;D<ye;++D)de();var H=q(),ue=H.toString,Te=ae[me]=n(H,{arg:de,toString:function(){return Wn(["function(",ce.join(),"){",ue(),"}"])}});return Te}function pe(){var me=['"use strict";',ie,"return {"];Object.keys(ae).forEach(function(de){me.push('"',de,'":',ae[de].toString(),",")}),me.push("}");var ye=Wn(me).replace(/;/g,`;
`).replace(/}/g,`}
`).replace(/{/g,`{
`),ce=Function.apply(null,v.concat(ye));return ce.apply(null,T)}return{global:ie,link:X,block:K,proc:he,scope:q,cond:Y,compile:pe}}var Zn="xyzw".split(""),Au=5121,Qn=1,Fi=2,Ni=0,Gi=1,ki=2,Di=3,zo=4,Tu=5,Su=6,Pu="dither",Cu="blend.enable",Mu="blend.color",Bi="blend.equation",Ii="blend.func",Ou="depth.enable",Lu="depth.func",Ru="depth.range",Fu="depth.mask",Vi="colorMask",Nu="cull.enable",Gu="cull.face",zi="frontFace",Ui="lineWidth",ku="polygonOffset.enable",qi="polygonOffset.offset",Du="sample.alpha",Bu="sample.enable",Xi="sample.coverage",Iu="stencil.enable",Vu="stencil.mask",ji="stencil.func",Hi="stencil.opFront",Ns="stencil.opBack",zu="scissor.enable",Uo="scissor.box",kr="viewport",Gs="profile",pn="framebuffer",ks="vert",Ds="frag",vn="elements",gn="primitive",yn="count",qo="offset",Xo="instances",Bs="vao",Yi="Width",Wi="Height",Kn=pn+Yi,Jn=pn+Wi,Eg=kr+Yi,Ag=kr+Wi,Uu="drawingBuffer",qu=Uu+Yi,Xu=Uu+Wi,Tg=[Ii,Bi,ji,Hi,Ns,Xi,kr,Uo,qi],es=34962,Zi=34963,Sg=35632,Pg=35633,ju=3553,Cg=34067,Mg=2884,Og=3042,Lg=3024,Rg=2960,Fg=2929,Ng=3089,Gg=32823,kg=32926,Dg=32928,Qi=5126,jo=35664,Ho=35665,Yo=35666,Ki=5124,Wo=35667,Zo=35668,Qo=35669,Ji=35670,Ko=35671,Jo=35672,ea=35673,Is=35674,Vs=35675,zs=35676,Us=35678,qs=35680,ec=4,Xs=1028,bn=1029,Hu=2304,tc=2305,Bg=32775,Ig=32776,Vg=519,jr=7680,Yu=0,Wu=1,Zu=32774,zg=513,Qu=36160,Ug=36064,Ar={0:0,1:1,zero:0,one:1,"src color":768,"one minus src color":769,"src alpha":770,"one minus src alpha":771,"dst color":774,"one minus dst color":775,"dst alpha":772,"one minus dst alpha":773,"constant color":32769,"one minus constant color":32770,"constant alpha":32771,"one minus constant alpha":32772,"src alpha saturate":776},Ku=["constant color, constant alpha","one minus constant color, constant alpha","constant color, one minus constant alpha","one minus constant color, one minus constant alpha","constant alpha, constant color","constant alpha, one minus constant color","one minus constant alpha, constant color","one minus constant alpha, one minus constant color"],ts={never:512,less:513,"<":513,equal:514,"=":514,"==":514,"===":514,lequal:515,"<=":515,greater:516,">":516,notequal:517,"!=":517,"!==":517,gequal:518,">=":518,always:519},Hr={0:0,zero:0,keep:7680,replace:7681,increment:7682,decrement:7683,"increment wrap":34055,"decrement wrap":34056,invert:5386},Ju={frag:Sg,vert:Pg},rc={cw:Hu,ccw:tc};function ta(f){return Array.isArray(f)||r(f)||yr(f)}function e1(f){return f.sort(function(v,T){return v===kr?-1:T===kr?1:v<T?-1:1})}function Pt(f,v,T,X){this.thisDep=f,this.contextDep=v,this.propDep=T,this.append=X}function Yr(f){return f&&!(f.thisDep||f.contextDep||f.propDep)}function wt(f){return new Pt(!1,!1,!1,f)}function Ht(f,v){var T=f.type;if(T===Ni){var X=f.data.length;return new Pt(!0,X>=1,X>=2,v)}else if(T===zo){var K=f.data;return new Pt(K.thisDep,K.contextDep,K.propDep,v)}else{if(T===Tu)return new Pt(!1,!1,!1,v);if(T===Su){for(var q=!1,Y=!1,ie=!1,ae=0;ae<f.data.length;++ae){var he=f.data[ae];if(he.type===Gi)ie=!0;else if(he.type===ki)Y=!0;else if(he.type===Di)q=!0;else if(he.type===Ni){q=!0;var pe=he.data;pe>=1&&(Y=!0),pe>=2&&(ie=!0)}else he.type===zo&&(q=q||he.data.thisDep,Y=Y||he.data.contextDep,ie=ie||he.data.propDep)}return new Pt(q,Y,ie,v)}else return new Pt(T===Di,T===ki,T===Gi,v)}}var t1=new Pt(!1,!1,!1,function(){});function qg(f,v,T,X,K,q,Y,ie,ae,he,pe,me,ye,ce,de){var D=he.Record,H={add:32774,subtract:32778,"reverse subtract":32779};T.ext_blend_minmax&&(H.min=Bg,H.max=Ig);var ue=T.angle_instanced_arrays,Te=T.webgl_draw_buffers,se=T.oes_vertex_array_object,Ee={dirty:!0,profile:de.profile},$e={},ke=[],ee={},Q={};function Me(_){return _.replace(".","_")}function be(_,p,P){var k=Me(_);ke.push(_),$e[k]=Ee[k]=!!P,ee[k]=p}function fe(_,p,P){var k=Me(_);ke.push(_),Array.isArray(P)?(Ee[k]=P.slice(),$e[k]=P.slice()):Ee[k]=$e[k]=P,Q[k]=p}be(Pu,Lg),be(Cu,Og),fe(Mu,"blendColor",[0,0,0,0]),fe(Bi,"blendEquationSeparate",[Zu,Zu]),fe(Ii,"blendFuncSeparate",[Wu,Yu,Wu,Yu]),be(Ou,Fg,!0),fe(Lu,"depthFunc",zg),fe(Ru,"depthRange",[0,1]),fe(Fu,"depthMask",!0),fe(Vi,Vi,[!0,!0,!0,!0]),be(Nu,Mg),fe(Gu,"cullFace",bn),fe(zi,zi,tc),fe(Ui,Ui,1),be(ku,Gg),fe(qi,"polygonOffset",[0,0]),be(Du,kg),be(Bu,Dg),fe(Xi,"sampleCoverage",[1,!1]),be(Iu,Rg),fe(Vu,"stencilMask",-1),fe(ji,"stencilFunc",[Vg,0,-1]),fe(Hi,"stencilOpSeparate",[Xs,jr,jr,jr]),fe(Ns,"stencilOpSeparate",[bn,jr,jr,jr]),be(zu,Ng),fe(Uo,"scissor",[0,0,f.drawingBufferWidth,f.drawingBufferHeight]),fe(kr,kr,[0,0,f.drawingBufferWidth,f.drawingBufferHeight]);var _e={gl:f,context:ye,strings:v,next:$e,current:Ee,draw:me,elements:q,buffer:K,shader:pe,attributes:he.state,vao:he,uniforms:ae,framebuffer:ie,extensions:T,timer:ce,isBufferArgs:ta},we={primTypes:qr,compareFuncs:ts,blendFuncs:Ar,blendEquations:H,stencilOps:Hr,glTypes:fn,orientationType:rc};b.optional(function(){_e.isArrayLike=dt}),Te&&(we.backBuffer=[bn],we.drawBuffer=rr(X.maxDrawbuffers,function(_){return _===0?[0]:rr(_,function(p){return Ug+p})}));var je=0;function qe(){var _=xg(),p=_.link,P=_.global;_.id=je++,_.batchId="0";var k=p(_e),B=_.shared={props:"a0"};Object.keys(_e).forEach(function(A){B[A]=P.def(k,".",A)}),b.optional(function(){_.CHECK=p(b),_.commandStr=b.guessCommand(),_.command=p(_.commandStr),_.assert=function(A,x,V){A("if(!(",x,"))",this.CHECK,".commandRaise(",p(V),",",this.command,");")},we.invalidBlendCombinations=Ku});var M=_.next={},C=_.current={};Object.keys(Q).forEach(function(A){Array.isArray(Ee[A])&&(M[A]=P.def(B.next,".",A),C[A]=P.def(B.current,".",A))});var G=_.constants={};Object.keys(we).forEach(function(A){G[A]=P.def(JSON.stringify(we[A]))}),_.invoke=function(A,x){switch(x.type){case Ni:var V=["this",B.context,B.props,_.batchId];return A.def(p(x.data),".call(",V.slice(0,Math.max(x.data.length+1,4)),")");case Gi:return A.def(B.props,x.data);case ki:return A.def(B.context,x.data);case Di:return A.def("this",x.data);case zo:return x.data.append(_,A),x.data.ref;case Tu:return x.data.toString();case Su:return x.data.map(function(I){return _.invoke(A,I)})}},_.attribCache={};var w={};return _.scopeAttrib=function(A){var x=v.id(A);if(x in w)return w[x];var V=he.scope[x];V||(V=he.scope[x]=new D);var I=w[x]=p(V);return I},_}function xe(_){var p=_.static,P=_.dynamic,k;if(Gs in p){var B=!!p[Gs];k=wt(function(C,G){return B}),k.enable=B}else if(Gs in P){var M=P[Gs];k=Ht(M,function(C,G){return C.invoke(G,M)})}return k}function Ae(_,p){var P=_.static,k=_.dynamic;if(pn in P){var B=P[pn];return B?(B=ie.getFramebuffer(B),b.command(B,"invalid framebuffer object"),wt(function(C,G){var w=C.link(B),A=C.shared;G.set(A.framebuffer,".next",w);var x=A.context;return G.set(x,"."+Kn,w+".width"),G.set(x,"."+Jn,w+".height"),w})):wt(function(C,G){var w=C.shared;G.set(w.framebuffer,".next","null");var A=w.context;return G.set(A,"."+Kn,A+"."+qu),G.set(A,"."+Jn,A+"."+Xu),"null"})}else if(pn in k){var M=k[pn];return Ht(M,function(C,G){var w=C.invoke(G,M),A=C.shared,x=A.framebuffer,V=G.def(x,".getFramebuffer(",w,")");b.optional(function(){C.assert(G,"!"+w+"||"+V,"invalid framebuffer object")}),G.set(x,".next",V);var I=A.context;return G.set(I,"."+Kn,V+"?"+V+".width:"+I+"."+qu),G.set(I,"."+Jn,V+"?"+V+".height:"+I+"."+Xu),V})}else return null}function Be(_,p,P){var k=_.static,B=_.dynamic;function M(w){if(w in k){var A=k[w];b.commandType(A,"object","invalid "+w,P.commandStr);var x=!0,V=A.x|0,I=A.y|0,Z,te;return"width"in A?(Z=A.width|0,b.command(Z>=0,"invalid "+w,P.commandStr)):x=!1,"height"in A?(te=A.height|0,b.command(te>=0,"invalid "+w,P.commandStr)):x=!1,new Pt(!x&&p&&p.thisDep,!x&&p&&p.contextDep,!x&&p&&p.propDep,function(Fe,Se){var re=Fe.shared.context,W=Z;"width"in A||(W=Se.def(re,".",Kn,"-",V));var Re=te;return"height"in A||(Re=Se.def(re,".",Jn,"-",I)),[V,I,W,Re]})}else if(w in B){var ge=B[w],Ve=Ht(ge,function(Fe,Se){var re=Fe.invoke(Se,ge);b.optional(function(){Fe.assert(Se,re+"&&typeof "+re+'==="object"',"invalid "+w)});var W=Fe.shared.context,Re=Se.def(re,".x|0"),Oe=Se.def(re,".y|0"),Ie=Se.def('"width" in ',re,"?",re,".width|0:","(",W,".",Kn,"-",Re,")"),it=Se.def('"height" in ',re,"?",re,".height|0:","(",W,".",Jn,"-",Oe,")");return b.optional(function(){Fe.assert(Se,Ie+">=0&&"+it+">=0","invalid "+w)}),[Re,Oe,Ie,it]});return p&&(Ve.thisDep=Ve.thisDep||p.thisDep,Ve.contextDep=Ve.contextDep||p.contextDep,Ve.propDep=Ve.propDep||p.propDep),Ve}else return p?new Pt(p.thisDep,p.contextDep,p.propDep,function(Fe,Se){var re=Fe.shared.context;return[0,0,Se.def(re,".",Kn),Se.def(re,".",Jn)]}):null}var C=M(kr);if(C){var G=C;C=new Pt(C.thisDep,C.contextDep,C.propDep,function(w,A){var x=G.append(w,A),V=w.shared.context;return A.set(V,"."+Eg,x[2]),A.set(V,"."+Ag,x[3]),x})}return{viewport:C,scissor_box:M(Uo)}}function He(_,p){var P=_.static,k=typeof P[Ds]=="string"&&typeof P[ks]=="string";if(k){if(Object.keys(p.dynamic).length>0)return null;var B=p.static,M=Object.keys(B);if(M.length>0&&typeof B[M[0]]=="number"){for(var C=[],G=0;G<M.length;++G)b(typeof B[M[G]]=="number","must specify all vertex attribute locations when using vaos"),C.push([B[M[G]]|0,M[G]]);return C}}return null}function Je(_,p,P){var k=_.static,B=_.dynamic;function M(x){if(x in k){var V=v.id(k[x]);b.optional(function(){pe.shader(Ju[x],V,b.guessCommand())});var I=wt(function(){return V});return I.id=V,I}else if(x in B){var Z=B[x];return Ht(Z,function(te,ge){var Ve=te.invoke(ge,Z),Fe=ge.def(te.shared.strings,".id(",Ve,")");return b.optional(function(){ge(te.shared.shader,".shader(",Ju[x],",",Fe,",",te.command,");")}),Fe})}return null}var C=M(Ds),G=M(ks),w=null,A;return Yr(C)&&Yr(G)?(w=pe.program(G.id,C.id,null,P),A=wt(function(x,V){return x.link(w)})):A=new Pt(C&&C.thisDep||G&&G.thisDep,C&&C.contextDep||G&&G.contextDep,C&&C.propDep||G&&G.propDep,function(x,V){var I=x.shared.shader,Z;C?Z=C.append(x,V):Z=V.def(I,".",Ds);var te;G?te=G.append(x,V):te=V.def(I,".",ks);var ge=I+".program("+te+","+Z;return b.optional(function(){ge+=","+x.command}),V.def(ge+")")}),{frag:C,vert:G,progVar:A,program:w}}function ht(_,p){var P=_.static,k=_.dynamic,B={},M=!1;function C(){if(Bs in P){var Se=P[Bs];return Se!==null&&he.getVAO(Se)===null&&(Se=he.createVAO(Se)),M=!0,B.vao=Se,wt(function(W){var Re=he.getVAO(Se);return Re?W.link(Re):"null"})}else if(Bs in k){M=!0;var re=k[Bs];return Ht(re,function(W,Re){var Oe=W.invoke(Re,re);return Re.def(W.shared.vao+".getVAO("+Oe+")")})}return null}var G=C(),w=!1;function A(){if(vn in P){var Se=P[vn];if(B.elements=Se,ta(Se)){var re=B.elements=q.create(Se,!0);Se=q.getElements(re),w=!0}else Se&&(Se=q.getElements(Se),w=!0,b.command(Se,"invalid elements",p.commandStr));var W=wt(function(Oe,Ie){if(Se){var it=Oe.link(Se);return Oe.ELEMENTS=it,it}return Oe.ELEMENTS=null,null});return W.value=Se,W}else if(vn in k){w=!0;var Re=k[vn];return Ht(Re,function(Oe,Ie){var it=Oe.shared,kt=it.isBufferArgs,wn=it.elements,Dr=Oe.invoke(Ie,Re),Sr=Ie.def("null"),Wr=Ie.def(kt,"(",Dr,")"),$n=Oe.cond(Wr).then(Sr,"=",wn,".createStream(",Dr,");").else(Sr,"=",wn,".getElements(",Dr,");");return b.optional(function(){Oe.assert($n.else,"!"+Dr+"||"+Sr,"invalid elements")}),Ie.entry($n),Ie.exit(Oe.cond(Wr).then(wn,".destroyStream(",Sr,");")),Oe.ELEMENTS=Sr,Sr})}else if(M)return new Pt(G.thisDep,G.contextDep,G.propDep,function(Oe,Ie){return Ie.def(Oe.shared.vao+".currentVAO?"+Oe.shared.elements+".getElements("+Oe.shared.vao+".currentVAO.elements):null")});return null}var x=A();function V(){if(gn in P){var Se=P[gn];return B.primitive=Se,b.commandParameter(Se,qr,"invalid primitve",p.commandStr),wt(function(W,Re){return qr[Se]})}else if(gn in k){var re=k[gn];return Ht(re,function(W,Re){var Oe=W.constants.primTypes,Ie=W.invoke(Re,re);return b.optional(function(){W.assert(Re,Ie+" in "+Oe,"invalid primitive, must be one of "+Object.keys(qr))}),Re.def(Oe,"[",Ie,"]")})}else{if(w)return Yr(x)?x.value?wt(function(W,Re){return Re.def(W.ELEMENTS,".primType")}):wt(function(){return ec}):new Pt(x.thisDep,x.contextDep,x.propDep,function(W,Re){var Oe=W.ELEMENTS;return Re.def(Oe,"?",Oe,".primType:",ec)});if(M)return new Pt(G.thisDep,G.contextDep,G.propDep,function(W,Re){return Re.def(W.shared.vao+".currentVAO?"+W.shared.vao+".currentVAO.primitive:"+ec)})}return null}function I(Se,re){if(Se in P){var W=P[Se]|0;return re?B.offset=W:B.instances=W,b.command(!re||W>=0,"invalid "+Se,p.commandStr),wt(function(Oe,Ie){return re&&(Oe.OFFSET=W),W})}else if(Se in k){var Re=k[Se];return Ht(Re,function(Oe,Ie){var it=Oe.invoke(Ie,Re);return re&&(Oe.OFFSET=it,b.optional(function(){Oe.assert(Ie,it+">=0","invalid "+Se)})),it})}else if(re){if(w)return wt(function(Oe,Ie){return Oe.OFFSET=0,0});if(M)return new Pt(G.thisDep,G.contextDep,G.propDep,function(Oe,Ie){return Ie.def(Oe.shared.vao+".currentVAO?"+Oe.shared.vao+".currentVAO.offset:0")})}else if(M)return new Pt(G.thisDep,G.contextDep,G.propDep,function(Oe,Ie){return Ie.def(Oe.shared.vao+".currentVAO?"+Oe.shared.vao+".currentVAO.instances:-1")});return null}var Z=I(qo,!0);function te(){if(yn in P){var Se=P[yn]|0;return B.count=Se,b.command(typeof Se=="number"&&Se>=0,"invalid vertex count",p.commandStr),wt(function(){return Se})}else if(yn in k){var re=k[yn];return Ht(re,function(Ie,it){var kt=Ie.invoke(it,re);return b.optional(function(){Ie.assert(it,"typeof "+kt+'==="number"&&'+kt+">=0&&"+kt+"===("+kt+"|0)","invalid vertex count")}),kt})}else if(w)if(Yr(x)){if(x)return Z?new Pt(Z.thisDep,Z.contextDep,Z.propDep,function(Ie,it){var kt=it.def(Ie.ELEMENTS,".vertCount-",Ie.OFFSET);return b.optional(function(){Ie.assert(it,kt+">=0","invalid vertex offset/element buffer too small")}),kt}):wt(function(Ie,it){return it.def(Ie.ELEMENTS,".vertCount")});var W=wt(function(){return-1});return b.optional(function(){W.MISSING=!0}),W}else{var Re=new Pt(x.thisDep||Z.thisDep,x.contextDep||Z.contextDep,x.propDep||Z.propDep,function(Ie,it){var kt=Ie.ELEMENTS;return Ie.OFFSET?it.def(kt,"?",kt,".vertCount-",Ie.OFFSET,":-1"):it.def(kt,"?",kt,".vertCount:-1")});return b.optional(function(){Re.DYNAMIC=!0}),Re}else if(M){var Oe=new Pt(G.thisDep,G.contextDep,G.propDep,function(Ie,it){return it.def(Ie.shared.vao,".currentVAO?",Ie.shared.vao,".currentVAO.count:-1")});return Oe}return null}var ge=V(),Ve=te(),Fe=I(Xo,!1);return{elements:x,primitive:ge,count:Ve,instances:Fe,offset:Z,vao:G,vaoActive:M,elementsActive:w,static:B}}function mt(_,p){var P=_.static,k=_.dynamic,B={};return ke.forEach(function(M){var C=Me(M);function G(w,A){if(M in P){var x=w(P[M]);B[C]=wt(function(){return x})}else if(M in k){var V=k[M];B[C]=Ht(V,function(I,Z){return A(I,Z,I.invoke(Z,V))})}}switch(M){case Nu:case Cu:case Pu:case Iu:case Ou:case zu:case ku:case Du:case Bu:case Fu:return G(function(w){return b.commandType(w,"boolean",M,p.commandStr),w},function(w,A,x){return b.optional(function(){w.assert(A,"typeof "+x+'==="boolean"',"invalid flag "+M,w.commandStr)}),x});case Lu:return G(function(w){return b.commandParameter(w,ts,"invalid "+M,p.commandStr),ts[w]},function(w,A,x){var V=w.constants.compareFuncs;return b.optional(function(){w.assert(A,x+" in "+V,"invalid "+M+", must be one of "+Object.keys(ts))}),A.def(V,"[",x,"]")});case Ru:return G(function(w){return b.command(dt(w)&&w.length===2&&typeof w[0]=="number"&&typeof w[1]=="number"&&w[0]<=w[1],"depth range is 2d array",p.commandStr),w},function(w,A,x){b.optional(function(){w.assert(A,w.shared.isArrayLike+"("+x+")&&"+x+".length===2&&typeof "+x+'[0]==="number"&&typeof '+x+'[1]==="number"&&'+x+"[0]<="+x+"[1]","depth range must be a 2d array")});var V=A.def("+",x,"[0]"),I=A.def("+",x,"[1]");return[V,I]});case Ii:return G(function(w){b.commandType(w,"object","blend.func",p.commandStr);var A="srcRGB"in w?w.srcRGB:w.src,x="srcAlpha"in w?w.srcAlpha:w.src,V="dstRGB"in w?w.dstRGB:w.dst,I="dstAlpha"in w?w.dstAlpha:w.dst;return b.commandParameter(A,Ar,C+".srcRGB",p.commandStr),b.commandParameter(x,Ar,C+".srcAlpha",p.commandStr),b.commandParameter(V,Ar,C+".dstRGB",p.commandStr),b.commandParameter(I,Ar,C+".dstAlpha",p.commandStr),b.command(Ku.indexOf(A+", "+V)===-1,"unallowed blending combination (srcRGB, dstRGB) = ("+A+", "+V+")",p.commandStr),[Ar[A],Ar[V],Ar[x],Ar[I]]},function(w,A,x){var V=w.constants.blendFuncs;b.optional(function(){w.assert(A,x+"&&typeof "+x+'==="object"',"invalid blend func, must be an object")});function I(re,W){var Re=A.def('"',re,W,'" in ',x,"?",x,".",re,W,":",x,".",re);return b.optional(function(){w.assert(A,Re+" in "+V,"invalid "+M+"."+re+W+", must be one of "+Object.keys(Ar))}),Re}var Z=I("src","RGB"),te=I("dst","RGB");b.optional(function(){var re=w.constants.invalidBlendCombinations;w.assert(A,re+".indexOf("+Z+'+", "+'+te+") === -1 ","unallowed blending combination for (srcRGB, dstRGB)")});var ge=A.def(V,"[",Z,"]"),Ve=A.def(V,"[",I("src","Alpha"),"]"),Fe=A.def(V,"[",te,"]"),Se=A.def(V,"[",I("dst","Alpha"),"]");return[ge,Fe,Ve,Se]});case Bi:return G(function(w){if(typeof w=="string")return b.commandParameter(w,H,"invalid "+M,p.commandStr),[H[w],H[w]];if(typeof w=="object")return b.commandParameter(w.rgb,H,M+".rgb",p.commandStr),b.commandParameter(w.alpha,H,M+".alpha",p.commandStr),[H[w.rgb],H[w.alpha]];b.commandRaise("invalid blend.equation",p.commandStr)},function(w,A,x){var V=w.constants.blendEquations,I=A.def(),Z=A.def(),te=w.cond("typeof ",x,'==="string"');return b.optional(function(){function ge(Ve,Fe,Se){w.assert(Ve,Se+" in "+V,"invalid "+Fe+", must be one of "+Object.keys(H))}ge(te.then,M,x),w.assert(te.else,x+"&&typeof "+x+'==="object"',"invalid "+M),ge(te.else,M+".rgb",x+".rgb"),ge(te.else,M+".alpha",x+".alpha")}),te.then(I,"=",Z,"=",V,"[",x,"];"),te.else(I,"=",V,"[",x,".rgb];",Z,"=",V,"[",x,".alpha];"),A(te),[I,Z]});case Mu:return G(function(w){return b.command(dt(w)&&w.length===4,"blend.color must be a 4d array",p.commandStr),rr(4,function(A){return+w[A]})},function(w,A,x){return b.optional(function(){w.assert(A,w.shared.isArrayLike+"("+x+")&&"+x+".length===4","blend.color must be a 4d array")}),rr(4,function(V){return A.def("+",x,"[",V,"]")})});case Vu:return G(function(w){return b.commandType(w,"number",C,p.commandStr),w|0},function(w,A,x){return b.optional(function(){w.assert(A,"typeof "+x+'==="number"',"invalid stencil.mask")}),A.def(x,"|0")});case ji:return G(function(w){b.commandType(w,"object",C,p.commandStr);var A=w.cmp||"keep",x=w.ref||0,V="mask"in w?w.mask:-1;return b.commandParameter(A,ts,M+".cmp",p.commandStr),b.commandType(x,"number",M+".ref",p.commandStr),b.commandType(V,"number",M+".mask",p.commandStr),[ts[A],x,V]},function(w,A,x){var V=w.constants.compareFuncs;b.optional(function(){function ge(){w.assert(A,Array.prototype.join.call(arguments,""),"invalid stencil.func")}ge(x+"&&typeof ",x,'==="object"'),ge('!("cmp" in ',x,")||(",x,".cmp in ",V,")")});var I=A.def('"cmp" in ',x,"?",V,"[",x,".cmp]",":",jr),Z=A.def(x,".ref|0"),te=A.def('"mask" in ',x,"?",x,".mask|0:-1");return[I,Z,te]});case Hi:case Ns:return G(function(w){b.commandType(w,"object",C,p.commandStr);var A=w.fail||"keep",x=w.zfail||"keep",V=w.zpass||"keep";return b.commandParameter(A,Hr,M+".fail",p.commandStr),b.commandParameter(x,Hr,M+".zfail",p.commandStr),b.commandParameter(V,Hr,M+".zpass",p.commandStr),[M===Ns?bn:Xs,Hr[A],Hr[x],Hr[V]]},function(w,A,x){var V=w.constants.stencilOps;b.optional(function(){w.assert(A,x+"&&typeof "+x+'==="object"',"invalid "+M)});function I(Z){return b.optional(function(){w.assert(A,'!("'+Z+'" in '+x+")||("+x+"."+Z+" in "+V+")","invalid "+M+"."+Z+", must be one of "+Object.keys(Hr))}),A.def('"',Z,'" in ',x,"?",V,"[",x,".",Z,"]:",jr)}return[M===Ns?bn:Xs,I("fail"),I("zfail"),I("zpass")]});case qi:return G(function(w){b.commandType(w,"object",C,p.commandStr);var A=w.factor|0,x=w.units|0;return b.commandType(A,"number",C+".factor",p.commandStr),b.commandType(x,"number",C+".units",p.commandStr),[A,x]},function(w,A,x){b.optional(function(){w.assert(A,x+"&&typeof "+x+'==="object"',"invalid "+M)});var V=A.def(x,".factor|0"),I=A.def(x,".units|0");return[V,I]});case Gu:return G(function(w){var A=0;return w==="front"?A=Xs:w==="back"&&(A=bn),b.command(!!A,C,p.commandStr),A},function(w,A,x){return b.optional(function(){w.assert(A,x+'==="front"||'+x+'==="back"',"invalid cull.face")}),A.def(x,'==="front"?',Xs,":",bn)});case Ui:return G(function(w){return b.command(typeof w=="number"&&w>=X.lineWidthDims[0]&&w<=X.lineWidthDims[1],"invalid line width, must be a positive number between "+X.lineWidthDims[0]+" and "+X.lineWidthDims[1],p.commandStr),w},function(w,A,x){return b.optional(function(){w.assert(A,"typeof "+x+'==="number"&&'+x+">="+X.lineWidthDims[0]+"&&"+x+"<="+X.lineWidthDims[1],"invalid line width")}),x});case zi:return G(function(w){return b.commandParameter(w,rc,C,p.commandStr),rc[w]},function(w,A,x){return b.optional(function(){w.assert(A,x+'==="cw"||'+x+'==="ccw"',"invalid frontFace, must be one of cw,ccw")}),A.def(x+'==="cw"?'+Hu+":"+tc)});case Vi:return G(function(w){return b.command(dt(w)&&w.length===4,"color.mask must be length 4 array",p.commandStr),w.map(function(A){return!!A})},function(w,A,x){return b.optional(function(){w.assert(A,w.shared.isArrayLike+"("+x+")&&"+x+".length===4","invalid color.mask")}),rr(4,function(V){return"!!"+x+"["+V+"]"})});case Xi:return G(function(w){b.command(typeof w=="object"&&w,C,p.commandStr);var A="value"in w?w.value:1,x=!!w.invert;return b.command(typeof A=="number"&&A>=0&&A<=1,"sample.coverage.value must be a number between 0 and 1",p.commandStr),[A,x]},function(w,A,x){b.optional(function(){w.assert(A,x+"&&typeof "+x+'==="object"',"invalid sample.coverage")});var V=A.def('"value" in ',x,"?+",x,".value:1"),I=A.def("!!",x,".invert");return[V,I]})}}),B}function tt(_,p){var P=_.static,k=_.dynamic,B={};return Object.keys(P).forEach(function(M){var C=P[M],G;if(typeof C=="number"||typeof C=="boolean")G=wt(function(){return C});else if(typeof C=="function"){var w=C._reglType;w==="texture2d"||w==="textureCube"?G=wt(function(A){return A.link(C)}):w==="framebuffer"||w==="framebufferCube"?(b.command(C.color.length>0,'missing color attachment for framebuffer sent to uniform "'+M+'"',p.commandStr),G=wt(function(A){return A.link(C.color[0])})):b.commandRaise('invalid data for uniform "'+M+'"',p.commandStr)}else dt(C)?G=wt(function(A){var x=A.global.def("[",rr(C.length,function(V){return b.command(typeof C[V]=="number"||typeof C[V]=="boolean","invalid uniform "+M,A.commandStr),C[V]}),"]");return x}):b.commandRaise('invalid or missing data for uniform "'+M+'"',p.commandStr);G.value=C,B[M]=G}),Object.keys(k).forEach(function(M){var C=k[M];B[M]=Ht(C,function(G,w){return G.invoke(w,C)})}),B}function Et(_,p){var P=_.static,k=_.dynamic,B={};return Object.keys(P).forEach(function(M){var C=P[M],G=v.id(M),w=new D;if(ta(C))w.state=Qn,w.buffer=K.getBuffer(K.create(C,es,!1,!0)),w.type=0;else{var A=K.getBuffer(C);if(A)w.state=Qn,w.buffer=A,w.type=0;else if(b.command(typeof C=="object"&&C,"invalid data for attribute "+M,p.commandStr),"constant"in C){var x=C.constant;w.buffer="null",w.state=Fi,typeof x=="number"?w.x=x:(b.command(dt(x)&&x.length>0&&x.length<=4,"invalid constant for attribute "+M,p.commandStr),Zn.forEach(function(Fe,Se){Se<x.length&&(w[Fe]=x[Se])}))}else{ta(C.buffer)?A=K.getBuffer(K.create(C.buffer,es,!1,!0)):A=K.getBuffer(C.buffer),b.command(!!A,'missing buffer for attribute "'+M+'"',p.commandStr);var V=C.offset|0;b.command(V>=0,'invalid offset for attribute "'+M+'"',p.commandStr);var I=C.stride|0;b.command(I>=0&&I<256,'invalid stride for attribute "'+M+'", must be integer betweeen [0, 255]',p.commandStr);var Z=C.size|0;b.command(!("size"in C)||Z>0&&Z<=4,'invalid size for attribute "'+M+'", must be 1,2,3,4',p.commandStr);var te=!!C.normalized,ge=0;"type"in C&&(b.commandParameter(C.type,fn,"invalid type for attribute "+M,p.commandStr),ge=fn[C.type]);var Ve=C.divisor|0;b.optional(function(){"divisor"in C&&(b.command(Ve===0||ue,'cannot specify divisor for attribute "'+M+'", instancing not supported',p.commandStr),b.command(Ve>=0,'invalid divisor for attribute "'+M+'"',p.commandStr));var Fe=p.commandStr,Se=["buffer","offset","divisor","normalized","type","size","stride"];Object.keys(C).forEach(function(re){b.command(Se.indexOf(re)>=0,'unknown parameter "'+re+'" for attribute pointer "'+M+'" (valid parameters are '+Se+")",Fe)})}),w.buffer=A,w.state=Qn,w.size=Z,w.normalized=te,w.type=ge||A.dtype,w.offset=V,w.stride=I,w.divisor=Ve}}B[M]=wt(function(Fe,Se){var re=Fe.attribCache;if(G in re)return re[G];var W={isStream:!1};return Object.keys(w).forEach(function(Re){W[Re]=w[Re]}),w.buffer&&(W.buffer=Fe.link(w.buffer),W.type=W.type||W.buffer+".dtype"),re[G]=W,W})}),Object.keys(k).forEach(function(M){var C=k[M];function G(w,A){var x=w.invoke(A,C),V=w.shared,I=w.constants,Z=V.isBufferArgs,te=V.buffer;b.optional(function(){w.assert(A,x+"&&(typeof "+x+'==="object"||typeof '+x+'==="function")&&('+Z+"("+x+")||"+te+".getBuffer("+x+")||"+te+".getBuffer("+x+".buffer)||"+Z+"("+x+'.buffer)||("constant" in '+x+"&&(typeof "+x+'.constant==="number"||'+V.isArrayLike+"("+x+".constant))))",'invalid dynamic attribute "'+M+'"')});var ge={isStream:A.def(!1)},Ve=new D;Ve.state=Qn,Object.keys(Ve).forEach(function(W){ge[W]=A.def(""+Ve[W])});var Fe=ge.buffer,Se=ge.type;A("if(",Z,"(",x,")){",ge.isStream,"=true;",Fe,"=",te,".createStream(",es,",",x,");",Se,"=",Fe,".dtype;","}else{",Fe,"=",te,".getBuffer(",x,");","if(",Fe,"){",Se,"=",Fe,".dtype;",'}else if("constant" in ',x,"){",ge.state,"=",Fi,";","if(typeof "+x+'.constant === "number"){',ge[Zn[0]],"=",x,".constant;",Zn.slice(1).map(function(W){return ge[W]}).join("="),"=0;","}else{",Zn.map(function(W,Re){return ge[W]+"="+x+".constant.length>"+Re+"?"+x+".constant["+Re+"]:0;"}).join(""),"}}else{","if(",Z,"(",x,".buffer)){",Fe,"=",te,".createStream(",es,",",x,".buffer);","}else{",Fe,"=",te,".getBuffer(",x,".buffer);","}",Se,'="type" in ',x,"?",I.glTypes,"[",x,".type]:",Fe,".dtype;",ge.normalized,"=!!",x,".normalized;");function re(W){A(ge[W],"=",x,".",W,"|0;")}return re("size"),re("offset"),re("stride"),re("divisor"),A("}}"),A.exit("if(",ge.isStream,"){",te,".destroyStream(",Fe,");","}"),ge}B[M]=Ht(C,G)}),B}function lt(_){var p=_.static,P=_.dynamic,k={};return Object.keys(p).forEach(function(B){var M=p[B];k[B]=wt(function(C,G){return typeof M=="number"||typeof M=="boolean"?""+M:C.link(M)})}),Object.keys(P).forEach(function(B){var M=P[B];k[B]=Ht(M,function(C,G){return C.invoke(G,M)})}),k}function $t(_,p,P,k,B){var M=_.static,C=_.dynamic;b.optional(function(){var re=[pn,ks,Ds,vn,gn,qo,yn,Xo,Gs,Bs].concat(ke);function W(Re){Object.keys(Re).forEach(function(Oe){b.command(re.indexOf(Oe)>=0,'unknown parameter "'+Oe+'"',B.commandStr)})}W(M),W(C)});var G=He(_,p),w=Ae(_),A=Be(_,w,B),x=ht(_,B),V=mt(_,B),I=Je(_,B,G);function Z(re){var W=A[re];W&&(V[re]=W)}Z(kr),Z(Me(Uo));var te=Object.keys(V).length>0,ge={framebuffer:w,draw:x,shader:I,state:V,dirty:te,scopeVAO:null,drawVAO:null,useVAO:!1,attributes:{}};if(ge.profile=xe(_),ge.uniforms=tt(P,B),ge.drawVAO=ge.scopeVAO=x.vao,!ge.drawVAO&&I.program&&!G&&T.angle_instanced_arrays&&x.static.elements){var Ve=!0,Fe=I.program.attributes.map(function(re){var W=p.static[re];return Ve=Ve&&!!W,W});if(Ve&&Fe.length>0){var Se=he.getVAO(he.createVAO({attributes:Fe,elements:x.static.elements}));ge.drawVAO=new Pt(null,null,null,function(re,W){return re.link(Se)}),ge.useVAO=!0}}return G?ge.useVAO=!0:ge.attributes=Et(p,B),ge.context=lt(k),ge}function At(_,p,P){var k=_.shared,B=k.context,M=_.scope();Object.keys(P).forEach(function(C){p.save(B,"."+C);var G=P[C],w=G.append(_,p);Array.isArray(w)?M(B,".",C,"=[",w.join(),"];"):M(B,".",C,"=",w,";")}),p(M)}function Tt(_,p,P,k){var B=_.shared,M=B.gl,C=B.framebuffer,G;Te&&(G=p.def(B.extensions,".webgl_draw_buffers"));var w=_.constants,A=w.drawBuffer,x=w.backBuffer,V;P?V=P.append(_,p):V=p.def(C,".next"),k||p("if(",V,"!==",C,".cur){"),p("if(",V,"){",M,".bindFramebuffer(",Qu,",",V,".framebuffer);"),Te&&p(G,".drawBuffersWEBGL(",A,"[",V,".colorAttachments.length]);"),p("}else{",M,".bindFramebuffer(",Qu,",null);"),Te&&p(G,".drawBuffersWEBGL(",x,");"),p("}",C,".cur=",V,";"),k||p("}")}function Lt(_,p,P){var k=_.shared,B=k.gl,M=_.current,C=_.next,G=k.current,w=k.next,A=_.cond(G,".dirty");ke.forEach(function(x){var V=Me(x);if(!(V in P.state)){var I,Z;if(V in C){I=C[V],Z=M[V];var te=rr(Ee[V].length,function(Ve){return A.def(I,"[",Ve,"]")});A(_.cond(te.map(function(Ve,Fe){return Ve+"!=="+Z+"["+Fe+"]"}).join("||")).then(B,".",Q[V],"(",te,");",te.map(function(Ve,Fe){return Z+"["+Fe+"]="+Ve}).join(";"),";"))}else{I=A.def(w,".",V);var ge=_.cond(I,"!==",G,".",V);A(ge),V in ee?ge(_.cond(I).then(B,".enable(",ee[V],");").else(B,".disable(",ee[V],");"),G,".",V,"=",I,";"):ge(B,".",Q[V],"(",I,");",G,".",V,"=",I,";")}}}),Object.keys(P.state).length===0&&A(G,".dirty=false;"),p(A)}function Nt(_,p,P,k){var B=_.shared,M=_.current,C=B.current,G=B.gl;e1(Object.keys(P)).forEach(function(w){var A=P[w];if(!(k&&!k(A))){var x=A.append(_,p);if(ee[w]){var V=ee[w];Yr(A)?x?p(G,".enable(",V,");"):p(G,".disable(",V,");"):p(_.cond(x).then(G,".enable(",V,");").else(G,".disable(",V,");")),p(C,".",w,"=",x,";")}else if(dt(x)){var I=M[w];p(G,".",Q[w],"(",x,");",x.map(function(Z,te){return I+"["+te+"]="+Z}).join(";"),";")}else p(G,".",Q[w],"(",x,");",C,".",w,"=",x,";")}})}function vt(_,p){ue&&(_.instancing=p.def(_.shared.extensions,".angle_instanced_arrays"))}function Ye(_,p,P,k,B){var M=_.shared,C=_.stats,G=M.current,w=M.timer,A=P.profile;function x(){return typeof performance>"u"?"Date.now()":"performance.now()"}var V,I;function Z(re){V=p.def(),re(V,"=",x(),";"),typeof B=="string"?re(C,".count+=",B,";"):re(C,".count++;"),ce&&(k?(I=p.def(),re(I,"=",w,".getNumPendingQueries();")):re(w,".beginQuery(",C,");"))}function te(re){re(C,".cpuTime+=",x(),"-",V,";"),ce&&(k?re(w,".pushScopeStats(",I,",",w,".getNumPendingQueries(),",C,");"):re(w,".endQuery();"))}function ge(re){var W=p.def(G,".profile");p(G,".profile=",re,";"),p.exit(G,".profile=",W,";")}var Ve;if(A){if(Yr(A)){A.enable?(Z(p),te(p.exit),ge("true")):ge("false");return}Ve=A.append(_,p),ge(Ve)}else Ve=p.def(G,".profile");var Fe=_.block();Z(Fe),p("if(",Ve,"){",Fe,"}");var Se=_.block();te(Se),p.exit("if(",Ve,"){",Se,"}")}function Gt(_,p,P,k,B){var M=_.shared;function C(w){switch(w){case jo:case Wo:case Ko:return 2;case Ho:case Zo:case Jo:return 3;case Yo:case Qo:case ea:return 4;default:return 1}}function G(w,A,x){var V=M.gl,I=p.def(w,".location"),Z=p.def(M.attributes,"[",I,"]"),te=x.state,ge=x.buffer,Ve=[x.x,x.y,x.z,x.w],Fe=["buffer","normalized","offset","stride"];function Se(){p("if(!",Z,".buffer){",V,".enableVertexAttribArray(",I,");}");var W=x.type,Re;if(x.size?Re=p.def(x.size,"||",A):Re=A,p("if(",Z,".type!==",W,"||",Z,".size!==",Re,"||",Fe.map(function(Ie){return Z+"."+Ie+"!=="+x[Ie]}).join("||"),"){",V,".bindBuffer(",es,",",ge,".buffer);",V,".vertexAttribPointer(",[I,Re,W,x.normalized,x.stride,x.offset],");",Z,".type=",W,";",Z,".size=",Re,";",Fe.map(function(Ie){return Z+"."+Ie+"="+x[Ie]+";"}).join(""),"}"),ue){var Oe=x.divisor;p("if(",Z,".divisor!==",Oe,"){",_.instancing,".vertexAttribDivisorANGLE(",[I,Oe],");",Z,".divisor=",Oe,";}")}}function re(){p("if(",Z,".buffer){",V,".disableVertexAttribArray(",I,");",Z,".buffer=null;","}if(",Zn.map(function(W,Re){return Z+"."+W+"!=="+Ve[Re]}).join("||"),"){",V,".vertexAttrib4f(",I,",",Ve,");",Zn.map(function(W,Re){return Z+"."+W+"="+Ve[Re]+";"}).join(""),"}")}te===Qn?Se():te===Fi?re():(p("if(",te,"===",Qn,"){"),Se(),p("}else{"),re(),p("}"))}k.forEach(function(w){var A=w.name,x=P.attributes[A],V;if(x){if(!B(x))return;V=x.append(_,p)}else{if(!B(t1))return;var I=_.scopeAttrib(A);b.optional(function(){_.assert(p,I+".state","missing attribute "+A)}),V={},Object.keys(new D).forEach(function(Z){V[Z]=p.def(I,".",Z)})}G(_.link(w),C(w.info.type),V)})}function at(_,p,P,k,B,M){for(var C=_.shared,G=C.gl,w={},A,x=0;x<k.length;++x){var V=k[x],I=V.name,Z=V.info.type,te=V.info.size,ge=P.uniforms[I];if(te>1){if(!ge)continue;var Ve=I.replace("[0]","");if(w[Ve])continue;w[Ve]=1}var Fe=_.link(V),Se=Fe+".location",re;if(ge){if(!B(ge))continue;if(Yr(ge)){var W=ge.value;if(b.command(W!==null&&typeof W<"u",'missing uniform "'+I+'"',_.commandStr),Z===Us||Z===qs){b.command(typeof W=="function"&&(Z===Us&&(W._reglType==="texture2d"||W._reglType==="framebuffer")||Z===qs&&(W._reglType==="textureCube"||W._reglType==="framebufferCube")),"invalid texture for uniform "+I,_.commandStr);var Re=_.link(W._texture||W.color[0]._texture);p(G,".uniform1i(",Se,",",Re+".bind());"),p.exit(Re,".unbind();")}else if(Z===Is||Z===Vs||Z===zs){b.optional(function(){b.command(dt(W),"invalid matrix for uniform "+I,_.commandStr),b.command(Z===Is&&W.length===4||Z===Vs&&W.length===9||Z===zs&&W.length===16,"invalid length for matrix uniform "+I,_.commandStr)});var Oe=_.global.def("new Float32Array(["+Array.prototype.slice.call(W)+"])"),Ie=2;Z===Vs?Ie=3:Z===zs&&(Ie=4),p(G,".uniformMatrix",Ie,"fv(",Se,",false,",Oe,");")}else{switch(Z){case Qi:te===1?b.commandType(W,"number","uniform "+I,_.commandStr):b.command(dt(W)&&W.length===te,"uniform "+I,_.commandStr),A="1f";break;case jo:b.command(dt(W)&&W.length&&W.length%2===0&&W.length<=te*2,"uniform "+I,_.commandStr),A="2f";break;case Ho:b.command(dt(W)&&W.length&&W.length%3===0&&W.length<=te*3,"uniform "+I,_.commandStr),A="3f";break;case Yo:b.command(dt(W)&&W.length&&W.length%4===0&&W.length<=te*4,"uniform "+I,_.commandStr),A="4f";break;case Ji:te===1?b.commandType(W,"boolean","uniform "+I,_.commandStr):b.command(dt(W)&&W.length===te,"uniform "+I,_.commandStr),A="1i";break;case Ki:te===1?b.commandType(W,"number","uniform "+I,_.commandStr):b.command(dt(W)&&W.length===te,"uniform "+I,_.commandStr),A="1i";break;case Ko:b.command(dt(W)&&W.length&&W.length%2===0&&W.length<=te*2,"uniform "+I,_.commandStr),A="2i";break;case Wo:b.command(dt(W)&&W.length&&W.length%2===0&&W.length<=te*2,"uniform "+I,_.commandStr),A="2i";break;case Jo:b.command(dt(W)&&W.length&&W.length%3===0&&W.length<=te*3,"uniform "+I,_.commandStr),A="3i";break;case Zo:b.command(dt(W)&&W.length&&W.length%3===0&&W.length<=te*3,"uniform "+I,_.commandStr),A="3i";break;case ea:b.command(dt(W)&&W.length&&W.length%4===0&&W.length<=te*4,"uniform "+I,_.commandStr),A="4i";break;case Qo:b.command(dt(W)&&W.length&&W.length%4===0&&W.length<=te*4,"uniform "+I,_.commandStr),A="4i";break}te>1?(A+="v",W=_.global.def("["+Array.prototype.slice.call(W)+"]")):W=dt(W)?Array.prototype.slice.call(W):W,p(G,".uniform",A,"(",Se,",",W,");")}continue}else re=ge.append(_,p)}else{if(!B(t1))continue;re=p.def(C.uniforms,"[",v.id(I),"]")}Z===Us?(b(!Array.isArray(re),"must specify a scalar prop for textures"),p("if(",re,"&&",re,'._reglType==="framebuffer"){',re,"=",re,".color[0];","}")):Z===qs&&(b(!Array.isArray(re),"must specify a scalar prop for cube maps"),p("if(",re,"&&",re,'._reglType==="framebufferCube"){',re,"=",re,".color[0];","}")),b.optional(function(){function sr(Yt,ra){_.assert(p,Yt,'bad data or missing for uniform "'+I+'".  '+ra)}function xn(Yt,ra){ra===1&&b(!Array.isArray(re),"must not specify an array type for uniform"),sr("Array.isArray("+re+") && typeof "+re+'[0]===" '+Yt+'" || typeof '+re+'==="'+Yt+'"',"invalid type, expected "+Yt)}function ur(Yt,ra,na){Array.isArray(re)?b(re.length&&re.length%Yt===0&&re.length<=Yt*na,"must have length of "+(na===1?"":"n * ")+Yt):sr(C.isArrayLike+"("+re+")&&"+re+".length && "+re+".length % "+Yt+" === 0 && "+re+".length<="+Yt*na,"invalid vector, should have length of "+(na===1?"":"n * ")+Yt,_.commandStr)}function c1(Yt){b(!Array.isArray(re),"must not specify a value type"),sr("typeof "+re+'==="function"&&'+re+'._reglType==="texture'+(Yt===ju?"2d":"Cube")+'"',"invalid texture type",_.commandStr)}switch(Z){case Ki:xn("number",te);break;case Wo:ur(2,"number",te);break;case Zo:ur(3,"number",te);break;case Qo:ur(4,"number",te);break;case Qi:xn("number",te);break;case jo:ur(2,"number",te);break;case Ho:ur(3,"number",te);break;case Yo:ur(4,"number",te);break;case Ji:xn("boolean",te);break;case Ko:ur(2,"boolean",te);break;case Jo:ur(3,"boolean",te);break;case ea:ur(4,"boolean",te);break;case Is:ur(4,"number",te);break;case Vs:ur(9,"number",te);break;case zs:ur(16,"number",te);break;case Us:c1(ju);break;case qs:c1(Cg);break}});var it=1;switch(Z){case Us:case qs:var kt=p.def(re,"._texture");p(G,".uniform1i(",Se,",",kt,".bind());"),p.exit(kt,".unbind();");continue;case Ki:case Ji:A="1i";break;case Wo:case Ko:A="2i",it=2;break;case Zo:case Jo:A="3i",it=3;break;case Qo:case ea:A="4i",it=4;break;case Qi:A="1f";break;case jo:A="2f",it=2;break;case Ho:A="3f",it=3;break;case Yo:A="4f",it=4;break;case Is:A="Matrix2fv";break;case Vs:A="Matrix3fv";break;case zs:A="Matrix4fv";break}if(A.indexOf("Matrix")===-1&&te>1&&(A+="v",it=1),A.charAt(0)==="M"){p(G,".uniform",A,"(",Se,",");var wn=Math.pow(Z-Is+2,2),Dr=_.global.def("new Float32Array(",wn,")");Array.isArray(re)?p("false,(",rr(wn,function(sr){return Dr+"["+sr+"]="+re[sr]}),",",Dr,")"):p("false,(Array.isArray(",re,")||",re," instanceof Float32Array)?",re,":(",rr(wn,function(sr){return Dr+"["+sr+"]="+re+"["+sr+"]"}),",",Dr,")"),p(");")}else if(it>1){for(var Sr=[],Wr=[],$n=0;$n<it;++$n)Array.isArray(re)?Wr.push(re[$n]):Wr.push(p.def(re+"["+$n+"]")),M&&Sr.push(p.def());M&&p("if(!",_.batchId,"||",Sr.map(function(sr,xn){return sr+"!=="+Wr[xn]}).join("||"),"){",Sr.map(function(sr,xn){return sr+"="+Wr[xn]+";"}).join("")),p(G,".uniform",A,"(",Se,",",Wr.join(","),");"),M&&p("}")}else{if(b(!Array.isArray(re),"uniform value must not be an array"),M){var i1=p.def();p("if(!",_.batchId,"||",i1,"!==",re,"){",i1,"=",re,";")}p(G,".uniform",A,"(",Se,",",re,");"),M&&p("}")}}}function De(_,p,P,k){var B=_.shared,M=B.gl,C=B.draw,G=k.draw;function w(){var Re=G.elements,Oe,Ie=p;return Re?((Re.contextDep&&k.contextDynamic||Re.propDep)&&(Ie=P),Oe=Re.append(_,Ie),G.elementsActive&&Ie("if("+Oe+")"+M+".bindBuffer("+Zi+","+Oe+".buffer.buffer);")):(Oe=Ie.def(),Ie(Oe,"=",C,".",vn,";","if(",Oe,"){",M,".bindBuffer(",Zi,",",Oe,".buffer.buffer);}","else if(",B.vao,".currentVAO){",Oe,"=",_.shared.elements+".getElements("+B.vao,".currentVAO.elements);",se?"":"if("+Oe+")"+M+".bindBuffer("+Zi+","+Oe+".buffer.buffer);","}")),Oe}function A(){var Re=G.count,Oe,Ie=p;return Re?((Re.contextDep&&k.contextDynamic||Re.propDep)&&(Ie=P),Oe=Re.append(_,Ie),b.optional(function(){Re.MISSING&&_.assert(p,"false","missing vertex count"),Re.DYNAMIC&&_.assert(Ie,Oe+">=0","missing vertex count")})):(Oe=Ie.def(C,".",yn),b.optional(function(){_.assert(Ie,Oe+">=0","missing vertex count")})),Oe}var x=w();function V(Re){var Oe=G[Re];return Oe?Oe.contextDep&&k.contextDynamic||Oe.propDep?Oe.append(_,P):Oe.append(_,p):p.def(C,".",Re)}var I=V(gn),Z=V(qo),te=A();if(typeof te=="number"){if(te===0)return}else P("if(",te,"){"),P.exit("}");var ge,Ve;ue&&(ge=V(Xo),Ve=_.instancing);var Fe=x+".type",Se=G.elements&&Yr(G.elements)&&!G.vaoActive;function re(){function Re(){P(Ve,".drawElementsInstancedANGLE(",[I,te,Fe,Z+"<<(("+Fe+"-"+Au+")>>1)",ge],");")}function Oe(){P(Ve,".drawArraysInstancedANGLE(",[I,Z,te,ge],");")}x&&x!=="null"?Se?Re():(P("if(",x,"){"),Re(),P("}else{"),Oe(),P("}")):Oe()}function W(){function Re(){P(M+".drawElements("+[I,te,Fe,Z+"<<(("+Fe+"-"+Au+")>>1)"]+");")}function Oe(){P(M+".drawArrays("+[I,Z,te]+");")}x&&x!=="null"?Se?Re():(P("if(",x,"){"),Re(),P("}else{"),Oe(),P("}")):Oe()}ue&&(typeof ge!="number"||ge>=0)?typeof ge=="string"?(P("if(",ge,">0){"),re(),P("}else if(",ge,"<0){"),W(),P("}")):re():W()}function et(_,p,P,k,B){var M=qe(),C=M.proc("body",B);return b.optional(function(){M.commandStr=p.commandStr,M.command=M.link(p.commandStr)}),ue&&(M.instancing=C.def(M.shared.extensions,".angle_instanced_arrays")),_(M,C,P,k),M.compile().body}function nt(_,p,P,k){vt(_,p),P.useVAO?P.drawVAO?p(_.shared.vao,".setVAO(",P.drawVAO.append(_,p),");"):p(_.shared.vao,".setVAO(",_.shared.vao,".targetVAO);"):(p(_.shared.vao,".setVAO(null);"),Gt(_,p,P,k.attributes,function(){return!0})),at(_,p,P,k.uniforms,function(){return!0},!1),De(_,p,p,P)}function gt(_,p){var P=_.proc("draw",1);vt(_,P),At(_,P,p.context),Tt(_,P,p.framebuffer),Lt(_,P,p),Nt(_,P,p.state),Ye(_,P,p,!1,!0);var k=p.shader.progVar.append(_,P);if(P(_.shared.gl,".useProgram(",k,".program);"),p.shader.program)nt(_,P,p,p.shader.program);else{P(_.shared.vao,".setVAO(null);");var B=_.global.def("{}"),M=P.def(k,".id"),C=P.def(B,"[",M,"]");P(_.cond(C).then(C,".call(this,a0);").else(C,"=",B,"[",M,"]=",_.link(function(G){return et(nt,_,p,G,1)}),"(",k,");",C,".call(this,a0);"))}Object.keys(p.state).length>0&&P(_.shared.current,".dirty=true;"),_.shared.vao&&P(_.shared.vao,".setVAO(null);")}function Tr(_,p,P,k){_.batchId="a1",vt(_,p);function B(){return!0}Gt(_,p,P,k.attributes,B),at(_,p,P,k.uniforms,B,!1),De(_,p,p,P)}function _n(_,p,P,k){vt(_,p);var B=P.contextDep,M=p.def(),C="a0",G="a1",w=p.def();_.shared.props=w,_.batchId=M;var A=_.scope(),x=_.scope();p(A.entry,"for(",M,"=0;",M,"<",G,";++",M,"){",w,"=",C,"[",M,"];",x,"}",A.exit);function V(Fe){return Fe.contextDep&&B||Fe.propDep}function I(Fe){return!V(Fe)}if(P.needsContext&&At(_,x,P.context),P.needsFramebuffer&&Tt(_,x,P.framebuffer),Nt(_,x,P.state,V),P.profile&&V(P.profile)&&Ye(_,x,P,!1,!0),k)P.useVAO?P.drawVAO?V(P.drawVAO)?x(_.shared.vao,".setVAO(",P.drawVAO.append(_,x),");"):A(_.shared.vao,".setVAO(",P.drawVAO.append(_,A),");"):A(_.shared.vao,".setVAO(",_.shared.vao,".targetVAO);"):(A(_.shared.vao,".setVAO(null);"),Gt(_,A,P,k.attributes,I),Gt(_,x,P,k.attributes,V)),at(_,A,P,k.uniforms,I,!1),at(_,x,P,k.uniforms,V,!0),De(_,A,x,P);else{var Z=_.global.def("{}"),te=P.shader.progVar.append(_,x),ge=x.def(te,".id"),Ve=x.def(Z,"[",ge,"]");x(_.shared.gl,".useProgram(",te,".program);","if(!",Ve,"){",Ve,"=",Z,"[",ge,"]=",_.link(function(Fe){return et(Tr,_,P,Fe,2)}),"(",te,");}",Ve,".call(this,a0[",M,"],",M,");")}}function E(_,p){var P=_.proc("batch",2);_.batchId="0",vt(_,P);var k=!1,B=!0;Object.keys(p.context).forEach(function(Z){k=k||p.context[Z].propDep}),k||(At(_,P,p.context),B=!1);var M=p.framebuffer,C=!1;M?(M.propDep?k=C=!0:M.contextDep&&k&&(C=!0),C||Tt(_,P,M)):Tt(_,P,null),p.state.viewport&&p.state.viewport.propDep&&(k=!0);function G(Z){return Z.contextDep&&k||Z.propDep}Lt(_,P,p),Nt(_,P,p.state,function(Z){return!G(Z)}),(!p.profile||!G(p.profile))&&Ye(_,P,p,!1,"a1"),p.contextDep=k,p.needsContext=B,p.needsFramebuffer=C;var w=p.shader.progVar;if(w.contextDep&&k||w.propDep)_n(_,P,p,null);else{var A=w.append(_,P);if(P(_.shared.gl,".useProgram(",A,".program);"),p.shader.program)_n(_,P,p,p.shader.program);else{P(_.shared.vao,".setVAO(null);");var x=_.global.def("{}"),V=P.def(A,".id"),I=P.def(x,"[",V,"]");P(_.cond(I).then(I,".call(this,a0,a1);").else(I,"=",x,"[",V,"]=",_.link(function(Z){return et(_n,_,p,Z,2)}),"(",A,");",I,".call(this,a0,a1);"))}}Object.keys(p.state).length>0&&P(_.shared.current,".dirty=true;"),_.shared.vao&&P(_.shared.vao,".setVAO(null);")}function j(_,p){var P=_.proc("scope",3);_.batchId="a2";var k=_.shared,B=k.current;At(_,P,p.context),p.framebuffer&&p.framebuffer.append(_,P),e1(Object.keys(p.state)).forEach(function(C){var G=p.state[C],w=G.append(_,P);dt(w)?w.forEach(function(A,x){P.set(_.next[C],"["+x+"]",A)}):P.set(k.next,"."+C,w)}),Ye(_,P,p,!0,!0),[vn,qo,yn,Xo,gn].forEach(function(C){var G=p.draw[C];G&&P.set(k.draw,"."+C,""+G.append(_,P))}),Object.keys(p.uniforms).forEach(function(C){var G=p.uniforms[C].append(_,P);Array.isArray(G)&&(G="["+G.join()+"]"),P.set(k.uniforms,"["+v.id(C)+"]",G)}),Object.keys(p.attributes).forEach(function(C){var G=p.attributes[C].append(_,P),w=_.scopeAttrib(C);Object.keys(new D).forEach(function(A){P.set(w,"."+A,G[A])})}),p.scopeVAO&&P.set(k.vao,".targetVAO",p.scopeVAO.append(_,P));function M(C){var G=p.shader[C];G&&P.set(k.shader,"."+C,G.append(_,P))}M(ks),M(Ds),Object.keys(p.state).length>0&&(P(B,".dirty=true;"),P.exit(B,".dirty=true;")),P("a1(",_.shared.context,",a0,",_.batchId,");")}function U(_){if(!(typeof _!="object"||dt(_))){for(var p=Object.keys(_),P=0;P<p.length;++P)if(tr.isDynamic(_[p[P]]))return!0;return!1}}function Ce(_,p,P){var k=p.static[P];if(!k||!U(k))return;var B=_.global,M=Object.keys(k),C=!1,G=!1,w=!1,A=_.global.def("{}");M.forEach(function(V){var I=k[V];if(tr.isDynamic(I)){typeof I=="function"&&(I=k[V]=tr.unbox(I));var Z=Ht(I,null);C=C||Z.thisDep,w=w||Z.propDep,G=G||Z.contextDep}else{switch(B(A,".",V,"="),typeof I){case"number":B(I);break;case"string":B('"',I,'"');break;case"object":Array.isArray(I)&&B("[",I.join(),"]");break;default:B(_.link(I));break}B(";")}});function x(V,I){M.forEach(function(Z){var te=k[Z];if(tr.isDynamic(te)){var ge=V.invoke(I,te);I(A,".",Z,"=",ge,";")}})}p.dynamic[P]=new tr.DynamicVariable(zo,{thisDep:C,contextDep:G,propDep:w,ref:A,append:x}),delete p.static[P]}function Ze(_,p,P,k,B){var M=qe();M.stats=M.link(B),Object.keys(p.static).forEach(function(G){Ce(M,p,G)}),Tg.forEach(function(G){Ce(M,_,G)});var C=$t(_,p,P,k,M);return gt(M,C),j(M,C),E(M,C),n(M.compile(),{destroy:function(){C.shader.program.destroy()}})}return{next:$e,current:Ee,procs:function(){var _=qe(),p=_.proc("poll"),P=_.proc("refresh"),k=_.block();p(k),P(k);var B=_.shared,M=B.gl,C=B.next,G=B.current;k(G,".dirty=false;"),Tt(_,p),Tt(_,P,null,!0);var w;ue&&(w=_.link(ue)),T.oes_vertex_array_object&&P(_.link(T.oes_vertex_array_object),".bindVertexArrayOES(null);");for(var A=0;A<X.maxAttributes;++A){var x=P.def(B.attributes,"[",A,"]"),V=_.cond(x,".buffer");V.then(M,".enableVertexAttribArray(",A,");",M,".bindBuffer(",es,",",x,".buffer.buffer);",M,".vertexAttribPointer(",A,",",x,".size,",x,".type,",x,".normalized,",x,".stride,",x,".offset);").else(M,".disableVertexAttribArray(",A,");",M,".vertexAttrib4f(",A,",",x,".x,",x,".y,",x,".z,",x,".w);",x,".buffer=null;"),P(V),ue&&P(w,".vertexAttribDivisorANGLE(",A,",",x,".divisor);")}return P(_.shared.vao,".currentVAO=null;",_.shared.vao,".setVAO(",_.shared.vao,".targetVAO);"),Object.keys(ee).forEach(function(I){var Z=ee[I],te=k.def(C,".",I),ge=_.block();ge("if(",te,"){",M,".enable(",Z,")}else{",M,".disable(",Z,")}",G,".",I,"=",te,";"),P(ge),p("if(",te,"!==",G,".",I,"){",ge,"}")}),Object.keys(Q).forEach(function(I){var Z=Q[I],te=Ee[I],ge,Ve,Fe=_.block();if(Fe(M,".",Z,"("),dt(te)){var Se=te.length;ge=_.global.def(C,".",I),Ve=_.global.def(G,".",I),Fe(rr(Se,function(re){return ge+"["+re+"]"}),");",rr(Se,function(re){return Ve+"["+re+"]="+ge+"["+re+"];"}).join("")),p("if(",rr(Se,function(re){return ge+"["+re+"]!=="+Ve+"["+re+"]"}).join("||"),"){",Fe,"}")}else ge=k.def(C,".",I),Ve=k.def(G,".",I),Fe(ge,");",G,".",I,"=",ge,";"),p("if(",ge,"!==",Ve,"){",Fe,"}");P(Fe)}),_.compile()}(),compile:Ze}}function Xg(){return{vaoCount:0,bufferCount:0,elementsCount:0,framebufferCount:0,shaderCount:0,textureCount:0,cubeCount:0,renderbufferCount:0,maxTextureUnits:0}}var jg=34918,Hg=34919,r1=35007,Yg=function(f,v){if(!v.ext_disjoint_timer_query)return null;var T=[];function X(){return T.pop()||v.ext_disjoint_timer_query.createQueryEXT()}function K(ue){T.push(ue)}var q=[];function Y(ue){var Te=X();v.ext_disjoint_timer_query.beginQueryEXT(r1,Te),q.push(Te),ce(q.length-1,q.length,ue)}function ie(){v.ext_disjoint_timer_query.endQueryEXT(r1)}function ae(){this.startQueryIndex=-1,this.endQueryIndex=-1,this.sum=0,this.stats=null}var he=[];function pe(){return he.pop()||new ae}function me(ue){he.push(ue)}var ye=[];function ce(ue,Te,se){var Ee=pe();Ee.startQueryIndex=ue,Ee.endQueryIndex=Te,Ee.sum=0,Ee.stats=se,ye.push(Ee)}var de=[],D=[];function H(){var ue,Te,se=q.length;if(se!==0){D.length=Math.max(D.length,se+1),de.length=Math.max(de.length,se+1),de[0]=0,D[0]=0;var Ee=0;for(ue=0,Te=0;Te<q.length;++Te){var $e=q[Te];v.ext_disjoint_timer_query.getQueryObjectEXT($e,Hg)?(Ee+=v.ext_disjoint_timer_query.getQueryObjectEXT($e,jg),K($e)):q[ue++]=$e,de[Te+1]=Ee,D[Te+1]=ue}for(q.length=ue,ue=0,Te=0;Te<ye.length;++Te){var ke=ye[Te],ee=ke.startQueryIndex,Q=ke.endQueryIndex;ke.sum+=de[Q]-de[ee];var Me=D[ee],be=D[Q];be===Me?(ke.stats.gpuTime+=ke.sum/1e6,me(ke)):(ke.startQueryIndex=Me,ke.endQueryIndex=be,ye[ue++]=ke)}ye.length=ue}}return{beginQuery:Y,endQuery:ie,pushScopeStats:ce,update:H,getNumPendingQueries:function(){return q.length},clear:function(){T.push.apply(T,q);for(var ue=0;ue<T.length;ue++)v.ext_disjoint_timer_query.deleteQueryEXT(T[ue]);q.length=0,T.length=0},restore:function(){q.length=0,T.length=0}}},Wg=16384,Zg=256,Qg=1024,Kg=34962,n1="webglcontextlost",s1="webglcontextrestored",o1=1,Jg=2,e5=3;function a1(f,v){for(var T=0;T<f.length;++T)if(f[T]===v)return T;return-1}function t5(f){var v=Jp(f);if(!v)return null;var T=v.gl,X=T.getContextAttributes(),K=T.isContextLost(),q=ev(T,v);if(!q)return null;var Y=Yp(),ie=Xg(),ae=q.extensions,he=Yg(T,ae),pe=mf(),me=T.drawingBufferWidth,ye=T.drawingBufferHeight,ce={tick:0,time:0,viewportWidth:me,viewportHeight:ye,framebufferWidth:me,framebufferHeight:ye,drawingBufferWidth:me,drawingBufferHeight:ye,pixelRatio:v.pixelRatio},de={},D={elements:null,primitive:4,count:-1,offset:0,instances:-1},H=Vv(T,ae),ue=n2(T,ie,v,Ee),Te=p2(T,ae,ue,ie),se=pg(T,ae,H,ie,ue,Te,D);function Ee(De){return se.destroyBuffer(De)}var $e=bg(T,Y,ie,v),ke=j2(T,ae,H,function(){Me.procs.poll()},ce,ie,v),ee=H2(T,ae,H,ie,v),Q=hg(T,ae,H,ke,ee,ie),Me=qg(T,Y,ae,H,ue,Te,ke,Q,de,se,$e,D,ce,he,v),be=$g(T,Q,Me.procs.poll,ce,X,ae,H),fe=Me.next,_e=T.canvas,we=[],je=[],qe=[],xe=[v.onDestroy],Ae=null;function Be(){if(we.length===0){he&&he.update(),Ae=null;return}Ae=ai.next(Be),Nt();for(var De=we.length-1;De>=0;--De){var et=we[De];et&&et(ce,null,0)}T.flush(),he&&he.update()}function He(){!Ae&&we.length>0&&(Ae=ai.next(Be))}function Je(){Ae&&(ai.cancel(Be),Ae=null)}function ht(De){De.preventDefault(),K=!0,Je(),je.forEach(function(et){et()})}function mt(De){T.getError(),K=!1,q.restore(),$e.restore(),ue.restore(),ke.restore(),ee.restore(),Q.restore(),se.restore(),he&&he.restore(),Me.procs.refresh(),He(),qe.forEach(function(et){et()})}_e&&(_e.addEventListener(n1,ht,!1),_e.addEventListener(s1,mt,!1));function tt(){we.length=0,Je(),_e&&(_e.removeEventListener(n1,ht),_e.removeEventListener(s1,mt)),$e.clear(),Q.clear(),ee.clear(),se.clear(),ke.clear(),Te.clear(),ue.clear(),he&&he.clear(),xe.forEach(function(De){De()})}function Et(De){b(!!De,"invalid args to regl({...})"),b.type(De,"object","invalid args to regl({...})");function et(B){var M=n({},B);delete M.uniforms,delete M.attributes,delete M.context,delete M.vao,"stencil"in M&&M.stencil.op&&(M.stencil.opBack=M.stencil.opFront=M.stencil.op,delete M.stencil.op);function C(G){if(G in M){var w=M[G];delete M[G],Object.keys(w).forEach(function(A){M[G+"."+A]=w[A]})}}return C("blend"),C("depth"),C("cull"),C("stencil"),C("polygonOffset"),C("scissor"),C("sample"),"vao"in B&&(M.vao=B.vao),M}function nt(B,M){var C={},G={};return Object.keys(B).forEach(function(w){var A=B[w];if(tr.isDynamic(A)){G[w]=tr.unbox(A,w);return}else if(M&&Array.isArray(A)){for(var x=0;x<A.length;++x)if(tr.isDynamic(A[x])){G[w]=tr.unbox(A,w);return}}C[w]=A}),{dynamic:G,static:C}}var gt=nt(De.context||{},!0),Tr=nt(De.uniforms||{},!0),_n=nt(De.attributes||{},!1),E=nt(et(De),!1),j={gpuTime:0,cpuTime:0,count:0},U=Me.compile(E,_n,Tr,gt,j),Ce=U.draw,Ze=U.batch,_=U.scope,p=[];function P(B){for(;p.length<B;)p.push(null);return p}function k(B,M){var C;if(K&&b.raise("context lost"),typeof B=="function")return _.call(this,null,B,0);if(typeof M=="function")if(typeof B=="number")for(C=0;C<B;++C)_.call(this,null,M,C);else if(Array.isArray(B))for(C=0;C<B.length;++C)_.call(this,B[C],M,C);else return _.call(this,B,M,0);else if(typeof B=="number"){if(B>0)return Ze.call(this,P(B|0),B|0)}else if(Array.isArray(B)){if(B.length)return Ze.call(this,B,B.length)}else return Ce.call(this,B)}return n(k,{stats:j,destroy:function(){U.destroy()}})}var lt=Q.setFBO=Et({framebuffer:tr.define.call(null,o1,"framebuffer")});function $t(De,et){var nt=0;Me.procs.poll();var gt=et.color;gt&&(T.clearColor(+gt[0]||0,+gt[1]||0,+gt[2]||0,+gt[3]||0),nt|=Wg),"depth"in et&&(T.clearDepth(+et.depth),nt|=Zg),"stencil"in et&&(T.clearStencil(et.stencil|0),nt|=Qg),b(!!nt,"called regl.clear with no buffer specified"),T.clear(nt)}function At(De){if(b(typeof De=="object"&&De,"regl.clear() takes an object as input"),"framebuffer"in De)if(De.framebuffer&&De.framebuffer_reglType==="framebufferCube")for(var et=0;et<6;++et)lt(n({framebuffer:De.framebuffer.faces[et]},De),$t);else lt(De,$t);else $t(null,De)}function Tt(De){b.type(De,"function","regl.frame() callback must be a function"),we.push(De);function et(){var nt=a1(we,De);b(nt>=0,"cannot cancel a frame twice");function gt(){var Tr=a1(we,gt);we[Tr]=we[we.length-1],we.length-=1,we.length<=0&&Je()}we[nt]=gt}return He(),{cancel:et}}function Lt(){var De=fe.viewport,et=fe.scissor_box;De[0]=De[1]=et[0]=et[1]=0,ce.viewportWidth=ce.framebufferWidth=ce.drawingBufferWidth=De[2]=et[2]=T.drawingBufferWidth,ce.viewportHeight=ce.framebufferHeight=ce.drawingBufferHeight=De[3]=et[3]=T.drawingBufferHeight}function Nt(){ce.tick+=1,ce.time=Ye(),Lt(),Me.procs.poll()}function vt(){ke.refresh(),Lt(),Me.procs.refresh(),he&&he.update()}function Ye(){return(mf()-pe)/1e3}vt();function Gt(De,et){b.type(et,"function","listener callback must be a function");var nt;switch(De){case"frame":return Tt(et);case"lost":nt=je;break;case"restore":nt=qe;break;case"destroy":nt=xe;break;default:b.raise("invalid event, must be one of frame,lost,restore,destroy")}return nt.push(et),{cancel:function(){for(var gt=0;gt<nt.length;++gt)if(nt[gt]===et){nt[gt]=nt[nt.length-1],nt.pop();return}}}}var at=n(Et,{clear:At,prop:tr.define.bind(null,o1),context:tr.define.bind(null,Jg),this:tr.define.bind(null,e5),draw:Et({}),buffer:function(De){return ue.create(De,Kg,!1,!1)},elements:function(De){return Te.create(De,!1)},texture:ke.create2D,cube:ke.createCube,renderbuffer:ee.create,framebuffer:Q.create,framebufferCube:Q.createCube,vao:se.createVAO,attributes:X,frame:Tt,on:Gt,limits:H,hasExtension:function(De){return H.extensions.indexOf(De.toLowerCase())>=0},read:be,destroy:tt,_gl:T,_refresh:vt,poll:function(){Nt(),he&&he.update()},now:Ye,stats:ie});return v.onDone(null,at),at}return t5})}(ac)),ac.exports}const Oy=Cy,Ly=Ba,Ry=e=>{const r=Object.assign({},{},e.glOptions,{onDone:(a,i)=>{if(a)throw a}}),n=My()(r),s=new Map,o=a=>{a.rendering=Object.assign({},Ly,a.rendering),Oy(n)(a,i=>{n.clear({color:a.rendering.background,depth:1}),a.entities&&a.entities.sort((c,l)=>{const u="transparent"in c.visuals?c.visuals.transparent:!1,d="transparent"in l.visuals?l.visuals.transparent:!1;return u===d?0:u?1:-1}).forEach(c=>{const{visuals:l}=c;if(("show"in l?l.show:!0)&&l.drawCmd&&a.drawCommands[l.drawCmd]){let d;l.cacheId?d=s.get(l.cacheId):(l.cacheId=s.size,d=a.drawCommands[l.drawCmd](n,c),s.set(l.cacheId,d));const h={...c,...l,camera:a.camera};d(h)}})})};return function(i){n.poll(),o(i)}};var Fy=Ry,ic,d1;function h1(){if(d1)return ic;d1=1;const e=pr;return ic=(r,n={})=>{const s=[],o={visuals:{color:[0,0,1,1],fadeOut:!1},ticks:1,size:[16,16],centered:!1,lineWidth:2},a=Object.assign({},o.visuals,n.visuals||{}),{fadeOut:i,color:c}=a,{size:l,ticks:u,centered:d,lineWidth:h}=Object.assign({},o,n),m=l[0],$=l[1];if(d){const g=m*.5,y=$*.5,S=g%u,N=-g+S,O=-N,L=y%u,R=-y+L,F=-R,z=0;for(let J=N,oe=0;J<=O;J+=u,oe+=1)oe%z!==0&&(s.push(R,J,0),s.push(F,J,0),s.push(R,J,0));for(let J=R,oe=0;J<=F;J+=u,oe+=1)oe%z!==0&&(s.push(J,N,0),s.push(J,O,0),s.push(J,N,0))}else{for(let g=-m*.5;g<=m*.5;g+=u)s.push(-$*.5,g,0),s.push($*.5,g,0),s.push(-$*.5,g,0);for(let g=-$*.5;g<=$*.5;g+=u)s.push(g,-m*.5,0),s.push(g,m*.5,0),s.push(g,-m*.5,0)}return r({vert:`precision mediump float;

    uniform float camNear, camFar;
    uniform mat4 model, view, projection;

    attribute vec3 position;
    varying vec3 fragNormal, fragPosition;
    varying vec4 worldPosition;

    void main() {
      fragPosition = position;
      worldPosition = model * vec4(position, 1);
      vec4 glPosition = projection * view * worldPosition;
      gl_Position = glPosition;
    }`,frag:`precision mediump float;
    uniform vec4 color;
    varying vec3 fragNormal, fragPosition;
    varying vec4 worldPosition;

    uniform vec4 fogColor;
    uniform bool fadeOut;
    void main() {
      float dist = .5;
      if(fadeOut){
        dist = distance( vec2(0.,0.), vec2(worldPosition.x, worldPosition.y));
        dist *= 0.0025;
        dist = sqrt(dist);
      }

      gl_FragColor = mix(color, fogColor, dist);
    }
    `,attributes:{position:r.buffer(s)},count:s.length/3,uniforms:{model:(g,y)=>y&&y.model?y.model:e.identity([]),color:(g,y)=>y&&y.color?y.color:c,fogColor:(g,y)=>y&&y.color?[y.color[0],y.color[1],y.color[2],0]:[c[0],c[1],c[2],0],fadeOut:(g,y)=>y&&y.fadeOut!==void 0?y.fadeOut:i},lineWidth:(g,y)=>Math.min(y&&y.lineWidth?y.lineWidth:h,r.limits.lineWidthDims[1]),primitive:"lines",cull:{enable:!0,face:"front"},polygonOffset:{enable:!0,offset:{factor:1,units:Math.random()*10}},blend:{enable:!0,func:{src:"src alpha",dst:"one minus src alpha"}}})},ic}const Ny=(e,t)=>{const r={size:[50,50],ticks:[10,1]},{size:n,ticks:s}=Object.assign({},r,t),o=h1()(e,{size:n,ticks:s[0]}),a=h1()(e,{size:n,ticks:s[1]});return c=>{o(c),a({color:c.subColor,fadeOut:c.fadeOut})}};var Gy=Ny;const zt=pr,ky=(e,t)=>{const r={xColor:[1,0,0,1],yColor:[0,1,0,1],zColor:[0,0,1,1],size:10,lineWidth:3,alwaysVisible:!0};let{size:n,xColor:s,yColor:o,zColor:a,lineWidth:i,alwaysVisible:c}=Object.assign({},r,t);i>e.limits.lineWidthDims[1]&&(i=e.limits.lineWidthDims[1]);const l=[0,0,0,n,0,0],u={frag:`precision mediump float;
    uniform vec4 color;
    void main() {
      gl_FragColor = color;
    }`,vert:`
    precision mediump float;
    attribute vec3 position;
    uniform mat4 model, view, projection;
    void main() {
      gl_Position = projection * view * model * vec4(position, 1);
    }`,uniforms:{model:(g,y)=>y&&y.model?y.model:zt.identity([]),color:(g,y)=>y.color,angle:(g,y)=>y.angle},attributes:{position:l},count:l.length/3,primitive:"line loop",lineWidth:i,depth:{enable:!c}},d=zt.identity([]),h=zt.rotateZ(zt.create(),zt.identity([]),Math.PI/2),m=zt.rotateY(zt.create(),zt.identity([]),-Math.PI/2),$=e(u);return g=>{const y={model:zt.identity([])};return g=Object.assign({},y,g),$([{color:s,model:zt.multiply(zt.create(),g.model,d)},{color:o,model:zt.multiply(zt.create(),g.model,h)},{color:a,model:zt.multiply(zt.create(),g.model,m)}])}};var Dy=ky,cc,m1;function p1(){return m1||(m1=1,cc={frag:`
precision mediump float;
varying vec3 surfaceNormal, surfacePosition;

uniform float ambientLightAmount;
uniform float diffuseLightAmount;
uniform float specularLightAmount;

uniform vec3 lightDirection;
uniform vec4 lightColor;
uniform vec3 opacity;
uniform float uMaterialShininess;

varying vec4 vColor;
uniform vec4 ucolor;
uniform float vColorToggler;

uniform vec2 printableArea;
vec4 errorColor = vec4(0.15, 0.15, 0.15, 0.3);//vec4(0.15, 0.15, 0.15, 0.3);
varying vec4 _worldSpacePosition;
varying float ambientAo;

void main () {
  vec4 depth = gl_FragCoord;
  vec4 endColor = vColor * vColorToggler + ucolor * (1.0 - vColorToggler);

  vec3 ambient = ambientLightAmount * endColor.rgb ; //ambientAo * 

  float diffuseWeight = dot(surfaceNormal, lightDirection);
  vec3 diffuse = diffuseLightAmount * endColor.rgb * clamp(diffuseWeight , 0.0, 1.0 );

  //specular
  
  vec4 specularColor = vec4(lightColor);
  vec3 eyeDirection = normalize(surfacePosition.xyz);
  vec3 reflectionDirection = reflect(-lightDirection, -surfaceNormal);
  float specularLightWeight = pow(max(dot(reflectionDirection, eyeDirection), 0.0), uMaterialShininess);
  vec3 specular = specularColor.rgb * specularLightWeight * specularLightAmount;

  gl_FragColor = vec4((ambient + diffuse + specular), endColor.a);
}
`,vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection, unormal;

attribute vec3 position, normal;
attribute vec4 color;

attribute float ao;
varying float ambientAo;

varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;
varying vec4 vColor;

void main() {
  surfacePosition = (unormal * vec4(position, 1.0)).xyz;
  surfaceNormal = normalize((unormal * vec4(normal, 1.0)).xyz); //vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;
  //gl_Position = projection * view * worldSpacePosition;

  vColor = color;

  //ambientAo = (1. - ao) * (0.5 * max(normal.x, 0.) + 0.5);

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
  //gl_Position = zBufferAdjust(glPosition, camNear, camFar);
}
`}),cc}var lc,v1;function g1(){return v1||(v1=1,lc={vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection;

attribute vec3 position, normal;

varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;

void main() {
  surfacePosition = position;
  surfaceNormal = normal;
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
}
`,frag:`
precision mediump float;
varying vec3 surfaceNormal;
uniform float ambientLightAmount;
uniform float diffuseLightAmount;
uniform vec4 ucolor;
uniform vec3 lightDirection;
uniform vec3 opacity;

varying vec4 _worldSpacePosition;

uniform vec2 printableArea;

vec4 errorColor = vec4(0.15, 0.15, 0.15, 0.3);

void main () {
  vec4 depth = gl_FragCoord;

  float v = 0.8; // shadow value
  vec4 endColor = ucolor;

  vec3 ambient = ambientLightAmount * endColor.rgb;
  float cosTheta = dot(surfaceNormal, lightDirection);
  vec3 diffuse = diffuseLightAmount * endColor.rgb * clamp(cosTheta , 0.0, 1.0 );

  float cosTheta2 = dot(surfaceNormal, vec3(-lightDirection.x, -lightDirection.y, lightDirection.z));
  vec3 diffuse2 = diffuseLightAmount * endColor.rgb * clamp(cosTheta2 , 0.0, 1.0 );

  gl_FragColor = vec4((ambient + diffuse + diffuse2 * v), endColor.a);
}`}),lc}const Zr=pr,{meshColor:By}=Ba,Iy=(e,t={extras:{}})=>{const r={useVertexColors:!0,dynamicCulling:!0,geometry:void 0,color:By,visuals:{}},{geometry:n,dynamicCulling:s,useVertexColors:o,color:a,visuals:i}=Object.assign({},r,t),c=e.buffer([]),l=!!(n.indices&&n.indices.length>0),u=!!(n.normals&&n.normals.length>0),d="transparent"in i?i.transparent:!1,h=!!(o&&n.colors&&n.colors.length>0),m=n.transforms||Zr.create(),$=Zr.determinant(m)<0,g=s&&$?"front":"back",y=h?p1().vert:g1().vert,S=h?p1().frag:g1().frag,N=Zr.invert(Zr.create(),m);let O={primitive:"triangles",vert:y,frag:S,uniforms:{model:(L,R)=>m,ucolor:(L,R)=>R&&R.color?R.color:a,vColorToggler:(L,R)=>R&&R.useVertexColors&&R.useVertexColors===!0?1:0,unormal:(L,R)=>{const F=Zr.invert(Zr.create(),R.camera.view);return Zr.multiply(F,N,F),Zr.transpose(F,F),F}},attributes:{position:e.buffer({usage:"static",type:"float",data:n.positions}),ao:c},cull:{enable:!0,face:g}};return d&&(O.blend={enable:!0,func:{src:"src alpha",dst:"one minus src alpha"}}),n.cells?O.elements=n.cells:l?O.elements=e.elements({usage:"static",type:"uint16",data:n.indices}):n.triangles?O.elements=n.triangles:O.count=n.positions.length/3,u&&(O.attributes.normal=e.buffer({usage:"static",type:"float",data:n.normals})),h&&(O.attributes.color=e.buffer({usage:"static",type:"float",data:n.colors})),O=Object.assign({},O,t.extras),e(O)};var Vy=Iy,fc,y1;function b1(){return y1||(y1=1,fc={frag:`
precision mediump float;
varying vec4 vColor;

void main () {
  gl_FragColor = vColor;
}
`,vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection;

attribute vec3 position, normal;
attribute vec4 color;

varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;
varying vec4 vColor;

void main() {
  vColor = color;

  surfacePosition = position;
  surfaceNormal = normal;
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
}
`}),fc}var uc,_1;function zy(){return _1||(_1=1,uc={vert:`
precision mediump float;

uniform float camNear, camFar;
uniform mat4 model, view, projection;

attribute vec3 position, normal;


varying vec3 surfaceNormal, surfacePosition;
varying vec4 _worldSpacePosition;


void main() {


  surfacePosition = position;
  surfaceNormal = normal;
  vec4 worldSpacePosition = model * vec4(position, 1);
  _worldSpacePosition = worldSpacePosition;

  vec4 glPosition = projection * view * model * vec4(position, 1);
  gl_Position = glPosition;
}
`,frag:`
precision mediump float;
varying vec3 surfaceNormal;
uniform float ambientLightAmount;
uniform float diffuseLightAmount;
uniform vec4 ucolor;
uniform vec3 lightDirection;
uniform vec3 opacity;

varying vec4 _worldSpacePosition;

uniform vec2 printableArea;

vec4 errorColor = vec4(0.15, 0.15, 0.15, 0.3);

void main () {
  vec4 depth = gl_FragCoord;

  float v = 0.8; // shadow value
  vec4 endColor = ucolor;

  vec3 ambient = ambientLightAmount * endColor.rgb;
  float cosTheta = dot(surfaceNormal, lightDirection);
  vec3 diffuse = diffuseLightAmount * endColor.rgb * clamp(cosTheta , 0.0, 1.0 );

  float cosTheta2 = dot(surfaceNormal, vec3(-lightDirection.x, -lightDirection.y, lightDirection.z));
  vec3 diffuse2 = diffuseLightAmount * endColor.rgb * clamp(cosTheta2 , 0.0, 1.0 );

  gl_FragColor = vec4((ambient + diffuse + diffuse2 * v), endColor.a);
}`}),uc}var dc,w1;function Uy(){return w1||(w1=1,dc={frag:`
precision mediump float;
uniform vec4 ucolor;

void main () {
  gl_FragColor = ucolor;
}
`}),dc}const qy=pr,{meshColor:Xy}=Ba,jy=(e,t={})=>{const r={color:Xy,geometry:void 0};let{geometry:n,color:s,transparent:o}=Object.assign({},r,t);"color"in n&&(s=n.color);const a=!!(n.indices&&n.indices.length>0),i=!!(n.normals&&n.normals.length>0),c=!!(n.colors&&n.colors.length>0),l=c?b1().vert:zy().vert,u=c?b1().frag:Uy().frag,d={primitive:"lines",vert:l,frag:u,uniforms:{model:(h,m)=>m.model||n.transforms||qy.create(),ucolor:(h,m)=>m&&m.color?m.color:s},attributes:{position:e.buffer({usage:"static",type:"float",data:n.positions})}};return o&&(d.blend={enable:!0,func:{src:"src alpha",dst:"one minus src alpha"}}),c&&(d.attributes.color=e.buffer({usage:"static",type:"float",data:n.colors})),a&&(d.elements=e.elements({usage:"static",type:"uint16",data:n.indices})),i&&(d.attributes.normal=e.buffer({usage:"static",type:"float",data:n.normals})),e(d)};var Hy=jy,vh=1e-6,gh=Yy;function Yy(){var e=new Float32Array(3);return e[0]=0,e[1]=0,e[2]=0,e}var Wy=Zy;function Zy(e){var t=new Float32Array(3);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t}var yh=Qy;function Qy(e,t,r){var n=new Float32Array(3);return n[0]=e,n[1]=t,n[2]=r,n}var bh=Ky;function Ky(e,t){var r=t[0],n=t[1],s=t[2],o=r*r+n*n+s*s;return o>0&&(o=1/Math.sqrt(o),e[0]=t[0]*o,e[1]=t[1]*o,e[2]=t[2]*o),e}var _h=Jy;function Jy(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}var eb=rb,$1=yh,x1=bh,tb=_h;function rb(e,t){var r=$1(e[0],e[1],e[2]),n=$1(t[0],t[1],t[2]);x1(r,r),x1(n,n);var s=tb(r,n);return s>1?0:Math.acos(s)}var nb=sb;function sb(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e}var ob=ab;function ab(e,t,r,n){return e[0]=t,e[1]=r,e[2]=n,e}var ib=cb,hc=vh;function cb(e,t){var r=e[0],n=e[1],s=e[2],o=t[0],a=t[1],i=t[2];return Math.abs(r-o)<=hc*Math.max(1,Math.abs(r),Math.abs(o))&&Math.abs(n-a)<=hc*Math.max(1,Math.abs(n),Math.abs(a))&&Math.abs(s-i)<=hc*Math.max(1,Math.abs(s),Math.abs(i))}var lb=fb;function fb(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}var ub=db;function db(e,t,r){return e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e}var wh=hb;function hb(e,t,r){return e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e}var mb=wh,$h=pb;function pb(e,t,r){return e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e}var vb=$h,xh=gb;function gb(e,t,r){return e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e}var yb=xh,bb=_b;function _b(e,t,r){return e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e}var wb=$b;function $b(e,t,r){return e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e}var xb=Eb;function Eb(e,t){return e[0]=Math.floor(t[0]),e[1]=Math.floor(t[1]),e[2]=Math.floor(t[2]),e}var Ab=Tb;function Tb(e,t){return e[0]=Math.ceil(t[0]),e[1]=Math.ceil(t[1]),e[2]=Math.ceil(t[2]),e}var Sb=Pb;function Pb(e,t){return e[0]=Math.round(t[0]),e[1]=Math.round(t[1]),e[2]=Math.round(t[2]),e}var Cb=Mb;function Mb(e,t,r){return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e}var Ob=Lb;function Lb(e,t,r,n){return e[0]=t[0]+r[0]*n,e[1]=t[1]+r[1]*n,e[2]=t[2]+r[2]*n,e}var Eh=Rb;function Rb(e,t){var r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return Math.sqrt(r*r+n*n+s*s)}var Fb=Eh,Ah=Nb;function Nb(e,t){var r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return r*r+n*n+s*s}var Gb=Ah,Th=kb;function kb(e){var t=e[0],r=e[1],n=e[2];return Math.sqrt(t*t+r*r+n*n)}var Db=Th,Sh=Bb;function Bb(e){var t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n}var Ib=Sh,Vb=zb;function zb(e,t){return e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e}var Ub=qb;function qb(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}var Xb=jb;function jb(e,t,r){var n=t[0],s=t[1],o=t[2],a=r[0],i=r[1],c=r[2];return e[0]=s*c-o*i,e[1]=o*a-n*c,e[2]=n*i-s*a,e}var Hb=Yb;function Yb(e,t,r,n){var s=t[0],o=t[1],a=t[2];return e[0]=s+n*(r[0]-s),e[1]=o+n*(r[1]-o),e[2]=a+n*(r[2]-a),e}var Wb=Zb;function Zb(e,t){t=t||1;var r=Math.random()*2*Math.PI,n=Math.random()*2-1,s=Math.sqrt(1-n*n)*t;return e[0]=Math.cos(r)*s,e[1]=Math.sin(r)*s,e[2]=n*t,e}var Qb=Kb;function Kb(e,t,r){var n=t[0],s=t[1],o=t[2],a=r[3]*n+r[7]*s+r[11]*o+r[15];return a=a||1,e[0]=(r[0]*n+r[4]*s+r[8]*o+r[12])/a,e[1]=(r[1]*n+r[5]*s+r[9]*o+r[13])/a,e[2]=(r[2]*n+r[6]*s+r[10]*o+r[14])/a,e}var Jb=e_;function e_(e,t,r){var n=t[0],s=t[1],o=t[2];return e[0]=n*r[0]+s*r[3]+o*r[6],e[1]=n*r[1]+s*r[4]+o*r[7],e[2]=n*r[2]+s*r[5]+o*r[8],e}var t_=r_;function r_(e,t,r){var n=t[0],s=t[1],o=t[2],a=r[0],i=r[1],c=r[2],l=r[3],u=l*n+i*o-c*s,d=l*s+c*n-a*o,h=l*o+a*s-i*n,m=-a*n-i*s-c*o;return e[0]=u*l+m*-a+d*-c-h*-i,e[1]=d*l+m*-i+h*-a-u*-c,e[2]=h*l+m*-c+u*-i-d*-a,e}var n_=s_;function s_(e,t,r,n){var s=r[1],o=r[2],a=t[1]-s,i=t[2]-o,c=Math.sin(n),l=Math.cos(n);return e[0]=t[0],e[1]=s+a*l-i*c,e[2]=o+a*c+i*l,e}var o_=a_;function a_(e,t,r,n){var s=r[0],o=r[2],a=t[0]-s,i=t[2]-o,c=Math.sin(n),l=Math.cos(n);return e[0]=s+i*c+a*l,e[1]=t[1],e[2]=o+i*l-a*c,e}var i_=c_;function c_(e,t,r,n){var s=r[0],o=r[1],a=t[0]-s,i=t[1]-o,c=Math.sin(n),l=Math.cos(n);return e[0]=s+a*l-i*c,e[1]=o+a*c+i*l,e[2]=t[2],e}var l_=f_,Qr=gh();function f_(e,t,r,n,s,o){var a,i;for(t||(t=3),r||(r=0),n?i=Math.min(n*t+r,e.length):i=e.length,a=r;a<i;a+=t)Qr[0]=e[a],Qr[1]=e[a+1],Qr[2]=e[a+2],s(Qr,Qr,o),e[a]=Qr[0],e[a+1]=Qr[1],e[a+2]=Qr[2];return e}var yo={EPSILON:vh,create:gh,clone:Wy,angle:eb,fromValues:yh,copy:nb,set:ob,equals:ib,exactEquals:lb,add:ub,subtract:wh,sub:mb,multiply:$h,mul:vb,divide:xh,div:yb,min:bb,max:wb,floor:xb,ceil:Ab,round:Sb,scale:Cb,scaleAndAdd:Ob,distance:Eh,dist:Fb,squaredDistance:Ah,sqrDist:Gb,length:Th,len:Db,squaredLength:Sh,sqrLen:Ib,negate:Vb,inverse:Ub,normalize:bh,dot:_h,cross:Xb,lerp:Hb,random:Wb,transformMat4:Qb,transformMat3:Jb,transformQuat:t_,rotateX:n_,rotateY:o_,rotateZ:i_,forEach:l_};const Rn=pr,mc=yo,Ph={view:Rn.identity(new Float32Array(16)),projection:Rn.identity(new Float32Array(16)),matrix:Rn.identity(new Float32Array(16)),near:1,far:18e3,up:[0,0,1],eye:new Float32Array(3),position:[450,550,700],target:[0,0,0],fov:Math.PI/4,aspect:1,viewport:[0,0,0,0],projectionType:"perspective"},Ch={},u_=Object.assign({},Ph,Ch),d_=(e,t,r)=>{const n=r.width/r.height,s=Rn.perspective(Rn.identity([]),t.fov,n,t.near,t.far),o=[0,0,r.width,r.height],a=e||{};return a.projection=s,a.aspect=n,a.viewport=o,a},h_=(e,t)=>{t||(t=e);const{position:r,target:n,up:s}=t,o=mc.subtract([],r,n),a=mc.add(mc.create(),n,o),i=Rn.lookAt(Rn.create(),a,n,s),c=e||{};return c.position=a,c.view=i,c};var gl={cameraState:Ph,cameraProps:Ch,defaults:u_,setProjection:d_,update:h_};const Pa=pr,m_={view:Pa.identity(new Float32Array(16)),projection:Pa.identity(new Float32Array(16)),matrix:Pa.identity(new Float32Array(16)),near:1,far:1300,up:[0,0,1],eye:new Float32Array(3),position:[150,250,200],target:[0,0,0],fov:Math.PI/4,aspect:1,viewport:[0,0,0,0],zoom:1,projectionType:"orthographic"},p_={},v_=(e,t)=>{const{width:r,height:n}=t,s=r/n,o=[0,0,r,n],a=e.zoom,i=-r*a,c=r*a,l=-n*a,u=n*a;return{projection:Pa.ortho([],i,c,l,u,e.near,e.far),aspect:s,viewport:o}};var Oa={cameraState:m_,cameraProps:p_,setProjection:v_};const gs=yo,La=pr,g_=e=>{const{near:t,far:r,fov:n,zoom:s}=e,{viewport:o}=e,a=gl.setProjection(e,{width:o[2],height:o[3]}),{projectionType:i}=gl.cameraState;return Object.assign({},e,a,{projectionType:i},{near:t,far:r,fov:n})},y_=e=>{const{fov:t,aspect:r}=e,n=gs.length(gs.subtract([],e.position,e.target))*.3,s=Math.tan(t)*n*r,o=Math.tan(t)*n,{near:a,far:i,viewport:c}=e,l={zoom:1,near:a,far:i},u=Oa.cameraState,d=Oa.setProjection(l,{width:s,height:o});return Object.assign({},u,e,d,{projectionType:u.projectionType,viewport:c})},b_=({camera:e})=>{const r=gs.distance(e.position,e.target),n=[r,r,r];return{view:La.lookAt(La.create(),n,e.target,e.up),position:n}},__=(e,{camera:t})=>{const r={top:[0,-1e-6,1],bottom:[0,0,-1],front:[0,1,0],back:[0,-1,0],left:[-1,0,0],right:[1,0,0],undefined:[0,0,0]},n=gs.distance(t.position,t.target),s=gs.add(gs.create(),r[e].map(a=>a*n),t.target);return{view:La.lookAt(La.create(),s,t.target,t.up),position:s}};var w_={toPerspectiveView:b_,toPresetView:__,fromOrthographicToPerspective:g_,fromPerspectiveToOrthographic:y_};const Mh=e=>e.reduce((t,r)=>Array.isArray(r)?t.concat(Mh(r)):t.concat(r),[]);var $_=Mh;const x_=(e,t)=>e-t;var E_=x_;const A_=e=>{if(!(!Array.isArray(e)||e.length===0))return e[0]};var T_=A_;const S_=(e,t,r)=>{let n=0,s=e.length;for(;s>n;){const o=Math.floor((n+s)/2),a=e[o];r(t,a)>0?n=o+1:s=o}return e.splice(n,0,t),e};var P_=S_;const C_=(e,t)=>{if(!(!Array.isArray(e)||e.length<t))return e[t]};var M_=C_;const O_=(e,t,r)=>{for(e=e.slice();e.length<r;)e.push(t);return e};var L_=O_;const R_=e=>Array.isArray(e)?e:e==null?[]:[e];var F_=R_,Cl={flatten:$_,fnNumberSort:E_,head:T_,insertSorted:P_,nth:M_,padToLength:L_,toArray:F_};const N_=e=>{if(e.length===0)return[[0,0,0],[0,0,0]];const t=Array.isArray(e)&&Array.isArray(e[0]),r=t?e[0].length:3,n=new Array(r),s=new Array(r);for(let o=0;o<r;o+=1)n[o]=1/0,s[o]=-1/0;if(t)e.forEach(o=>{for(let a=0;a<r;a+=1){const i=t?o[a]:o;s[a]=i>s[a]?i:s[a],n[a]=i<n[a]?i:n[a]}});else for(let o=0;o<e.length;o+=r)for(let a=0;a<r;a+=1){const i=e[a+o];s[a]=i>s[a]?i:s[a],n[a]=i<n[a]?i:n[a]}return[n,s]};var G_=N_;const or=yo,{flatten:k_}=Cl,D_=G_,B_=(...e)=>{e=k_(e);let t;e.forEach(c=>{let l=D_(c.positions);l=l.map(u=>or.transformMat4(u,u,c.transforms)),t?(or.min(t[0],t[0],l[0]),or.max(t[1],t[1],l[1])):t=l});const r=or.min(or.create(),t[1],t[0]),n=or.max(or.create(),t[1],t[0]),s=or.subtract(or.create(),n,r);let o=or.scale(or.create(),s,.5);return o=or.add(o,r,o),{dia:or.distance(o,n),center:[...o],min:[...r],max:[...n],size:[...s]}};var I_=B_,pc,E1;function V_(){if(E1)return pc;E1=1,pc=e;function e(t,r,n){var s=r[0],o=r[1],a=r[2],i=n[0],c=n[1],l=n[2],u=n[3],d=n[4],h=n[5],m=n[6],$=n[7],g=n[8],y=n[9],S=n[10],N=n[11],O=n[12],L=n[13],R=n[14],F=n[15],z=1/(s*u+o*$+a*N+F);return t[0]=(s*i+o*d+a*g+O)*z,t[1]=(s*c+o*h+a*y+L)*z,t[2]=(s*l+o*m+a*S+R)*z,t}return pc}var vc,A1;function z_(){if(A1)return vc;A1=1;var e=V_();vc=t;function t(r,n,s,o){var a=s[0],i=s[1],c=s[2],l=s[3],u=n[0],d=n[1],h=n[2];return u=u-a,d=l-d-1,d=d-i,r[0]=2*u/c-1,r[1]=2*d/l-1,r[2]=2*h-1,e(r,r,o)}return vc}const jt=yo,po=pr,{max:gc,min:yc,sqrt:T1,PI:U_,sin:ns,cos:sa,atan2:oa}=Math,q_=I_,Ml={limits:{minDistance:.01,maxDistance:1e4},drag:.27,EPS:1e-6,zoomToFit:{auto:!0,targets:"all",tightness:1.5},userControl:{zoom:!0,zoomSpeed:1,rotate:!0,rotateSpeed:1,pan:!0,panSpeed:1},autoRotate:{enabled:!1,speed:1},autoAdjustPlanes:!0},Oh={thetaDelta:0,phiDelta:0,scale:1},X_=Object.assign({},Oh,Ml),j_=({controls:e,camera:t},r)=>{const{EPS:n,drag:s}=e,{position:o,target:a}=t,i=e.up?e.up:t.up;let c=e.thetaDelta;const l=e.phiDelta,u=e.scale,d=jt.subtract([],o,a);let h,m;i[2]===1?(h=oa(d[0],d[1]),m=oa(T1(d[0]*d[0]+d[1]*d[1]),d[2])):(h=oa(d[0],d[2]),m=oa(T1(d[0]*d[0]+d[2]*d[2]),d[1])),e.autoRotate.enabled&&e.userControl.rotate&&(c+=2*Math.PI/60/60*e.autoRotate.speed),h+=c,m+=l,m=gc(n,yc(U_-n,m));const $=gc(e.limits.minDistance,yc(e.limits.maxDistance,jt.length(d)*u));i[2]===1?(d[0]=$*ns(m)*ns(h),d[2]=$*sa(m),d[1]=$*ns(m)*sa(h)):(d[0]=$*ns(m)*ns(h),d[1]=$*sa(m),d[2]=$*ns(m)*sa(h));const g=jt.add(jt.create(),a,d),y=po.lookAt(po.create(),g,a,i),S=1-gc(yc(s,1),.01),N=jt.distance(o,g)>.001;return{controls:{thetaDelta:c*S,phiDelta:l*S,scale:1,changed:N},camera:{position:g,view:y}}},H_=({controls:e,camera:t,speed:r=1},n)=>{let{thetaDelta:s,phiDelta:o}=e;return e.userControl.rotate&&(s+=n[0]*r,o+=n[1]*r),{controls:{thetaDelta:s,phiDelta:o},camera:t}},Y_=({controls:e,camera:t,speed:r=1},n=0)=>{let{scale:s}=e;if(e.userControl.zoom&&t&&n!==void 0&&n!==0&&!isNaN(n)){const o=Math.sign(n)===0?1:Math.sign(n);n=n/n*o*r;const a=n+e.scale,i=jt.distance(t.position,t.target)*a;if(i>e.limits.minDistance&&i<e.limits.maxDistance&&(s+=n),t.projectionType==="orthographic"){const c=jt.length(jt.subtract([],t.position,t.target))*.3,l=Math.tan(t.fov)*c*t.aspect,u=Math.tan(t.fov)*c;t=Oa.setProjection(t,{width:l,height:u})}}return{controls:{scale:s},camera:t}},W_=({controls:e,camera:t,speed:r=1},n)=>{const s=z_(),{projection:o,view:a,viewport:i}=t,c=po.multiply([],o,a),l=po.invert([],c),u=[i[2],i[3],0],d=[i[2]-n[0],i[3]+n[1],0],h=s([],u,i,l),m=s([],d,i,l),$=jt.distance(t.position,t.eye),g=jt.subtract([],h,m).map(y=>y*r*$*e.scale);return{controls:e,camera:{position:jt.add(jt.create(),t.position,g),target:jt.add(jt.create(),t.target,g)}}},Z_=({controls:e,camera:t,entities:r})=>{const{zoomToFit:n}=e;if(n.targets!=="all")return{controls:e,camera:t};if(r.length===0)return{controls:e,camera:t};const s=r.map(m=>m.geometry),o=q_(s),{fov:a,target:i,position:c}=t,{tightness:l}=Object.assign({},n,Ml.zoomToFit),u=o.dia*l/Math.tan(a/2),d=jt.distance(i,c),h=u/d;return{camera:{target:o.center},controls:{scale:h}}},Q_=({controls:e,camera:t},r)=>({camera:{position:r.camera.position,target:r.camera.target,projection:po.perspective([],t.fov,t.aspect,t.near,t.far),view:r.camera.view},controls:{thetaDelta:r.controls.thetaDelta,phiDelta:r.controls.phiDelta,scale:r.controls.scale}});var K_={controlsProps:Ml,controlsState:Oh,defaults:X_,update:j_,rotate:H_,zoom:Y_,pan:W_,zoomToFit:Z_,reset:Q_};const S1=pr,bc=Math.floor(65535/2),J_=(e,t)=>{let{color:r}=e;const n=t.sides;if(n.length===0)return[];"color"in t&&(r=t.color);const s=r[3]<1,o=[],a=Math.floor(n.length/bc)+1,i=(l,u)=>{o.push(l,u||l)},c=[];for(let l=0;l<a;l++){const u=l*bc,d=Math.min(u+bc,n.length),h=[];for(let y=u;y<d;y++){const S=n[y];if(S.color){if(o.length===0&&h.length>0){const N=h.length;for(let O=0;O<N;O++)o.push(r)}i(S.color,S.endColor)}else o.length&&i(r);h.push([S[0][0],S[0][1],0]),h.push([S[1][0],S[1][1],0])}const m=h.map(y=>[0,0,-1]),$=h.map((y,S)=>S),g=t.transforms?S1.clone(t.transforms):S1.create();c.push({type:"2d",positions:h,normals:m,indices:$,transforms:g,color:r,colors:o,isTransparent:s})}return c};var e3=J_;const Kr=yo,P1=pr,t3=65535,r3=(e,t)=>{let{color:r,smoothLighting:n}=e;"color"in t&&(r=t.color);const s=t.polygons,o=t.transforms?P1.clone(t.transforms):P1.create(),a=[];let i=0;for(;i<s.length;){let c=0,l=i;for(let y=i;y<s.length&&(c+=s[y].vertices.length,!(c>t3));y++)l++;const u=[],d=[],h=[],m=[],$=r[3]<1;for(let y=i;y<l;y++){const S=s[y],N=S.vertices,O=s3(S),L=n3(S,r),R=[];for(let F=0;F<N.length;F++){const z=N[F];u.push(z),d.push(O),m.push(L);const J=u.length-1;R.push(J)}for(let F=2;F<R.length;F++)h.push([R[0],R[F-1],R[F]])}const g={type:"3d",positions:u,normals:d,indices:h,colors:m,transforms:o,isTransparent:$};a.push(g),i=l}return a},n3=(e,t)=>{let r=t;return e.color&&(r=e.color),r&&r.length<4&&r.push(1),r},s3=e=>{if(e.plane)return Kr.clone(e.plane);const t=e.vertices,r=Kr.create();Kr.subtract(r,t[1],t[0]);const n=Kr.create();Kr.subtract(n,t[2],t[0]);const s=Kr.create();return Kr.cross(s,r,n),Kr.normalize(s,s),s};var o3=r3;const C1=pr,_c=Math.floor(65535/2)-2,a3=(e,t)=>{let{color:r}=e;const n=t.points;if(n.length===0)return[];"color"in t&&(r=t.color);const s=r[3]<1,o=Math.floor(n.length/_c)+1,a=[];for(let i=0;i<o;i++){const c=i*_c,l=Math.min(c+_c,n.length),u=[];let d;for(let g=c;g<l;g++){const y=n[g];d&&(u.push([d[0],d[1],0]),u.push([y[0],y[1],0])),d=y}if(i+1===o&&t.isClosed&&d){const g=n[0];u.push([d[0],d[1],0]),u.push([g[0],g[1],0])}const h=u.map(g=>[0,0,-1]),m=u.map((g,y)=>y),$=t.transforms?C1.clone(t.transforms):C1.create();a.push({type:"2d",positions:u,normals:h,indices:m,transforms:$,color:r,isTransparent:s})}return a};var i3=a3;const{flatten:c3,toArray:l3}=Cl,{meshColor:f3}=Ba,u3=e3,d3=o3,h3=i3,m3=e=>e.map(r=>{const n={drawCmd:r.type==="2d"?"drawLines":"drawMesh",show:!0,transparent:r.isTransparent,useVertexColors:!0};return{geometry:r,visuals:n}}),p3=(e,...t)=>{const r={color:f3,smoothNormals:!0},{color:n,smoothNormals:s}=Object.assign({},r,e);t=c3(l3(t)),t=t.filter(a=>a&&a instanceof Object);const o=[];return t.forEach(a=>{let i=[];"sides"in a?i=u3({color:n},a):"points"in a?i=h3({color:n},a):"polygons"in a&&(i=d3({smoothLighting:s,normalThreshold:.3,color:n},a)),o.push(...m3(i))}),o};var v3=p3,En={prepareRender:Fy,drawCommands:{drawGrid:Gy,drawAxis:Dy,drawMesh:Vy,drawLines:Hy},cameras:{camera:w_,orthographic:Oa,perspective:gl},controls:{orbit:K_},entitiesFromSolids:v3};function g3(e){let t,r;const n=e[1].default,s=a5(n,e,e[0],null);return{c(){t=lr("h2"),s&&s.c(),Vt(t,"class","svelte-yghvt3")},m(o,a){Fr(o,t,a),s&&s.m(t,null),r=!0},p(o,[a]){s&&s.p&&(!r||a&1)&&c5(s,n,o,o[0],r?i5(n,o[0],a,null):l5(o[0]),null)},i(o){r||(cr(s,o),r=!0)},o(o){dr(s,o),r=!1},d(o){o&&xr(t),s&&s.d(o)}}}function y3(e,t,r){let{$$slots:n={},$$scope:s}=t;return e.$$set=o=>{"$$scope"in o&&r(0,s=o.$$scope)},[s,n]}class yl extends Dn{constructor(t){super(),kn(this,t,y3,g3,Gn,{})}}function b3(e){let t;return{c(){t=Fn("Preview")},m(r,n){Fr(r,t,n)},d(r){r&&xr(t)}}}function _3(e){let t,r,n,s,o;return r=new yl({props:{$$slots:{default:[b3]},$$scope:{ctx:e}}}),{c(){t=lr("div"),wr(r.$$.fragment),n=$r(),s=lr("canvas"),Vt(s,"width",Lh),Vt(s,"height",Rh),Vt(s,"class","svelte-152eaku"),Vt(t,"class","container svelte-152eaku")},m(a,i){Fr(a,t,i),hr(r,t,null),Ot(t,n),Ot(t,s),e[3](s),o=!0},p(a,[i]){const c={};i&64&&(c.$$scope={dirty:i,ctx:a}),r.$set(c)},i(a){o||(cr(r.$$.fragment,a),o=!0)},o(a){dr(r.$$.fragment,a),o=!1},d(a){a&&xr(t),mr(r),e[3](null)}}}const Lh=500,Rh=500;function w3(e,t,r){let{model:n}=t,s=!1,o,a=[],i=l=>{if(!s)return;const u=En.cameras.perspective,d=Object.assign({},u.defaults);u.setProjection(d,d,{width:Lh,height:Rh}),u.update(d,d);const h={glOptions:{canvas:o},camera:d,drawCommands:{drawAxis:En.drawCommands.drawAxis,drawGrid:En.drawCommands.drawGrid,drawLines:En.drawCommands.drawLines,drawMesh:En.drawCommands.drawMesh},entities:[{visuals:{drawCmd:"drawGrid",show:!1},size:[500,500],ticks:[25,5]},{visuals:{drawCmd:"drawAxis",show:!1},size:300},...l]};En.prepareRender(h)(h)};d5(()=>{s=!0});function c(l){an[l?"unshift":"push"](()=>{o=l,r(0,o)})}return e.$$set=l=>{"model"in l&&r(1,n=l.model)},e.$$.update=()=>{e.$$.dirty&2&&r(2,a=En.entitiesFromSolids({},n)),e.$$.dirty&4&&i(a)},[o,n,a,c]}class $3 extends Dn{constructor(t){super(),kn(this,t,w3,_3,Gn,{model:1})}}function x3(e){let t,r,n,s;return{c(){t=lr("button"),r=Fn(e[1]),Vt(t,"class","svelte-ysflfc")},m(o,a){Fr(o,t,a),Ot(t,r),n||(s=dh(t,"click",e[2]),n=!0)},p(o,[a]){a&2&&hl(r,o[1])},i:Rr,o:Rr,d(o){o&&xr(t),n=!1,s()}}}function E3(e,t,r){let{onClick:n}=t,{text:s}=t;const o=()=>n();return e.$$set=a=>{"onClick"in a&&r(0,n=a.onClick),"text"in a&&r(1,s=a.text)},[n,s,o]}class A3 extends Dn{constructor(t){super(),kn(this,t,E3,x3,Gn,{onClick:0,text:1})}}function T3(e){let t,r,n,s,o,a,i,c,l;return{c(){t=lr("label"),r=Fn(e[1]),n=$r(),s=lr("span"),o=lr("input"),a=$r(),i=Fn(e[2]),Vt(o,"type","number"),Vt(o,"min","0"),Vt(o,"class","svelte-1vrbkkw"),Vt(t,"class","svelte-1vrbkkw")},m(u,d){Fr(u,t,d),Ot(t,r),Ot(t,n),Ot(t,s),Ot(s,o),f1(o,e[0]),Ot(s,a),Ot(s,i),c||(l=dh(o,"input",e[3]),c=!0)},p(u,[d]){d&2&&hl(r,u[1]),d&1&&hh(o.value)!==u[0]&&f1(o,u[0]),d&4&&hl(i,u[2])},i:Rr,o:Rr,d(u){u&&xr(t),c=!1,l()}}}function S3(e,t,r){let{value:n=0}=t,{label:s}=t,{suffix:o=""}=t;function a(){n=hh(this.value),r(0,n)}return e.$$set=i=>{"value"in i&&r(0,n=i.value),"label"in i&&r(1,s=i.label),"suffix"in i&&r(2,o=i.suffix)},[n,s,o,a]}class aa extends Dn{constructor(t){super(),kn(this,t,S3,T3,Gn,{value:0,label:1,suffix:2})}}function P3(e){let t;return{c(){t=Fn("Dimensions")},m(r,n){Fr(r,t,n)},d(r){r&&xr(t)}}}function C3(e){let t;return{c(){t=Fn("Walls")},m(r,n){Fr(r,t,n)},d(r){r&&xr(t)}}}function M3(e){let t,r,n,s,o,a,i,c,l,u,d,h,m,$,g,y,S,N,O,L,R;r=new A3({props:{text:"Download STL",onClick:e[1]}}),o=new yl({props:{$$slots:{default:[P3]},$$scope:{ctx:e}}});function F(ne){e[2](ne)}let z={label:"Inner length",suffix:"mm"};e[0].innerLength!==void 0&&(z.value=e[0].innerLength),i=new aa({props:z}),an.push(()=>ao(i,"value",F));function J(ne){e[3](ne)}let oe={label:"Inner width",suffix:"mm"};e[0].innerWidth!==void 0&&(oe.value=e[0].innerWidth),u=new aa({props:oe}),an.push(()=>ao(u,"value",J));function ve(ne){e[4](ne)}let le={label:"Inner height",suffix:"mm"};e[0].innerHeight!==void 0&&(le.value=e[0].innerHeight),m=new aa({props:le}),an.push(()=>ao(m,"value",ve)),S=new yl({props:{$$slots:{default:[C3]},$$scope:{ctx:e}}});function Pe(ne){e[5](ne)}let Xe={label:"Wall thickness",suffix:"mm"};return e[0].wallThickness!==void 0&&(Xe.value=e[0].wallThickness),O=new aa({props:Xe}),an.push(()=>ao(O,"value",Pe)),{c(){t=lr("div"),wr(r.$$.fragment),n=$r(),s=lr("div"),wr(o.$$.fragment),a=$r(),wr(i.$$.fragment),l=$r(),wr(u.$$.fragment),h=$r(),wr(m.$$.fragment),g=$r(),y=lr("div"),wr(S.$$.fragment),N=$r(),wr(O.$$.fragment),Vt(s,"class","inner-container svelte-mycl5i"),Vt(y,"class","inner-container svelte-mycl5i"),Vt(t,"class","container svelte-mycl5i")},m(ne,Ne){Fr(ne,t,Ne),hr(r,t,null),Ot(t,n),Ot(t,s),hr(o,s,null),Ot(s,a),hr(i,s,null),Ot(s,l),hr(u,s,null),Ot(s,h),hr(m,s,null),Ot(t,g),Ot(t,y),hr(S,y,null),Ot(y,N),hr(O,y,null),R=!0},p(ne,[Ne]){const Ge={};Ne&2&&(Ge.onClick=ne[1]),r.$set(Ge);const bt={};Ne&64&&(bt.$$scope={dirty:Ne,ctx:ne}),o.$set(bt);const xt={};!c&&Ne&1&&(c=!0,xt.value=ne[0].innerLength,oo(()=>c=!1)),i.$set(xt);const vr={};!d&&Ne&1&&(d=!0,vr.value=ne[0].innerWidth,oo(()=>d=!1)),u.$set(vr);const Kt={};!$&&Ne&1&&($=!0,Kt.value=ne[0].innerHeight,oo(()=>$=!1)),m.$set(Kt);const gr={};Ne&64&&(gr.$$scope={dirty:Ne,ctx:ne}),S.$set(gr);const Jt={};!L&&Ne&1&&(L=!0,Jt.value=ne[0].wallThickness,oo(()=>L=!1)),O.$set(Jt)},i(ne){R||(cr(r.$$.fragment,ne),cr(o.$$.fragment,ne),cr(i.$$.fragment,ne),cr(u.$$.fragment,ne),cr(m.$$.fragment,ne),cr(S.$$.fragment,ne),cr(O.$$.fragment,ne),R=!0)},o(ne){dr(r.$$.fragment,ne),dr(o.$$.fragment,ne),dr(i.$$.fragment,ne),dr(u.$$.fragment,ne),dr(m.$$.fragment,ne),dr(S.$$.fragment,ne),dr(O.$$.fragment,ne),R=!1},d(ne){ne&&xr(t),mr(r),mr(o),mr(i),mr(u),mr(m),mr(S),mr(O)}}}function O3(e,t,r){let{parameters:n}=t,{generate:s}=t;function o(l){e.$$.not_equal(n.innerLength,l)&&(n.innerLength=l,r(0,n))}function a(l){e.$$.not_equal(n.innerWidth,l)&&(n.innerWidth=l,r(0,n))}function i(l){e.$$.not_equal(n.innerHeight,l)&&(n.innerHeight=l,r(0,n))}function c(l){e.$$.not_equal(n.wallThickness,l)&&(n.wallThickness=l,r(0,n))}return e.$$set=l=>{"parameters"in l&&r(0,n=l.parameters),"generate"in l&&r(1,s=l.generate)},[n,s,o,a,i,c]}class L3 extends Dn{constructor(t){super(),kn(this,t,O3,M3,Gn,{parameters:0,generate:1})}}const Fh=e=>e.reduce((t,r)=>Array.isArray(r)?t.concat(Fh(r)):t.concat(r),[]);var We=Fh;const R3=e=>Object.assign({},e);var F3=R3;const N3=(e,t,r)=>(e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e[3]=t[3]+r[3],e[4]=t[4]+r[4],e[5]=t[5]+r[5],e[6]=t[6]+r[6],e[7]=t[7]+r[7],e[8]=t[8]+r[8],e[9]=t[9]+r[9],e[10]=t[10]+r[10],e[11]=t[11]+r[11],e[12]=t[12]+r[12],e[13]=t[13]+r[13],e[14]=t[14]+r[14],e[15]=t[15]+r[15],e);var G3=N3;const k3=()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];var Ol=k3;const D3=Ol,B3=e=>{const t=D3();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t};var I3=B3;const V3=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e);var Nh=V3;const z3=(e,t)=>{const r=t[0],n=t[1],s=t[2],o=t[3],a=t[4],i=t[5],c=t[6],l=t[7],u=t[8],d=t[9],h=t[10],m=t[11],$=t[12],g=t[13],y=t[14],S=t[15],N=r*i-n*a,O=r*c-s*a,L=r*l-o*a,R=n*c-s*i,F=n*l-o*i,z=s*l-o*c,J=u*g-d*$,oe=u*y-h*$,ve=u*S-m*$,le=d*y-h*g,Pe=d*S-m*g,Xe=h*S-m*y;let ne=N*Xe-O*Pe+L*le+R*ve-F*oe+z*J;return ne?(ne=1/ne,e[0]=(i*Xe-c*Pe+l*le)*ne,e[1]=(s*Pe-n*Xe-o*le)*ne,e[2]=(g*z-y*F+S*R)*ne,e[3]=(h*F-d*z-m*R)*ne,e[4]=(c*ve-a*Xe-l*oe)*ne,e[5]=(r*Xe-s*ve+o*oe)*ne,e[6]=(y*L-$*z-S*O)*ne,e[7]=(u*z-h*L+m*O)*ne,e[8]=(a*Pe-i*ve+l*J)*ne,e[9]=(n*ve-r*Pe-o*J)*ne,e[10]=($*F-g*L+S*N)*ne,e[11]=(d*L-u*F-m*N)*ne,e[12]=(i*oe-a*le-c*J)*ne,e[13]=(r*le-n*oe+s*J)*ne,e[14]=(g*O-$*R-y*N)*ne,e[15]=(u*R-d*O+h*N)*ne,e):null};var U3=z3;const q3=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15];var X3=q3;const j3=1e5,H3=1e-5,Y3=1e-13,W3=Math.PI*2;var st={EPS:H3,NEPS:Y3,TAU:W3,spatialResolution:j3};const{NEPS:Z3}=st,Gh=e=>Math.abs(e)<Z3?0:e,Q3=e=>Gh(Math.sin(e)),K3=e=>Gh(Math.cos(e));var It={sin:Q3,cos:K3};const J3=e=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e);var kh=J3;const{EPS:ew}=st,{sin:tw,cos:rw}=It,nw=kh,sw=(e,t,r)=>{let[n,s,o]=r;const a=n*n+s*s+o*o;if(Math.abs(a)<ew)return nw(e);const i=1/Math.sqrt(a);n*=i,s*=i,o*=i;const c=tw(t),l=rw(t),u=1-l;return e[0]=n*n*u+l,e[1]=s*n*u+o*c,e[2]=o*n*u-s*c,e[3]=0,e[4]=n*s*u-o*c,e[5]=s*s*u+l,e[6]=o*s*u+n*c,e[7]=0,e[8]=n*o*u+s*c,e[9]=s*o*u-n*c,e[10]=o*o*u+l,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var Dh=sw;const ow=(e,t)=>(e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e);var aw=ow;const{sin:wc,cos:$c}=It,iw=(e,t,r,n)=>{const s=wc(t),o=$c(t),a=wc(r),i=$c(r),c=wc(n),l=$c(n);return e[0]=i*o,e[1]=i*s,e[2]=-a,e[3]=0,e[4]=c*a*o-l*s,e[5]=l*o+c*a*s,e[6]=c*i,e[7]=0,e[8]=c*s+l*a*o,e[9]=l*a*s-c*o,e[10]=l*i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var cw=iw;const lw=(e,t)=>(e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e);var fw=lw;const uw=Ol,dw=(e,t,r,n,s,o,a,i,c,l,u,d,h,m,$,g)=>{const y=uw();return y[0]=e,y[1]=t,y[2]=r,y[3]=n,y[4]=s,y[5]=o,y[6]=a,y[7]=i,y[8]=c,y[9]=l,y[10]=u,y[11]=d,y[12]=h,y[13]=m,y[14]=$,y[15]=g,y};var hw=dw;const mw=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e[2]=Math.abs(t[2]),e);var Bh=mw;const pw=(e,t,r)=>(e[0]=t[0]+r[0],e[1]=t[1]+r[1],e[2]=t[2]+r[2],e);var Ih=pw;const vw=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2];var Ia=vw;const gw=Ia,yw=(e,t)=>{const r=e[0],n=e[1],s=e[2],o=t[0],a=t[1],i=t[2],c=Math.sqrt(r*r+n*n+s*s),l=Math.sqrt(o*o+a*a+i*i),u=c*l,d=u&&gw(e,t)/u;return Math.acos(Math.min(Math.max(d,-1),1))};var bw=yw;const _w=()=>[0,0,0];var Va=_w;const ww=Va,$w=e=>{const t=ww();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t};var xw=$w;const Ew=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e);var Vh=Ew;const Aw=(e,t,r)=>{const n=t[0],s=t[1],o=t[2],a=r[0],i=r[1],c=r[2];return e[0]=s*c-o*i,e[1]=o*a-n*c,e[2]=n*i-s*a,e};var bo=Aw;const Tw=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return Math.sqrt(r*r+n*n+s*s)};var zh=Tw;const Sw=(e,t,r)=>(e[0]=t[0]/r[0],e[1]=t[1]/r[1],e[2]=t[2]/r[2],e);var Pw=Sw;const Cw=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2];var Mw=Cw;const Ow=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e);var Lw=Ow;const Rw=Va,Fw=(e,t,r)=>{const n=Rw();return n[0]=e,n[1]=t,n[2]=r,n};var Nw=Fw;const Gw=(e,t,r=0)=>(e[0]=t[0],e[1]=t[1],e[2]=r,e);var kw=Gw;const Dw=e=>{const t=e[0],r=e[1],n=e[2];return Math.sqrt(t*t+r*r+n*n)};var Uh=Dw;const Bw=(e,t,r,n)=>(e[0]=t[0]+n*(r[0]-t[0]),e[1]=t[1]+n*(r[1]-t[1]),e[2]=t[2]+n*(r[2]-t[2]),e);var Iw=Bw;const Vw=(e,t,r)=>(e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e[2]=Math.max(t[2],r[2]),e);var qh=Vw;const zw=(e,t,r)=>(e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e[2]=Math.min(t[2],r[2]),e);var Xh=zw;const Uw=(e,t,r)=>(e[0]=t[0]*r[0],e[1]=t[1]*r[1],e[2]=t[2]*r[2],e);var qw=Uw;const Xw=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e);var jw=Xw;const Hw=(e,t)=>{const r=t[0],n=t[1],s=t[2];let o=r*r+n*n+s*s;return o>0&&(o=1/Math.sqrt(o)),e[0]=r*o,e[1]=n*o,e[2]=s*o,e};var Ll=Hw;const Yw=Bh,Ww=Va,Zw=bo,Qw=(e,t)=>{const r=Yw(Ww(),t),n=0+(r[0]<r[1]&&r[0]<r[2]),s=0+(r[1]<=r[0]&&r[1]<r[2]),o=0+(r[2]<=r[0]&&r[2]<=r[1]);return Zw(e,t,[n,s,o])};var Kw=Qw;const Jw=(e,t,r,n)=>{const s=[],o=[];return s[0]=t[0]-r[0],s[1]=t[1]-r[1],s[2]=t[2]-r[2],o[0]=s[0],o[1]=s[1]*Math.cos(n)-s[2]*Math.sin(n),o[2]=s[1]*Math.sin(n)+s[2]*Math.cos(n),e[0]=o[0]+r[0],e[1]=o[1]+r[1],e[2]=o[2]+r[2],e};var e$=Jw;const t$=(e,t,r,n)=>{const s=[],o=[];return s[0]=t[0]-r[0],s[1]=t[1]-r[1],s[2]=t[2]-r[2],o[0]=s[2]*Math.sin(n)+s[0]*Math.cos(n),o[1]=s[1],o[2]=s[2]*Math.cos(n)-s[0]*Math.sin(n),e[0]=o[0]+r[0],e[1]=o[1]+r[1],e[2]=o[2]+r[2],e};var r$=t$;const n$=(e,t,r,n)=>{const s=[],o=[];return s[0]=t[0]-r[0],s[1]=t[1]-r[1],o[0]=s[0]*Math.cos(n)-s[1]*Math.sin(n),o[1]=s[0]*Math.sin(n)+s[1]*Math.cos(n),e[0]=o[0]+r[0],e[1]=o[1]+r[1],e[2]=t[2],e};var s$=n$;const o$=(e,t,r)=>(e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e);var jh=o$;const a$=(e,t,r)=>(e[0]=Math.round(t[0]/r)*r+0,e[1]=Math.round(t[1]/r)*r+0,e[2]=Math.round(t[2]/r)*r+0,e);var i$=a$;const c$=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1],s=t[2]-e[2];return r*r+n*n+s*s};var Hh=c$;const l$=e=>{const t=e[0],r=e[1],n=e[2];return t*t+r*r+n*n};var Yh=l$;const f$=(e,t,r)=>(e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e);var za=f$;const u$=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)}]`;var d$=u$;const h$=(e,t,r)=>{const n=t[0],s=t[1],o=t[2];let a=r[3]*n+r[7]*s+r[11]*o+r[15];return a=a||1,e[0]=(r[0]*n+r[4]*s+r[8]*o+r[12])/a,e[1]=(r[1]*n+r[5]*s+r[9]*o+r[13])/a,e[2]=(r[2]*n+r[6]*s+r[10]*o+r[14])/a,e};var m$=h$,ze={abs:Bh,add:Ih,angle:bw,clone:xw,copy:Vh,create:Va,cross:bo,distance:zh,divide:Pw,dot:Ia,equals:Mw,fromScalar:Lw,fromValues:Nw,fromVec2:kw,length:Uh,lerp:Iw,max:qh,min:Xh,multiply:qw,negate:jw,normalize:Ll,orthogonal:Kw,rotateX:e$,rotateY:r$,rotateZ:s$,scale:jh,snap:i$,squaredDistance:Hh,squaredLength:Yh,subtract:za,toString:d$,transform:m$};const Jr=ze,p$=Dh,v$=(e,t,r)=>{const n=Jr.normalize(Jr.create(),t),s=Jr.normalize(Jr.create(),r),o=Jr.cross(Jr.create(),s,n),a=Jr.dot(s,n);if(a===-1)return p$(e,Math.PI,Jr.orthogonal(o,n));const i=1/(1+a);return e[0]=o[0]*o[0]*i+a,e[1]=o[1]*o[0]*i-o[2],e[2]=o[2]*o[0]*i+o[1],e[3]=0,e[4]=o[0]*o[1]*i+o[2],e[5]=o[1]*o[1]*i+a,e[6]=o[2]*o[1]*i-o[0],e[7]=0,e[8]=o[0]*o[2]*i-o[1],e[9]=o[1]*o[2]*i+o[0],e[10]=o[2]*o[2]*i+a,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var g$=v$;const{sin:y$,cos:b$}=It,_$=(e,t)=>{const r=y$(t),n=b$(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=n,e[6]=r,e[7]=0,e[8]=0,e[9]=-r,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var w$=_$;const{sin:$$,cos:x$}=It,E$=(e,t)=>{const r=$$(t),n=x$(t);return e[0]=n,e[1]=0,e[2]=-r,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=r,e[9]=0,e[10]=n,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var A$=E$;const{sin:T$,cos:S$}=It,P$=(e,t)=>{const r=T$(t),n=S$(t);return e[0]=n,e[1]=r,e[2]=0,e[3]=0,e[4]=-r,e[5]=n,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e};var C$=P$;const M$=e=>e[0]===1&&e[1]===0&&e[2]===0&&e[3]===0&&e[4]===0&&e[5]===1&&e[6]===0&&e[7]===0&&e[8]===0&&e[9]===0&&e[10]===1&&e[11]===0&&e[12]===0&&e[13]===0&&e[14]===0&&e[15]===1;var O$=M$;const L$=e=>Br(e[1])&&Br(e[2])&&Br(e[3])&&Br(e[4])&&Br(e[6])&&Br(e[7])&&Br(e[8])&&Br(e[9])&&Br(e[11])&&e[15]===1,Br=e=>Math.abs(e)<Number.EPSILON;var R$=L$;const F$=e=>{const t=e[4]*e[9]-e[8]*e[5],r=e[8]*e[1]-e[0]*e[9],n=e[0]*e[5]-e[4]*e[1];return t*e[2]+r*e[6]+n*e[10]<0};var N$=F$;const G$=(e,t)=>{const[r,n,s,o]=t;return e[0]=1-2*r*r,e[1]=-2*n*r,e[2]=-2*s*r,e[3]=0,e[4]=-2*r*n,e[5]=1-2*n*n,e[6]=-2*s*n,e[7]=0,e[8]=-2*r*s,e[9]=-2*n*s,e[10]=1-2*s*s,e[11]=0,e[12]=2*r*o,e[13]=2*n*o,e[14]=2*s*o,e[15]=1,e};var k$=G$;const D$=(e,t,r)=>{const n=t[0],s=t[1],o=t[2],a=t[3],i=t[4],c=t[5],l=t[6],u=t[7],d=t[8],h=t[9],m=t[10],$=t[11],g=t[12],y=t[13],S=t[14],N=t[15];let O=r[0],L=r[1],R=r[2],F=r[3];return e[0]=O*n+L*i+R*d+F*g,e[1]=O*s+L*c+R*h+F*y,e[2]=O*o+L*l+R*m+F*S,e[3]=O*a+L*u+R*$+F*N,O=r[4],L=r[5],R=r[6],F=r[7],e[4]=O*n+L*i+R*d+F*g,e[5]=O*s+L*c+R*h+F*y,e[6]=O*o+L*l+R*m+F*S,e[7]=O*a+L*u+R*$+F*N,O=r[8],L=r[9],R=r[10],F=r[11],e[8]=O*n+L*i+R*d+F*g,e[9]=O*s+L*c+R*h+F*y,e[10]=O*o+L*l+R*m+F*S,e[11]=O*a+L*u+R*$+F*N,O=r[12],L=r[13],R=r[14],F=r[15],e[12]=O*n+L*i+R*d+F*g,e[13]=O*s+L*c+R*h+F*y,e[14]=O*o+L*l+R*m+F*S,e[15]=O*a+L*u+R*$+F*N,e};var B$=D$;const{EPS:I$}=st,{sin:V$,cos:z$}=It,U$=Nh,q$=(e,t,r,n)=>{let[s,o,a]=n;const i=s*s+o*o+a*a;if(Math.abs(i)<I$)return U$(e,t);const c=1/Math.sqrt(i);s*=c,o*=c,a*=c;const l=V$(r),u=z$(r),d=1-u,h=t[0],m=t[1],$=t[2],g=t[3],y=t[4],S=t[5],N=t[6],O=t[7],L=t[8],R=t[9],F=t[10],z=t[11],J=s*s*d+u,oe=o*s*d+a*l,ve=a*s*d-o*l,le=s*o*d-a*l,Pe=o*o*d+u,Xe=a*o*d+s*l,ne=s*a*d+o*l,Ne=o*a*d-s*l,Ge=a*a*d+u;return e[0]=h*J+y*oe+L*ve,e[1]=m*J+S*oe+R*ve,e[2]=$*J+N*oe+F*ve,e[3]=g*J+O*oe+z*ve,e[4]=h*le+y*Pe+L*Xe,e[5]=m*le+S*Pe+R*Xe,e[6]=$*le+N*Pe+F*Xe,e[7]=g*le+O*Pe+z*Xe,e[8]=h*ne+y*Ne+L*Ge,e[9]=m*ne+S*Ne+R*Ge,e[10]=$*ne+N*Ne+F*Ge,e[11]=g*ne+O*Ne+z*Ge,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e};var X$=q$;const{sin:j$,cos:H$}=It,Y$=(e,t,r)=>{const n=j$(r),s=H$(r),o=t[4],a=t[5],i=t[6],c=t[7],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=o*s+l*n,e[5]=a*s+u*n,e[6]=i*s+d*n,e[7]=c*s+h*n,e[8]=l*s-o*n,e[9]=u*s-a*n,e[10]=d*s-i*n,e[11]=h*s-c*n,e};var W$=Y$;const{sin:Z$,cos:Q$}=It,K$=(e,t,r)=>{const n=Z$(r),s=Q$(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[8],u=t[9],d=t[10],h=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s-l*n,e[1]=a*s-u*n,e[2]=i*s-d*n,e[3]=c*s-h*n,e[8]=o*n+l*s,e[9]=a*n+u*s,e[10]=i*n+d*s,e[11]=c*n+h*s,e};var J$=K$;const{sin:ex,cos:tx}=It,rx=(e,t,r)=>{const n=ex(r),s=tx(r),o=t[0],a=t[1],i=t[2],c=t[3],l=t[4],u=t[5],d=t[6],h=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=o*s+l*n,e[1]=a*s+u*n,e[2]=i*s+d*n,e[3]=c*s+h*n,e[4]=l*s-o*n,e[5]=u*s-a*n,e[6]=d*s-i*n,e[7]=h*s-c*n,e};var nx=rx;const sx=(e,t,r)=>{const n=r[0],s=r[1],o=r[2];return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*s,e[5]=t[5]*s,e[6]=t[6]*s,e[7]=t[7]*s,e[8]=t[8]*o,e[9]=t[9]*o,e[10]=t[10]*o,e[11]=t[11]*o,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e};var ox=sx;const ax=(e,t,r)=>(e[0]=t[0]-r[0],e[1]=t[1]-r[1],e[2]=t[2]-r[2],e[3]=t[3]-r[3],e[4]=t[4]-r[4],e[5]=t[5]-r[5],e[6]=t[6]-r[6],e[7]=t[7]-r[7],e[8]=t[8]-r[8],e[9]=t[9]-r[9],e[10]=t[10]-r[10],e[11]=t[11]-r[11],e[12]=t[12]-r[12],e[13]=t[13]-r[13],e[14]=t[14]-r[14],e[15]=t[15]-r[15],e);var ix=ax;const cx=e=>e.map(t=>t.toFixed(7)).toString();var lx=cx;const fx=(e,t,r)=>{const n=r[0],s=r[1],o=r[2];let a,i,c,l,u,d,h,m,$,g,y,S;return t===e?(e[12]=t[0]*n+t[4]*s+t[8]*o+t[12],e[13]=t[1]*n+t[5]*s+t[9]*o+t[13],e[14]=t[2]*n+t[6]*s+t[10]*o+t[14],e[15]=t[3]*n+t[7]*s+t[11]*o+t[15]):(a=t[0],i=t[1],c=t[2],l=t[3],u=t[4],d=t[5],h=t[6],m=t[7],$=t[8],g=t[9],y=t[10],S=t[11],e[0]=a,e[1]=i,e[2]=c,e[3]=l,e[4]=u,e[5]=d,e[6]=h,e[7]=m,e[8]=$,e[9]=g,e[10]=y,e[11]=S,e[12]=a*n+u*s+$*o+t[12],e[13]=i*n+d*s+g*o+t[13],e[14]=c*n+h*s+y*o+t[14],e[15]=l*n+m*s+S*o+t[15]),e};var ux=fx,ft={add:G3,clone:I3,copy:Nh,create:Ol,invert:U3,equals:X3,fromRotation:Dh,fromScaling:aw,fromTaitBryanRotation:cw,fromTranslation:fw,fromValues:hw,fromVectorRotation:g$,fromXRotation:w$,fromYRotation:A$,fromZRotation:C$,identity:kh,isIdentity:O$,isOnlyTransformScale:R$,isMirroring:N$,mirrorByPlane:k$,multiply:B$,rotate:X$,rotateX:W$,rotateY:J$,rotateZ:nx,scale:ox,subtract:ix,toString:lx,translate:ux};const dx=ft,hx=e=>(e===void 0&&(e=[]),{sides:e,transforms:dx.create()});var Ua=hx;const mx=(e,t)=>(e[0]=Math.abs(t[0]),e[1]=Math.abs(t[1]),e);var px=mx;const vx=(e,t,r)=>(e[0]=t[0]+r[0],e[1]=t[1]+r[1],e);var gx=vx;const yx=e=>Math.atan2(e[1],e[0]);var Rl=yx,bx=Rl;const _x=Rl,wx=e=>_x(e)*57.29577951308232;var $x=wx;const xx=()=>[0,0];var qa=xx;const Ex=qa,Ax=e=>{const t=Ex();return t[0]=e[0],t[1]=e[1],t};var Tx=Ax;const Sx=(e,t)=>(e[0]=t[0],e[1]=t[1],e);var Px=Sx;const Cx=(e,t,r)=>(e[0]=0,e[1]=0,e[2]=t[0]*r[1]-t[1]*r[0],e);var Mx=Cx;const Ox=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1];return Math.sqrt(r*r+n*n)};var Lx=Ox;const Rx=(e,t,r)=>(e[0]=t[0]/r[0],e[1]=t[1]/r[1],e);var Fx=Rx;const Nx=(e,t)=>e[0]*t[0]+e[1]*t[1];var Gx=Nx;const kx=(e,t)=>e[0]===t[0]&&e[1]===t[1];var Dx=kx;const{sin:Bx,cos:Ix}=It,Vx=(e,t)=>(e[0]=Ix(t),e[1]=Bx(t),e);var Wh=Vx;const zx=Wh,Ux=(e,t)=>zx(e,t*.017453292519943295);var qx=Ux;const Xx=(e,t)=>(e[0]=t,e[1]=t,e);var jx=Xx;const Hx=qa,Yx=(e,t)=>{const r=Hx();return r[0]=e,r[1]=t,r};var Wx=Yx;const Zx=e=>Math.sqrt(e[0]*e[0]+e[1]*e[1]);var Qx=Zx;const Kx=(e,t,r,n)=>{const s=t[0],o=t[1];return e[0]=s+n*(r[0]-s),e[1]=o+n*(r[1]-o),e};var Jx=Kx;const eE=(e,t,r)=>(e[0]=Math.max(t[0],r[0]),e[1]=Math.max(t[1],r[1]),e);var tE=eE;const rE=(e,t,r)=>(e[0]=Math.min(t[0],r[0]),e[1]=Math.min(t[1],r[1]),e);var nE=rE;const sE=(e,t,r)=>(e[0]=t[0]*r[0],e[1]=t[1]*r[1],e);var oE=sE;const aE=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e);var iE=aE;const cE=(e,t,r,n)=>{const s=t[0]-r[0],o=t[1]-r[1],a=Math.cos(n),i=Math.sin(n);return e[0]=s*a-o*i+r[0],e[1]=s*i+o*a+r[1],e};var Zh=cE;const{TAU:lE}=st,fE=qa,uE=Zh,dE=(e,t)=>uE(e,t,fE(),lE/4);var hE=dE;const mE=(e,t)=>{const r=t[0],n=t[1];let s=r*r+n*n;return s>0&&(s=1/Math.sqrt(s)),e[0]=r*s,e[1]=n*s,e};var pE=mE;const vE=(e,t,r)=>(e[0]=t[0]*r,e[1]=t[1]*r,e);var gE=vE;const yE=(e,t,r)=>(e[0]=Math.round(t[0]/r)*r+0,e[1]=Math.round(t[1]/r)*r+0,e);var bE=yE;const _E=(e,t)=>{const r=t[0]-e[0],n=t[1]-e[1];return r*r+n*n};var wE=_E;const $E=e=>{const t=e[0],r=e[1];return t*t+r*r};var xE=$E;const EE=(e,t,r)=>(e[0]=t[0]-r[0],e[1]=t[1]-r[1],e);var AE=EE;const TE=e=>`[${e[0].toFixed(7)}, ${e[1].toFixed(7)}]`;var SE=TE;const PE=(e,t,r)=>{const n=t[0],s=t[1];return e[0]=r[0]*n+r[4]*s+r[12],e[1]=r[1]*n+r[5]*s+r[13],e};var CE=PE,rt={abs:px,add:gx,angle:bx,angleDegrees:$x,angleRadians:Rl,clone:Tx,copy:Px,create:qa,cross:Mx,distance:Lx,divide:Fx,dot:Gx,equals:Dx,fromAngleDegrees:qx,fromAngleRadians:Wh,fromScalar:jx,fromValues:Wx,length:Qx,lerp:Jx,max:tE,min:nE,multiply:oE,negate:iE,normal:hE,normalize:pE,rotate:Zh,scale:gE,snap:bE,squaredDistance:wE,squaredLength:xE,subtract:AE,toString:SE,transform:CE};const xc=rt,ME=Ua,OE=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");let t=e.length;if(t<3)throw new Error("the given points must define a closed geometry with three or more points");xc.equals(e[0],e[t-1])&&--t;const r=[];let n=e[t-1];for(let s=0;s<t;s++){const o=e[s];r.push([xc.clone(n),xc.clone(o)]),n=o}return ME(r)};var LE=OE;const RE=ft,M1=rt,FE=Ua,NE=e=>{if(e[0]!==0)throw new Error("invalid compact binary data");const t=FE();t.transforms=RE.clone(e.slice(1,17));for(let r=21;r<e.length;r+=4){const n=M1.fromValues(e[r+0],e[r+1]),s=M1.fromValues(e[r+2],e[r+3]);t.sides.push([n,s])}return e[17]>=0&&(t.color=[e[17],e[18],e[19],e[20]]),t};var GE=NE;const kE=e=>!!(e&&typeof e=="object"&&"sides"in e&&"transforms"in e&&Array.isArray(e.sides)&&"length"in e.transforms);var Qh=kE;const O1=ft,ia=rt,DE=e=>(O1.isIdentity(e.transforms)||(e.sides=e.sides.map(t=>{const r=ia.transform(ia.create(),t[0],e.transforms),n=ia.transform(ia.create(),t[1],e.transforms);return[r,n]}),e.transforms=O1.create()),e);var BE=DE;const IE=BE,VE=e=>IE(e).sides;var _o=VE;const zE=Ua,UE=_o,qE=e=>{const r=UE(e).map(n=>[n[1],n[0]]);return r.reverse(),zE(r)};var XE=qE;const js=rt,jE=_o,HE=e=>{const t=new Map,r=n=>{const s=n.toString();return t.has(s)?t.get(s):(t.set(s,n),n)};return e.map(n=>n.map(r))},YE=e=>{const t=new Map;return HE(e).forEach(n=>{t.has(n[0])?t.get(n[0]).push(n):t.set(n[0],[n])}),t},WE=e=>{const t=YE(jE(e)),r=[];for(;;){let n;for(const[a,i]of t){if(n=i.shift(),!n){t.delete(a);continue}break}if(n===void 0)break;const s=[],o=n[0];for(;;){s.push(n[0]);const a=n[1];if(a===o)break;const i=t.get(a);if(!i)throw new Error(`geometry is not closed at vertex ${a}`);const c=ZE(n,i);i.length===0&&t.delete(a),n=c}s.length>0&&s.push(s.shift()),r.push(s)}return t.clear(),r},ZE=(e,t)=>{if(t.length===1)return t.pop();const r=js.create(),n=js.angleDegrees(js.subtract(r,e[1],e[0]));let s,o;t.forEach((i,c)=>{let u=js.angleDegrees(js.subtract(r,i[1],i[0]))-n;u<-180&&(u+=360),u>=180&&(u-=360),(o===void 0||u>s)&&(o=c,s=u)});const a=t[o];return t.splice(o,1),a};var Kh=WE;const QE=_o,KE=e=>{const r=QE(e).map(n=>n[0]);return r.length>0&&r.push(r.shift()),r};var JE=KE;const L1=rt,eA=_o,tA=e=>{const t=eA(e);let r="geom2 ("+t.length+` sides):
[
`;return t.forEach(n=>{r+="  ["+L1.toString(n[0])+", "+L1.toString(n[1])+`]
`}),r+=`]
`,r};var rA=tA;const nA=e=>{const t=e.sides,r=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const s=new Float32Array(1+16+4+t.length*4);s[0]=0,s[1]=r[0],s[2]=r[1],s[3]=r[2],s[4]=r[3],s[5]=r[4],s[6]=r[5],s[7]=r[6],s[8]=r[7],s[9]=r[8],s[10]=r[9],s[11]=r[10],s[12]=r[11],s[13]=r[12],s[14]=r[13],s[15]=r[14],s[16]=r[15],s[17]=n[0],s[18]=n[1],s[19]=n[2],s[20]=n[3];for(let o=0;o<t.length;o++){const a=o*4+21,i=t[o][0],c=t[o][1];s[a+0]=i[0],s[a+1]=i[1],s[a+2]=c[0],s[a+3]=c[1]}return s};var sA=nA;const R1=ft,oA=(e,t)=>{const r=R1.multiply(R1.create(),e,t.transforms);return Object.assign({},t,{transforms:r})};var aA=oA;const iA=rt,cA=Qh,lA=Kh,fA=e=>{if(!cA(e))throw new Error("invalid geom2 structure");if(lA(e),e.sides.forEach(t=>{if(iA.equals(t[0],t[1]))throw new Error(`geom2 self-edge ${t[0]}`)}),!e.transforms.every(Number.isFinite))throw new Error(`geom2 invalid transforms ${e.transforms}`)};var uA=fA,Qe={clone:F3,create:Ua,fromPoints:LE,fromCompactBinary:GE,isA:Qh,reverse:XE,toOutlines:Kh,toPoints:JE,toSides:_o,toString:rA,toCompactBinary:sA,transform:aA,validate:uA};const dA=e=>Object.assign({},e);var hA=dA;const mA=ft,pA=e=>(e===void 0&&(e=[]),{polygons:e,transforms:mA.create()});var Xa=pA;const vA=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e});var xs=vA;const gA=xs,yA=ze,bA=(...e)=>{let t,r;return e.length===1?(t=gA(),r=e[0]):(t=e[0],r=e[1]),t.vertices=r.vertices.map(n=>yA.clone(n)),t};var _A=bA;const wA=ze,$A=xs,xA=e=>{const t=e.map(r=>wA.clone(r));return $A(t)};var EA=xA;const AA=xs,TA=(e,t)=>{const r=AA(e);return r.plane=t,r};var SA=TA;const PA=()=>[0,0,0,0];var ja=PA;const CA=ja,MA=e=>{const t=CA();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t};var Jh=MA;const OA=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e);var em=OA;const LA=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3];var tm=LA;const RA=(e,t)=>(e[0]=-t[0],e[1]=-t[1],e[2]=-t[2],e[3]=-t[3],e);var rm=RA;const Ec=ze,FA=(e,t,r)=>{const n=Ec.normalize(Ec.create(),t),s=Ec.dot(r,n);return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=s,e};var NA=FA;const GA=ja,kA=(e,t,r,n)=>{const s=GA();return s[0]=e,s[1]=t,s[2]=r,s[3]=n,s};var nm=kA;const Pr=ze,DA=(e,...t)=>{const r=t.length,n=Pr.create(),s=Pr.create(),o=a=>{const i=t[a],c=t[(a+1)%r],l=t[(a+2)%r];return Pr.subtract(n,c,i),Pr.subtract(s,l,i),Pr.cross(n,n,s),Pr.normalize(n,n),n};return e[0]=0,e[1]=0,e[2]=0,r===3?Pr.copy(e,o(0)):(t.forEach((a,i)=>{Pr.add(e,e,o(i))}),Pr.normalize(e,e)),e[3]=Pr.dot(e,t[0]),e};var sm=DA;const{EPS:Ac}=st,Ut=ze,BA=(e,t,r,n)=>{let s=Ut.subtract(Ut.create(),r,t),o=Ut.subtract(Ut.create(),n,t);Ut.length(s)<Ac&&(s=Ut.orthogonal(s,o)),Ut.length(o)<Ac&&(o=Ut.orthogonal(o,s));let a=Ut.cross(Ut.create(),s,o);Ut.length(a)<Ac&&(o=Ut.orthogonal(o,s),a=Ut.cross(a,s,o)),a=Ut.normalize(a,a);const i=Ut.dot(a,t);return e[0]=a[0],e[1]=a[1],e[2]=a[2],e[3]=i,e};var IA=BA;const VA=ze,zA=(e,t)=>{const r=t[0]*e[0]+t[1]*e[1]+t[2]*e[2]-e[3],n=t[0]-r*e[0],s=t[1]-r*e[1],o=t[2]-r*e[2];return VA.fromValues(n,s,o)};var UA=zA;const qA=ze,XA=(e,t)=>qA.dot(e,t)-e[3];var om=XA;const jA=e=>`(${e[0].toFixed(9)}, ${e[1].toFixed(9)}, ${e[2].toFixed(9)}, ${e[3].toFixed(9)})`;var am=jA;const HA=ft,qt=ze,YA=sm,WA=rm,ZA=(e,t,r)=>{const n=HA.isMirroring(r),s=qt.orthogonal(qt.create(),t),o=qt.cross(s,t,s),a=qt.cross(qt.create(),t,o);let i=qt.fromScalar(qt.create(),t[3]);qt.multiply(i,i,t);let c=qt.add(qt.create(),i,o),l=qt.add(qt.create(),i,a);return i=qt.transform(i,i,r),c=qt.transform(c,c,r),l=qt.transform(l,l,r),YA(e,i,c,l),n&&WA(e,e),e};var QA=ZA,Nr={clone:Jh,copy:em,create:ja,equals:tm,flip:rm,fromNormalAndPoint:NA,fromValues:nm,fromPoints:sm,fromPointsRandom:IA,projectionOfPoint:UA,signedDistanceToPoint:om,toString:am,transform:QA};const F1=Nr,KA=xs,JA=e=>{const t=e.vertices.slice().reverse(),r=KA(t);return e.plane&&(r.plane=F1.flip(F1.create(),e.plane)),r};var eT=JA;const tT=e=>!!(e&&typeof e=="object"&&"vertices"in e&&Array.isArray(e.vertices));var im=tT;const N1=Nr,An=ze,rT=e=>nT(e.vertices),nT=e=>{const t=e.length;if(t>2){const r=N1.fromPoints(N1.create(),...e);let n=e[t-2],s=e[t-1];for(let o=0;o<t;o++){const a=e[o];if(!sT(n,s,a,r))return!1;n=s,s=a}}return!0},sT=(e,t,r,n)=>{const s=An.cross(An.create(),An.subtract(An.create(),t,e),An.subtract(An.create(),r,t));return An.dot(s,n)>=0};var cm=rT;const G1=Nr,oT=e=>(e.plane||(e.plane=G1.fromPoints(G1.create(),...e.vertices)),e.plane);var Fl=oT;const aT=Fl,iT=e=>{const t=e.vertices.length;if(t<3)return 0;const r=e.vertices,n=aT(e),s=Math.abs(n[0]),o=Math.abs(n[1]),a=Math.abs(n[2]);if(s+o+a===0)return 0;let i=3;s>o&&s>a?i=1:o>a&&(i=2);let c=0,l=0,u=1,d=2;switch(i){case 1:for(u=1;u<t;u++)l=u-1,d=(u+1)%t,c+=r[u][1]*(r[d][2]-r[l][2]);c+=r[0][1]*(r[1][2]-r[t-1][2]),c/=2*n[0];break;case 2:for(u=1;u<t;u++)l=u-1,d=(u+1)%t,c+=r[u][2]*(r[d][0]-r[l][0]);c+=r[0][2]*(r[1][0]-r[t-1][0]),c/=2*n[1];break;case 3:default:for(u=1;u<t;u++)l=u-1,d=(u+1)%t,c+=r[u][0]*(r[d][1]-r[l][1]);c+=r[0][0]*(r[1][1]-r[t-1][1]),c/=2*n[2];break}return c};var lm=iT;const Hs=ze,cT=e=>{const t=e.vertices,r=t.length,n=r===0?Hs.create():Hs.clone(t[0]),s=Hs.clone(n);for(let o=1;o<r;o++)Hs.min(n,n,t[o]),Hs.max(s,s,t[o]);return[n,s]};var lT=cT;const fT=(e,t)=>e[0]*t[0]+e[1]*t[1]+e[2]*t[2]+e[3]*t[3];var uT=fT;const dT=(e,t)=>(e[0]=t,e[1]=t,e[2]=t,e[3]=t,e);var hT=dT;const mT=(e,t,r)=>{const[n,s,o,a]=t;return e[0]=r[0]*n+r[4]*s+r[8]*o+r[12]*a,e[1]=r[1]*n+r[5]*s+r[9]*o+r[13]*a,e[2]=r[2]*n+r[6]*s+r[10]*o+r[14]*a,e[3]=r[3]*n+r[7]*s+r[11]*o+r[15]*a,e};var pT=mT,fm={clone:Jh,copy:em,create:ja,dot:uT,equals:tm,fromScalar:hT,fromValues:nm,toString:am,transform:pT};const vT=fm,k1=new WeakMap,gT=e=>{const t=k1.get(e);if(t)return t;const r=e.vertices,n=vT.create();if(r.length===0)return n[0]=0,n[1]=0,n[2]=0,n[3]=0,n;let s=r[0],o=s,a=s,i=s,c=s,l=s;r.forEach(m=>{s[0]>m[0]&&(s=m),o[1]>m[1]&&(o=m),a[2]>m[2]&&(a=m),i[0]<m[0]&&(i=m),c[1]<m[1]&&(c=m),l[2]<m[2]&&(l=m)}),n[0]=(s[0]+i[0])*.5,n[1]=(o[1]+c[1])*.5,n[2]=(a[2]+l[2])*.5;const u=n[0]-i[0],d=n[1]-c[1],h=n[2]-l[2];return n[3]=Math.sqrt(u*u+d*d+h*h),k1.set(e,n),n};var yT=gT;const Tc=ze,bT=e=>{let t=0;const r=e.vertices,n=Tc.create();for(let s=0;s<r.length-2;s++)Tc.cross(n,r[s+1],r[s+2]),t+=Tc.dot(r[0],n);return t/=6,t};var _T=bT;const wT=e=>e.vertices;var $T=wT;const xT=ze,ET=e=>{let t="poly3: vertices: [";return e.vertices.forEach(r=>{t+=`${xT.toString(r)}, `}),t+="]",t};var AT=ET;const TT=ft,D1=ze,ST=xs,PT=(e,t)=>{const r=t.vertices.map(n=>D1.transform(D1.create(),n,e));return TT.isMirroring(e)&&r.reverse(),ST(r)};var CT=PT;const MT=om,{NEPS:OT}=st,LT=ze,RT=im,FT=cm,NT=lm,GT=Fl,kT=e=>{if(!RT(e))throw new Error("invalid poly3 structure");if(e.vertices.length<3)throw new Error(`poly3 not enough vertices ${e.vertices.length}`);if(NT(e)<=0)throw new Error("poly3 area must be greater than zero");for(let t=0;t<e.vertices.length;t++)if(LT.equals(e.vertices[t],e.vertices[(t+1)%e.vertices.length]))throw new Error(`poly3 duplicate vertex ${e.vertices[t]}`);if(!FT(e))throw new Error("poly3 must be convex");if(e.vertices.forEach(t=>{if(!t.every(Number.isFinite))throw new Error(`poly3 invalid vertex ${t}`)}),e.vertices.length>3){const t=GT(e);e.vertices.forEach(r=>{const n=Math.abs(MT(t,r));if(n>OT)throw new Error(`poly3 must be coplanar: vertex ${r} distance ${n}`)})}};var DT=kT,ot={clone:_A,create:xs,fromPoints:EA,fromPointsAndPlane:SA,invert:eT,isA:im,isConvex:cm,measureArea:lm,measureBoundingBox:lT,measureBoundingSphere:yT,measureSignedVolume:_T,plane:Fl,toPoints:$T,toString:AT,transform:CT,validate:DT};const BT=ot,IT=Xa,VT=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");const t=e.map((n,s)=>BT.create(n));return IT(t)};var zT=VT;const UT=ze,qT=ft,XT=ot,jT=Xa,HT=e=>{if(e[0]!==1)throw new Error("invalid compact binary data");const t=jT();t.transforms=qT.clone(e.slice(1,17));const r=e[21];let n=22,s=e.length-r*3;for(;s<e.length;){const o=e[n];n++;const a=[];for(let i=0;i<o;i++)a.push(UT.fromValues(e[s],e[s+1],e[s+2])),s+=3;t.polygons.push(XT.create(a))}return e[17]>=0&&(t.color=[e[17],e[18],e[19],e[20]]),t};var YT=HT;const B1=ft,WT=ot,ZT=e=>(B1.isIdentity(e.transforms)||(e.polygons=e.polygons.map(t=>WT.transform(e.transforms,t)),e.transforms=B1.create()),e);var QT=ZT;const KT=QT,JT=e=>KT(e).polygons;var Ha=JT;const e4=ot,t4=Xa,r4=Ha,n4=e=>{const r=r4(e).map(n=>e4.invert(n));return t4(r)};var s4=n4;const o4=e=>!!(e&&typeof e=="object"&&"polygons"in e&&"transforms"in e&&Array.isArray(e.polygons)&&"length"in e.transforms);var um=o4;const a4=ot,i4=Ha,c4=e=>i4(e).map(n=>a4.toPoints(n));var l4=c4;const f4=ot,u4=Ha,d4=e=>{const t=u4(e);let r="geom3 ("+t.length+` polygons):
`;return t.forEach(n=>{r+="  "+f4.toString(n)+`
`}),r};var h4=d4;const m4=ot,p4=e=>{const t=e.polygons,r=e.transforms,n=t.length,s=t.reduce((l,u)=>l+u.vertices.length,0);let o=[-1,-1,-1,-1];e.color&&(o=e.color);const a=new Float32Array(1+16+4+1+n+s*3);a[0]=1,a[1]=r[0],a[2]=r[1],a[3]=r[2],a[4]=r[3],a[5]=r[4],a[6]=r[5],a[7]=r[6],a[8]=r[7],a[9]=r[8],a[10]=r[9],a[11]=r[10],a[12]=r[11],a[13]=r[12],a[14]=r[13],a[15]=r[14],a[16]=r[15],a[17]=o[0],a[18]=o[1],a[19]=o[2],a[20]=o[3],a[21]=s;let i=22,c=i+n;return t.forEach(l=>{const u=m4.toPoints(l);a[i]=u.length,i++;for(let d=0;d<u.length;d++){const h=u[d];a[c+0]=h[0],a[c+1]=h[1],a[c+2]=h[2],c+=3}}),a};var v4=p4;const I1=ft,g4=(e,t)=>{const r=I1.multiply(I1.create(),e,t.transforms);return Object.assign({},t,{transforms:r})};var y4=g4;const b4=ot,_4=um,w4=e=>{if(!_4(e))throw new Error("invalid geom3 structure");if(e.polygons.forEach(b4.validate),$4(e),!e.transforms.every(Number.isFinite))throw new Error(`geom3 invalid transforms ${e.transforms}`)},$4=e=>{const t=new Map;e.polygons.forEach(({vertices:n})=>{n.forEach((s,o)=>{const a=`${s}`,i=`${n[(o+1)%n.length]}`,c=`${a}/${i}`,l=t.has(c)?t.get(c):0;t.set(c,l+1)})});const r=[];if(t.forEach((n,s)=>{const o=s.split("/").reverse().join("/"),a=t.get(o);n!==a&&r.push(s.replace("/"," -> "))}),r.length>0)throw new Error(`non-manifold edges ${r.length}
${r.join(`
`)}`)};var x4=w4,Ke={clone:hA,create:Xa,fromPoints:zT,fromCompactBinary:YT,invert:s4,isA:um,toPoints:l4,toPolygons:Ha,toString:h4,toCompactBinary:v4,transform:y4,validate:x4};const E4=e=>Object.assign({},e);var Nl=E4;const{EPS:V1}=st,A4=rt,T4=Nl,S4=e=>{if(e.isClosed)return e;const t=T4(e);if(t.isClosed=!0,t.points.length>1){const r=t.points,n=r[0];let s=r[r.length-1];for(;A4.distance(n,s)<V1*V1&&(r.pop(),r.length!==1);)s=r[r.length-1]}return t};var dm=S4;const P4=ft,C4=e=>(e===void 0&&(e=[]),{points:e,isClosed:!1,transforms:P4.create()});var Ya=C4;const{EPS:z1}=st,U1=rt,M4=dm,O4=Ya,L4=(e,t)=>{const r={closed:!1};let{closed:n}=Object.assign({},r,e),s=O4();if(s.points=t.map(o=>U1.clone(o)),s.points.length>1){const o=s.points[0],a=s.points[s.points.length-1];U1.distance(o,a)<z1*z1&&(n=!0)}return n===!0&&(s=M4(s)),s};var Gl=L4;const q1=ft,X1=rt,R4=e=>(q1.isIdentity(e.transforms)||(e.points=e.points.map(t=>X1.transform(X1.create(),t,e.transforms)),e.transforms=q1.create()),e);var F4=R4;const N4=F4,G4=e=>N4(e).points;var Es=G4;const{TAU:ca}=st,Ct=rt,k4=Gl,D4=Es,B4=(e,t)=>{const r={radius:[0,0],xaxisrotation:0,clockwise:!1,large:!1,segments:16};let{endpoint:n,radius:s,xaxisrotation:o,clockwise:a,large:i,segments:c}=Object.assign({},r,e);if(!Array.isArray(n))throw new Error("endpoint must be an array of X and Y values");if(n.length<2)throw new Error("endpoint must contain X and Y values");if(n=Ct.clone(n),!Array.isArray(s))throw new Error("radius must be an array of X and Y values");if(s.length<2)throw new Error("radius must contain X and Y values");if(c<4)throw new Error("segments must be four or more");const l=1e5;if(t.isClosed)throw new Error("the given path cannot be closed");const u=D4(t);if(u.length<1)throw new Error("the given path must contain one or more points (as the starting point for the arc)");let d=s[0],h=s[1];const m=u[u.length-1];d=Math.round(d*l)/l,h=Math.round(h*l)/l,n=Ct.fromValues(Math.round(n[0]*l)/l,Math.round(n[1]*l)/l);const $=!a;let g=[];if(d===0||h===0)g.push(n);else{d=Math.abs(d),h=Math.abs(h);const S=o,N=Math.cos(S),O=Math.sin(S),L=Ct.subtract(Ct.create(),m,n);Ct.scale(L,L,.5);const R=Math.round((N*L[0]+O*L[1])*l)/l,F=Math.round((-O*L[0]+N*L[1])*l)/l,z=Ct.fromValues(R,F),J=z[0]*z[0]/(d*d)+z[1]*z[1]/(h*h);if(J>1){const xt=Math.sqrt(J);d*=xt,h*=xt,d=Math.round(d*l)/l,h=Math.round(h*l)/l}let oe=Math.sqrt((d*d*h*h-d*d*z[1]*z[1]-h*h*z[0]*z[0])/(d*d*z[1]*z[1]+h*h*z[0]*z[0]));$===i&&(oe=-oe);const ve=Ct.fromValues(d*z[1]/h,-h*z[0]/d);Ct.scale(ve,ve,oe);let le=Ct.fromValues(N*ve[0]-O*ve[1],O*ve[0]+N*ve[1]);le=Ct.add(le,le,Ct.scale(Ct.create(),Ct.add(Ct.create(),m,n),.5));const Pe=Ct.fromValues((z[0]-ve[0])/d,(z[1]-ve[1])/h),Xe=Ct.fromValues((-z[0]-ve[0])/d,(-z[1]-ve[1])/h),ne=Ct.angleRadians(Pe);let Ge=Ct.angleRadians(Xe)-ne;Ge=Ge%ca,!$&&Ge>0?Ge-=ca:$&&Ge<0&&(Ge+=ca);let bt=Math.ceil(Math.abs(Ge)/ca*c)+1;bt<1&&(bt=1);for(let xt=1;xt<bt;xt++){const vr=ne+xt/bt*Ge,Kt=Math.cos(vr),gr=Math.sin(vr),Jt=Ct.fromValues(N*d*Kt-O*h*gr,O*d*Kt+N*h*gr);Ct.add(Jt,Jt,le),g.push(Jt)}bt&&g.push(e.endpoint)}return g=u.concat(g),k4({},g)};var I4=B4;const V4=Gl,z4=Es,{equals:U4}=rt,q4=(...e)=>{let t=!1,r=[];return e.forEach((n,s)=>{const o=z4(n).slice();if(r.length>0&&o.length>0&&U4(o[0],r[r.length-1])&&o.shift(),o.length>0&&t)throw new Error(`Cannot concatenate to a closed path; check the ${s}th path`);t=n.isClosed,r=r.concat(o)}),V4({closed:t},r)};var hm=q4;const X4=hm,j4=Ya,H4=(e,t)=>X4(t,j4(e));var mm=H4;const{TAU:Y4}=st,ar=rt,W4=rt,Z4=mm,Q4=Es,K4=(e,t)=>{const r={segments:16};let{controlPoints:n,segments:s}=Object.assign({},r,e);if(!Array.isArray(n))throw new Error("controlPoints must be an array of one or more points");if(n.length<1)throw new Error("controlPoints must be an array of one or more points");if(s<4)throw new Error("segments must be four or more");if(t.isClosed)throw new Error("the given geometry cannot be closed");const o=Q4(t);if(o.length<1)throw new Error("the given path must contain one or more points (as the starting point for the bezier curve)");if(n=n.slice(),n[0]===null){if(n.length<2)throw new Error("a null control point must be passed with one more control points");let F=o[o.length-2];if("lastBezierControlPoint"in t&&(F=t.lastBezierControlPoint),!Array.isArray(F))throw new Error("the given path must contain TWO or more points if given a null control point");const z=ar.scale(ar.create(),o[o.length-1],2);ar.subtract(z,z,F),n[0]=z}n.unshift(o[o.length-1]);const i=n.length-1,c=[];let l=1;for(let F=0;F<=i;++F)F>0&&(l*=F),c.push(l);const u=[];for(let F=0;F<=i;++F){const z=c[i]/(c[F]*c[i-F]);u.push(z)}const d=ar.create(),h=ar.create(),m=W4.create(),$=F=>{let z=1,J=Math.pow(1-F,i);const oe=F!==1?1/(1-F):1,ve=ar.create();for(let le=0;le<=i;++le){le===i&&(J=1);const Pe=u[le]*z*J,Xe=ar.scale(d,n[le],Pe);ar.add(ve,ve,Xe),z*=F,J*=oe}return ve},g=[],y=[],S=i+1;for(let F=0;F<S;++F){const z=F/(S-1),J=$(z);g.push(J),y.push(z)}let N=1;const O=Y4/s,L=Math.sin(O);for(;N<g.length-1;){const F=ar.subtract(d,g[N],g[N-1]);ar.normalize(F,F);const z=ar.subtract(h,g[N+1],g[N]);ar.normalize(z,z);const J=ar.cross(m,F,z);if(Math.abs(J[2])>L){const oe=y[N-1],ve=y[N+1],le=oe+(ve-oe)*1/3,Pe=oe+(ve-oe)*2/3,Xe=$(le),ne=$(Pe);g.splice(N,1,Xe,ne),y.splice(N,1,le,Pe),N--,N<1&&(N=1)}else++N}g.shift();const R=Z4(g,t);return R.lastBezierControlPoint=n[n.length-2],R};var J4=K4;const eS=rt,j1=Es,tS=(e,t)=>{if(e.isClosed!==t.isClosed||e.points.length!==t.points.length)return!1;const r=j1(e),n=j1(t),s=r.length;let o=0;do{let a=!1;for(let i=0;i<s;i++)if(!eS.equals(r[i],n[(i+o)%s])){a=!0;break}if(a===!1)return!0;if(!e.isClosed)return!1}while(++o<s);return!1};var rS=tS;const nS=ft,sS=rt,oS=Ya,aS=e=>{if(e[0]!==2)throw new Error("invalid compact binary data");const t=oS();t.transforms=nS.clone(e.slice(1,17)),t.isClosed=!!e[17];for(let r=22;r<e.length;r+=2){const n=sS.fromValues(e[r],e[r+1]);t.points.push(n)}return e[18]>=0&&(t.color=[e[18],e[19],e[20],e[21]]),t};var iS=aS;const cS=e=>!!(e&&typeof e=="object"&&"points"in e&&"transforms"in e&&"isClosed"in e&&Array.isArray(e.points)&&"length"in e.transforms);var pm=cS;const lS=Nl,fS=e=>{const t=lS(e);return t.points=e.points.slice().reverse(),t};var uS=fS;const dS=rt,hS=Es,mS=e=>{const t=hS(e);let r="path ("+t.length+" points, "+e.isClosed+`):
[
`;return t.forEach(n=>{r+="  "+dS.toString(n)+`,
`}),r+=`]
`,r};var pS=mS;const vS=e=>{const t=e.points,r=e.transforms;let n=[-1,-1,-1,-1];e.color&&(n=e.color);const s=new Float32Array(1+16+1+4+t.length*2);s[0]=2,s[1]=r[0],s[2]=r[1],s[3]=r[2],s[4]=r[3],s[5]=r[4],s[6]=r[5],s[7]=r[6],s[8]=r[7],s[9]=r[8],s[10]=r[9],s[11]=r[10],s[12]=r[11],s[13]=r[12],s[14]=r[13],s[15]=r[14],s[16]=r[15],s[17]=e.isClosed?1:0,s[18]=n[0],s[19]=n[1],s[20]=n[2],s[21]=n[3];for(let o=0;o<t.length;o++){const a=o*2+22,i=t[o];s[a]=i[0],s[a+1]=i[1]}return s};var gS=vS;const H1=ft,yS=(e,t)=>{const r=H1.multiply(H1.create(),e,t.transforms);return Object.assign({},t,{transforms:r})};var bS=yS;const _S=rt,wS=pm,$S=e=>{if(!wS(e))throw new Error("invalid path2 structure");if(e.points.length>1){for(let t=0;t<e.points.length;t++)if(_S.equals(e.points[t],e.points[(t+1)%e.points.length]))throw new Error(`path2 duplicate points ${e.points[t]}`)}if(e.points.forEach(t=>{if(!t.every(Number.isFinite))throw new Error(`path2 invalid point ${t}`)}),!e.transforms.every(Number.isFinite))throw new Error(`path2 invalid transforms ${e.transforms}`)};var xS=$S,ct={appendArc:I4,appendBezier:J4,appendPoints:mm,clone:Nl,close:dm,concat:hm,create:Ya,equals:rS,fromPoints:Gl,fromCompactBinary:iS,isA:pm,reverse:uS,toPoints:Es,toString:pS,toCompactBinary:gS,transform:bS,validate:xS};const ES=We,vm=Qe,gm=Ke,ym=ct,bm=ot,AS=(e,t)=>{const r=vm.clone(t);return r.color=e,r},TS=(e,t)=>{const r=gm.clone(t);return r.color=e,r},SS=(e,t)=>{const r=ym.clone(t);return r.color=e,r},PS=(e,t)=>{const r=bm.clone(t);return r.color=e,r},CS=(e,...t)=>{if(!Array.isArray(e))throw new Error("color must be an array");if(e.length<3)throw new Error("color must contain R, G and B values");if(e.length===3&&(e=[e[0],e[1],e[2],1]),t=ES(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>vm.isA(n)?AS(e,n):gm.isA(n)?TS(e,n):ym.isA(n)?SS(e,n):bm.isA(n)?PS(e,n):(n.color=e,n));return r.length===1?r[0]:r};var MS=CS;const OS={black:[0/255,0/255,0/255],silver:[192/255,192/255,192/255],gray:[128/255,128/255,128/255],white:[255/255,255/255,255/255],maroon:[128/255,0/255,0/255],red:[255/255,0/255,0/255],purple:[128/255,0/255,128/255],fuchsia:[255/255,0/255,255/255],green:[0/255,128/255,0/255],lime:[0/255,255/255,0/255],olive:[128/255,128/255,0/255],yellow:[255/255,255/255,0/255],navy:[0/255,0/255,128/255],blue:[0/255,0/255,255/255],teal:[0/255,128/255,128/255],aqua:[0/255,255/255,255/255],aliceblue:[240/255,248/255,255/255],antiquewhite:[250/255,235/255,215/255],aquamarine:[127/255,255/255,212/255],azure:[240/255,255/255,255/255],beige:[245/255,245/255,220/255],bisque:[255/255,228/255,196/255],blanchedalmond:[255/255,235/255,205/255],blueviolet:[138/255,43/255,226/255],brown:[165/255,42/255,42/255],burlywood:[222/255,184/255,135/255],cadetblue:[95/255,158/255,160/255],chartreuse:[127/255,255/255,0/255],chocolate:[210/255,105/255,30/255],coral:[255/255,127/255,80/255],cornflowerblue:[100/255,149/255,237/255],cornsilk:[255/255,248/255,220/255],crimson:[220/255,20/255,60/255],cyan:[0/255,255/255,255/255],darkblue:[0/255,0/255,139/255],darkcyan:[0/255,139/255,139/255],darkgoldenrod:[184/255,134/255,11/255],darkgray:[169/255,169/255,169/255],darkgreen:[0/255,100/255,0/255],darkgrey:[169/255,169/255,169/255],darkkhaki:[189/255,183/255,107/255],darkmagenta:[139/255,0/255,139/255],darkolivegreen:[85/255,107/255,47/255],darkorange:[255/255,140/255,0/255],darkorchid:[153/255,50/255,204/255],darkred:[139/255,0/255,0/255],darksalmon:[233/255,150/255,122/255],darkseagreen:[143/255,188/255,143/255],darkslateblue:[72/255,61/255,139/255],darkslategray:[47/255,79/255,79/255],darkslategrey:[47/255,79/255,79/255],darkturquoise:[0/255,206/255,209/255],darkviolet:[148/255,0/255,211/255],deeppink:[255/255,20/255,147/255],deepskyblue:[0/255,191/255,255/255],dimgray:[105/255,105/255,105/255],dimgrey:[105/255,105/255,105/255],dodgerblue:[30/255,144/255,255/255],firebrick:[178/255,34/255,34/255],floralwhite:[255/255,250/255,240/255],forestgreen:[34/255,139/255,34/255],gainsboro:[220/255,220/255,220/255],ghostwhite:[248/255,248/255,255/255],gold:[255/255,215/255,0/255],goldenrod:[218/255,165/255,32/255],greenyellow:[173/255,255/255,47/255],grey:[128/255,128/255,128/255],honeydew:[240/255,255/255,240/255],hotpink:[255/255,105/255,180/255],indianred:[205/255,92/255,92/255],indigo:[75/255,0/255,130/255],ivory:[255/255,255/255,240/255],khaki:[240/255,230/255,140/255],lavender:[230/255,230/255,250/255],lavenderblush:[255/255,240/255,245/255],lawngreen:[124/255,252/255,0/255],lemonchiffon:[255/255,250/255,205/255],lightblue:[173/255,216/255,230/255],lightcoral:[240/255,128/255,128/255],lightcyan:[224/255,255/255,255/255],lightgoldenrodyellow:[250/255,250/255,210/255],lightgray:[211/255,211/255,211/255],lightgreen:[144/255,238/255,144/255],lightgrey:[211/255,211/255,211/255],lightpink:[255/255,182/255,193/255],lightsalmon:[255/255,160/255,122/255],lightseagreen:[32/255,178/255,170/255],lightskyblue:[135/255,206/255,250/255],lightslategray:[119/255,136/255,153/255],lightslategrey:[119/255,136/255,153/255],lightsteelblue:[176/255,196/255,222/255],lightyellow:[255/255,255/255,224/255],limegreen:[50/255,205/255,50/255],linen:[250/255,240/255,230/255],magenta:[255/255,0/255,255/255],mediumaquamarine:[102/255,205/255,170/255],mediumblue:[0/255,0/255,205/255],mediumorchid:[186/255,85/255,211/255],mediumpurple:[147/255,112/255,219/255],mediumseagreen:[60/255,179/255,113/255],mediumslateblue:[123/255,104/255,238/255],mediumspringgreen:[0/255,250/255,154/255],mediumturquoise:[72/255,209/255,204/255],mediumvioletred:[199/255,21/255,133/255],midnightblue:[25/255,25/255,112/255],mintcream:[245/255,255/255,250/255],mistyrose:[255/255,228/255,225/255],moccasin:[255/255,228/255,181/255],navajowhite:[255/255,222/255,173/255],oldlace:[253/255,245/255,230/255],olivedrab:[107/255,142/255,35/255],orange:[255/255,165/255,0/255],orangered:[255/255,69/255,0/255],orchid:[218/255,112/255,214/255],palegoldenrod:[238/255,232/255,170/255],palegreen:[152/255,251/255,152/255],paleturquoise:[175/255,238/255,238/255],palevioletred:[219/255,112/255,147/255],papayawhip:[255/255,239/255,213/255],peachpuff:[255/255,218/255,185/255],peru:[205/255,133/255,63/255],pink:[255/255,192/255,203/255],plum:[221/255,160/255,221/255],powderblue:[176/255,224/255,230/255],rosybrown:[188/255,143/255,143/255],royalblue:[65/255,105/255,225/255],saddlebrown:[139/255,69/255,19/255],salmon:[250/255,128/255,114/255],sandybrown:[244/255,164/255,96/255],seagreen:[46/255,139/255,87/255],seashell:[255/255,245/255,238/255],sienna:[160/255,82/255,45/255],skyblue:[135/255,206/255,235/255],slateblue:[106/255,90/255,205/255],slategray:[112/255,128/255,144/255],slategrey:[112/255,128/255,144/255],snow:[255/255,250/255,250/255],springgreen:[0/255,255/255,127/255],steelblue:[70/255,130/255,180/255],tan:[210/255,180/255,140/255],thistle:[216/255,191/255,216/255],tomato:[255/255,99/255,71/255],turquoise:[64/255,224/255,208/255],violet:[238/255,130/255,238/255],wheat:[245/255,222/255,179/255],whitesmoke:[245/255,245/255,245/255],yellowgreen:[154/255,205/255,50/255]};var _m=OS;const LS=_m,RS=e=>LS[e.toLowerCase()];var FS=RS;const NS=e=>{if(e=e.replace("#",""),e.length<6)throw new Error("the given notation must contain 3 or more hex values");const t=parseInt(e.substring(0,2),16)/255,r=parseInt(e.substring(2,4),16)/255,n=parseInt(e.substring(4,6),16)/255;if(e.length>=8){const s=parseInt(e.substring(6,8),16)/255;return[t,r,n,s]}return[t,r,n]};var GS=NS;const kS=(e,t,r)=>(r<0&&(r+=1),r>1&&(r-=1),r<1/6?e+(t-e)*6*r:r<1/2?t:r<2/3?e+(t-e)*(2/3-r)*6:e);var wm=kS;const DS=We,Sc=wm,BS=(...e)=>{if(e=DS(e),e.length<3)throw new Error("values must contain H, S and L values");const t=e[0],r=e[1],n=e[2];let s=n,o=n,a=n;if(r!==0){const i=n<.5?n*(1+r):n+r-n*r,c=2*n-i;s=Sc(c,i,t+1/3),o=Sc(c,i,t),a=Sc(c,i,t-1/3)}if(e.length>3){const i=e[3];return[s,o,a,i]}return[s,o,a]};var IS=BS;const VS=We,zS=(...e)=>{if(e=VS(e),e.length<3)throw new Error("values must contain H, S and V values");const t=e[0],r=e[1],n=e[2];let s=0,o=0,a=0;const i=Math.floor(t*6),c=t*6-i,l=n*(1-r),u=n*(1-c*r),d=n*(1-(1-c)*r);switch(i%6){case 0:s=n,o=d,a=l;break;case 1:s=u,o=n,a=l;break;case 2:s=l,o=n,a=d;break;case 3:s=l,o=u,a=n;break;case 4:s=d,o=l,a=n;break;case 5:s=n,o=l,a=u;break}if(e.length>3){const h=e[3];return[s,o,a,h]}return[s,o,a]};var US=zS;const qS=We,XS=(...e)=>{if(e=qS(e),e.length<3)throw new Error("values must contain R, G and B values");const t=e[0]*255,r=e[1]*255,n=e[2]*255;let s=`#${Number(16777216+t*65536+r*256+n).toString(16).substring(1,7)}`;return e.length>3&&(s=s+Number(e[3]*255).toString(16)),s};var jS=XS;const HS=We,YS=(...e)=>{if(e=HS(e),e.length<3)throw new Error("values must contain R, G and B values");const t=e[0],r=e[1],n=e[2],s=Math.max(t,r,n),o=Math.min(t,r,n);let a,i;const c=(s+o)/2;if(s===o)a=i=0;else{const l=s-o;switch(i=c>.5?l/(2-s-o):l/(s+o),s){case t:a=(r-n)/l+(r<n?6:0);break;case r:a=(n-t)/l+2;break;case n:a=(t-r)/l+4;break}a/=6}if(e.length>3){const l=e[3];return[a,i,c,l]}return[a,i,c]};var WS=YS;const ZS=We,QS=(...e)=>{if(e=ZS(e),e.length<3)throw new Error("values must contain R, G and B values");const t=e[0],r=e[1],n=e[2],s=Math.max(t,r,n),o=Math.min(t,r,n);let a;const i=s,c=s-o,l=s===0?0:c/s;if(s===o)a=0;else{switch(s){case t:a=(r-n)/c+(r<n?6:0);break;case r:a=(n-t)/c+2;break;case n:a=(t-r)/c+4;break}a/=6}if(e.length>3){const u=e[3];return[a,l,i,u]}return[a,l,i]};var KS=QS,JS={colorize:MS,colorNameToRgb:FS,cssColors:_m,hexToRgb:GS,hslToRgb:IS,hsvToRgb:US,hueToColorComponent:wm,rgbToHex:jS,rgbToHsl:WS,rgbToHsv:KS};const eP=e=>{if(!Array.isArray(e))throw new Error("Bezier points must be a valid array/");if(e.length<2)throw new Error("Bezier points must contain at least 2 values.");const t=tP(e);return{points:e,pointType:t,dimensions:t==="float_single"?0:e[0].length,permutations:Y1(e.length-1),tangentPermutations:Y1(e.length-2)}},tP=function(e){let t=null;return e.forEach(r=>{let n="";if(Number.isFinite(r))n="float_single";else if(Array.isArray(r))r.forEach(s=>{if(!Number.isFinite(s))throw new Error("Bezier point values must all be numbers.")}),n="float_"+r.length;else throw new Error("Bezier points must all be numbers or arrays of number.");if(t==null)t=n;else if(t!==n)throw new Error("Bezier points must be either all numbers or all arrays of numbers of the same size.")}),t},Y1=function(e){const t=[];for(let r=0;r<=e;r++)t.push(Pc(e)/(Pc(r)*Pc(e-r)));return t},Pc=function(e){let t=1;for(let r=2;r<=e;r++)t*=r;return t};var rP=eP;const nP=(e,t)=>{if(e<0||e>1)throw new Error("Bezier valueAt() input must be between 0 and 1");if(t.pointType==="float_single")return W1(t,t.points,e);{const r=[];for(let n=0;n<t.dimensions;n++){const s=[];for(let o=0;o<t.points.length;o++)s.push(t.points[o][n]);r.push(W1(t,s,e))}return r}},W1=function(e,t,r){const n=t.length-1;let s=0;for(let o=0;o<=n;o++)s+=e.permutations[o]*Math.pow(1-r,n-o)*Math.pow(r,o)*t[o];return s};var $m=nP;const sP=(e,t)=>{if(e<0||e>1)throw new Error("Bezier tangentAt() input must be between 0 and 1");if(t.pointType==="float_single")return Z1(t,t.points,e);{const r=[];for(let n=0;n<t.dimensions;n++){const s=[];for(let o=0;o<t.points.length;o++)s.push(t.points[o][n]);r.push(Z1(t,s,e))}return r}},Z1=function(e,t,r){const n=t.length-1;let s=0;for(let o=0;o<n;o++){const a=n*(t[o+1]-t[o]);s+=e.tangentPermutations[o]*Math.pow(1-r,n-1-o)*Math.pow(r,o)*a}return s};var oP=sP;const Q1=$m,aP=(e,t)=>{let r=0;const n=[0];let s=Q1(0,t);for(let o=1;o<=e;o++){const a=Q1(o/e,t);r+=iP(a,s),n.push(r),s=a}return n},iP=(e,t)=>{if(Number.isFinite(e)&&Number.isFinite(t))return Math.abs(e-t);if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)throw new Error("The operands must have the same number of dimensions.");let r=0;for(let n=0;n<e.length;n++)r+=(t[n]-e[n])*(t[n]-e[n]);return Math.sqrt(r)}else throw new Error("The operands must be of the same type, either number or array.")};var kl=aP;const cP=kl,lP=(e,t)=>cP(e,t)[e];var fP=lP;const uP=kl,dP=(e,t)=>{const r={distance:0,segments:100},{distance:n,segments:s}=Object.assign({},r,e),o=uP(s,t);let a=0,i=s;for(;a<=i;){const m=Math.floor(a+(i-a)/2),$=o[m]-n;if($<0)a=m+1;else if($>0)i=m-1;else{i=m;break}}const c=i;if(o[c]===n)return c/s;const l=o[c],d=o[c+1]-l,h=(n-l)/d;return(c+h)/s};var hP=dP,mP={create:rP,valueAt:$m,tangentAt:oP,lengths:kl,length:fP,arcLengthToT:hP},pP={bezier:mP};const vP=e=>{let t=0;for(let r=0;r<e.length;r++){const n=(r+1)%e.length;t+=e[r][0]*e[n][1],t-=e[n][0]*e[r][1]}return t/2};var Wa=vP;const gP=Wa,yP=e=>gP(e.vertices);var xm=yP;const bP=e=>((e===void 0||e.length<3)&&(e=[]),{vertices:e});var Em=bP;const _P=Em,wP=e=>{const t=e.vertices.slice().reverse();return _P(t)};var Am=wP;const $P=xm,xP=Am,EP=(e,t)=>{if(e.length===0)return 0;const r=t.vertices;return r.length<3?0:($P(t)<0&&(t=xP(t)),e.reduce((s,o)=>s+AP(o,r),0)===e.length?1:0)},AP=(e,t)=>{const r=t.length,n=e[0],s=e[1];let o=t[r-1],a=t[0],i=o[1]>s,c=0,l=0;for(let u=r+1;--u;){const d=a[1]>s;if(i!==d){const h=o[0]>n,m=a[0]>n;(h&&m||a[0]-(a[1]-s)*(o[0]-a[0])/(o[1]-a[1])>=n)&&(c=!c)}i=d,o=a,a=t[++l]}return c};var TP=EP,Dl={arePointsInside:TP,create:Em,flip:Am,measureArea:xm},Bl={geom2:Qe,geom3:Ke,path2:ct,poly2:Dl,poly3:ot};const SP=()=>[0,1,0];var Il=SP;const PP=Il,CP=e=>{const t=PP();return t[0]=e[0],t[1]=e[1],t[2]=e[2],t};var MP=CP;const Cc=rt,OP=e=>{const t=Cc.normal(Cc.create(),e);return Cc.negate(t,t),t};var Vl=OP;const K1=rt,LP=e=>K1.scale(K1.create(),e,e[2]);var Za=LP;const Ys=rt,RP=Vl,FP=Za,NP=(e,t)=>{const r=FP(e),n=RP(e),s=Ys.subtract(Ys.create(),t,r),o=Ys.dot(s,n);return Ys.scale(s,n,o),Ys.add(s,s,r),s};var GP=NP;const kP=(e,t)=>(e[0]=t[0],e[1]=t[1],e[2]=t[2],e);var Tm=kP;const DP=rt,BP=(e,t)=>{let r=DP.dot(t,e);return r=Math.abs(r-e[2]),r};var IP=BP;const VP=(e,t)=>e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2];var zP=VP;const Ws=rt,UP=(e,t,r)=>{const n=Ws.subtract(Ws.create(),r,t);Ws.normal(n,n),Ws.normalize(n,n);const s=Ws.dot(t,n);return e[0]=n[0],e[1]=n[1],e[2]=s,e};var Sm=UP;const qP=Il,XP=(e,t,r)=>{const n=qP();return n[0]=e,n[1]=t,n[2]=r,n};var Pm=XP;const{NEPS:Mc}=st,jP=(e,t)=>Math.abs(e[0]-t[0])<=Mc&&Math.abs(e[1]-t[1])<=Mc&&Math.abs(e[2]-t[2])<=Mc;var zl=jP;const HP=(e,t,r)=>{let n=r-e[1],s=t[1]-e[1];s<0&&(n=-n,s=-s);let o;return n<=0?o=0:n>=s?o=1:s<1e-10?o=.5:o=n/s,e[0]+o*(t[0]-e[0])};var Cm=HP;const YP=(e,t,r,n)=>{if(e[0]===t[0]&&e[1]===t[1]||r[0]===n[0]&&r[1]===n[1])return;const s=(n[1]-r[1])*(t[0]-e[0])-(n[0]-r[0])*(t[1]-e[1]);if(Math.abs(s)<Number.MIN_VALUE)return;const o=((n[0]-r[0])*(e[1]-r[1])-(n[1]-r[1])*(e[0]-r[0]))/s,a=((t[0]-e[0])*(e[1]-r[1])-(t[1]-e[1])*(e[0]-r[0]))/s;if(o<0||o>1||a<0||a>1)return;const i=e[0]+o*(t[0]-e[0]),c=e[1]+o*(t[1]-e[1]);return[i,c]};var Mm=YP;const WP=(e,t,r,n,s,o)=>{const i=1/(e*n-t*r);let c=s*n-t*o,l=-s*r+e*o;return c*=i,l*=i,[c,l]};var ZP=WP,wo={aboutEqualNormals:zl,area:Wa,cos:It.cos,interpolateBetween2DPointsForY:Cm,intersect:Mm,sin:It.sin,solve2Linear:ZP};const QP=rt,{solve2Linear:KP}=wo,JP=(e,t)=>{const r=KP(e[0],e[1],t[0],t[1],e[2],t[2]);return QP.clone(r)};var eC=JP;const J1=rt,tC=Tm,rC=Pm,nC=(e,t)=>{const r=J1.negate(J1.create(),t),n=-t[2];return tC(e,rC(r[0],r[1],n))};var sC=nC;const oC=e=>`line2: (${e[0].toFixed(7)}, ${e[1].toFixed(7)}, ${e[2].toFixed(7)})`;var aC=oC;const e0=rt,iC=Sm,cC=Za,lC=Vl,fC=(e,t,r)=>{const n=cC(t),s=lC(t);return e0.transform(n,n,r),e0.transform(s,s,r),iC(e,n,s)};var uC=fC;const dC=Za,hC=(e,t)=>{let r=(e[2]-e[1]*t)/e[0];return Number.isNaN(r)&&(r=dC(e)[0]),r};var mC=hC,Ul={clone:MP,closestPoint:GP,copy:Tm,create:Il,direction:Vl,distanceToPoint:IP,equals:zP,fromPoints:Sm,fromValues:Pm,intersectPointOfLines:eC,origin:Za,reverse:sC,toString:aC,transform:uC,xAtY:mC};const t0=ze,pC=()=>[t0.fromValues(0,0,0),t0.fromValues(0,0,1)];var Om=pC;const r0=ze,vC=Om,gC=e=>{const t=vC();return r0.copy(t[0],e[0]),r0.copy(t[1],e[1]),t};var yC=gC;const Tn=ze,bC=(e,t)=>{const r=e[0],n=e[1],s=Tn.dot(Tn.subtract(Tn.create(),t,r),n),o=Tn.dot(n,n),a=s/o,i=Tn.scale(Tn.create(),n,a);return Tn.add(i,i,r),i};var Lm=bC;const n0=ze,_C=(e,t)=>(n0.copy(e[0],t[0]),n0.copy(e[1],t[1]),e);var wC=_C;const $C=e=>e[1];var xC=$C;const Oc=ze,EC=Lm,AC=(e,t)=>{const r=EC(e,t),n=Oc.subtract(Oc.create(),t,r);return Oc.length(n)};var TC=AC;const s0=ze,SC=(e,t)=>!(!s0.equals(e[1],t[1])||!s0.equals(e[0],t[0]));var PC=SC;const la=ze,CC=(e,t,r)=>{const n=la.normalize(la.create(),r);return la.copy(e[0],t),la.copy(e[1],n),e};var $o=CC;const Sn=ze,{solve2Linear:Lc}=wo,{EPS:MC}=st,OC=$o,LC=(e,t,r)=>{let n=Sn.cross(Sn.create(),t,r),s=Sn.length(n);if(s<MC)throw new Error("parallel planes do not intersect");s=1/s,n=Sn.scale(n,n,s);const o=Math.abs(n[0]),a=Math.abs(n[1]),i=Math.abs(n[2]);let c,l;return o>=a&&o>=i?(l=Lc(t[1],t[2],r[1],r[2],t[3],r[3]),c=Sn.fromValues(0,l[0],l[1])):a>=o&&a>=i?(l=Lc(t[0],t[2],r[0],r[2],t[3],r[3]),c=Sn.fromValues(l[0],0,l[1])):(l=Lc(t[0],t[1],r[0],r[1],t[3],r[3]),c=Sn.fromValues(l[0],l[1],0)),OC(e,c,n)};var RC=LC;const o0=ze,FC=$o,NC=(e,t,r)=>{const n=o0.subtract(o0.create(),r,t);return FC(e,t,n)};var GC=NC;const ss=ze,kC=(e,t)=>{const r=t,n=t[3],s=e[0],o=e[1],a=(n-ss.dot(r,s))/ss.dot(r,o);return ss.add(ss.create(),s,ss.scale(ss.create(),o,a))};var DC=kC;const BC=e=>e[0];var IC=BC;const Rc=ze,VC=$o,zC=(e,t)=>{const r=Rc.clone(t[0]),n=Rc.negate(Rc.create(),t[1]);return VC(e,r,n)};var UC=zC;const qC=e=>{const t=e[0],r=e[1];return`line3: point: (${t[0].toFixed(7)}, ${t[1].toFixed(7)}, ${t[2].toFixed(7)}) direction: (${r[0].toFixed(7)}, ${r[1].toFixed(7)}, ${r[2].toFixed(7)})`};var XC=qC;const os=ze,jC=$o,HC=(e,t,r)=>{const n=t[0],s=t[1],o=os.add(os.create(),n,s),a=os.transform(os.create(),n,r),i=os.transform(o,o,r),c=os.subtract(i,i,a);return jC(e,a,c)};var YC=HC,WC={clone:yC,closestPoint:Lm,copy:wC,create:Om,direction:xC,distanceToPoint:TC,equals:PC,fromPlanes:RC,fromPointAndDirection:$o,fromPoints:GC,intersectPointOfLineAndPlane:DC,origin:IC,reverse:UC,toString:XC,transform:YC},ZC={constants:st,line2:Ul,line3:WC,mat4:ft,plane:Nr,utils:wo,vec2:rt,vec3:ze,vec4:fm};const QC=We,Rm=Qe,Fm=Ke,KC=ct,JC=ot,Ra=new WeakMap,e8=()=>0,t8=e=>{let t=Ra.get(e);return t||(t=Rm.toSides(e).reduce((n,s)=>n+(s[0][0]*s[1][1]-s[0][1]*s[1][0]),0),t*=.5,Ra.set(e,t),t)},r8=e=>{let t=Ra.get(e);return t||(t=Fm.toPolygons(e).reduce((n,s)=>n+JC.measureArea(s),0),Ra.set(e,t),t)},n8=(...e)=>{if(e=QC(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>KC.isA(r)?e8():Rm.isA(r)?t8(r):Fm.isA(r)?r8(r):0);return t.length===1?t[0]:t};var Nm=n8;const s8=We,o8=Nm,a8=(...e)=>{if(e=s8(e),e.length===0)throw new Error("measureAggregateArea: no geometries supplied");const t=o8(e);if(e.length===1)return t;const r=0;return t.reduce((n,s)=>n+s,r)};var i8=a8;const c8=We,Lr=rt,Zs=ze,Gm=Qe,km=Ke,Dm=ct,a0=ot,bs=new WeakMap,l8=e=>{let t=bs.get(e);if(t)return t;const r=Dm.toPoints(e);let n;r.length===0?n=Lr.create():n=Lr.clone(r[0]);let s=Lr.clone(n);return r.forEach(o=>{Lr.min(n,n,o),Lr.max(s,s,o)}),n=[n[0],n[1],0],s=[s[0],s[1],0],t=[n,s],bs.set(e,t),t},f8=e=>{let t=bs.get(e);if(t)return t;const r=Gm.toPoints(e);let n;r.length===0?n=Lr.create():n=Lr.clone(r[0]);let s=Lr.clone(n);return r.forEach(o=>{Lr.min(n,n,o),Lr.max(s,s,o)}),n=[n[0],n[1],0],s=[s[0],s[1],0],t=[n,s],bs.set(e,t),t},u8=e=>{let t=bs.get(e);if(t)return t;const r=km.toPolygons(e);let n=Zs.create();if(r.length>0){const o=a0.toPoints(r[0]);Zs.copy(n,o[0])}let s=Zs.clone(n);return r.forEach(o=>{a0.toPoints(o).forEach(a=>{Zs.min(n,n,a),Zs.max(s,s,a)})}),n=[n[0],n[1],n[2]],s=[s[0],s[1],s[2]],t=[n,s],bs.set(e,t),t},d8=(...e)=>{if(e=c8(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>Dm.isA(r)?l8(r):Gm.isA(r)?f8(r):km.isA(r)?u8(r):[[0,0,0],[0,0,0]]);return t.length===1?t[0]:t};var Bn=d8;const h8=We,m8=Xh,p8=qh,v8=Bn,g8=(...e)=>{if(e=h8(e),e.length===0)throw new Error("measureAggregateBoundingBox: no geometries supplied");const t=v8(e);if(e.length===1)return t;const r=[[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]];return t.reduce((n,s)=>(n=[m8(n[0],n[0],s[0]),p8(n[1],n[1],s[1])],n),r)};var ql=g8;const{EPS:y8}=st,b8=(e,t)=>{let r=0;for(let n=0;n<t;n++)r+=e[1][n]-e[0][n];return y8*r/t};var Bm=b8;const _8=We,w8=ql,$8=Bm,{geom2:x8,geom3:E8,path2:A8}=Bl,T8=(...e)=>{if(e=_8(e),e.length===0)throw new Error("measureAggregateEpsilon: no geometries supplied");const t=w8(e);let r=0;return r=e.reduce((n,s)=>A8.isA(s)||x8.isA(s)?Math.max(n,2):E8.isA(s)?Math.max(n,3):0,r),$8(t,r)};var S8=T8;const P8=We,C8=Qe,Im=Ke,M8=ct,O8=ot,i0=new WeakMap,L8=()=>0,R8=()=>0,F8=e=>{let t=i0.get(e);return t||(t=Im.toPolygons(e).reduce((n,s)=>n+O8.measureSignedVolume(s),0),i0.set(e,t),t)},N8=(...e)=>{if(e=P8(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>M8.isA(r)?L8():C8.isA(r)?R8():Im.isA(r)?F8(r):0);return t.length===1?t[0]:t};var Vm=N8;const G8=We,k8=Vm,D8=(...e)=>{if(e=G8(e),e.length===0)throw new Error("measureAggregateVolume: no geometries supplied");const t=k8(e);if(e.length===1)return t;const r=0;return t.reduce((n,s)=>n+s,r)};var B8=D8;const I8=We,zm=rt,Zt=ze,Um=Qe,qm=Ke,Xm=ct,c0=ot,_s=new WeakMap,V8=e=>{let t=_s.get(e);if(t!==void 0)return t;const r=Zt.create();let n=0;const s=Xm.toPoints(e);if(s.length>0){let o=0;const a=Zt.create();s.forEach(i=>{Zt.add(r,r,Zt.fromVec2(a,i,0)),o++}),Zt.scale(r,r,1/o),s.forEach(i=>{n=Math.max(n,zm.squaredDistance(r,i))}),n=Math.sqrt(n)}return t=[r,n],_s.set(e,t),t},z8=e=>{let t=_s.get(e);if(t!==void 0)return t;const r=Zt.create();let n=0;const s=Um.toSides(e);if(s.length>0){let o=0;const a=Zt.create();s.forEach(i=>{Zt.add(r,r,Zt.fromVec2(a,i[0],0)),o++}),Zt.scale(r,r,1/o),s.forEach(i=>{n=Math.max(n,zm.squaredDistance(r,i[0]))}),n=Math.sqrt(n)}return t=[r,n],_s.set(e,t),t},U8=e=>{let t=_s.get(e);if(t!==void 0)return t;const r=Zt.create();let n=0;const s=qm.toPolygons(e);if(s.length>0){let o=0;s.forEach(a=>{c0.toPoints(a).forEach(i=>{Zt.add(r,r,i),o++})}),Zt.scale(r,r,1/o),s.forEach(a=>{c0.toPoints(a).forEach(i=>{n=Math.max(n,Zt.squaredDistance(r,i))})}),n=Math.sqrt(n)}return t=[r,n],_s.set(e,t),t},q8=(...e)=>{e=I8(e);const t=e.map(r=>Xm.isA(r)?V8(r):Um.isA(r)?z8(r):qm.isA(r)?U8(r):[[0,0,0],0]);return t.length===1?t[0]:t};var X8=q8;const j8=We,H8=Bn,Y8=(...e)=>{e=j8(e);const t=e.map(r=>{const n=H8(r);return[n[0][0]+(n[1][0]-n[0][0])/2,n[0][1]+(n[1][1]-n[0][1])/2,n[0][2]+(n[1][2]-n[0][2])/2]});return t.length===1?t[0]:t};var W8=Y8;const Z8=We,Or=ze,jm=Qe,Hm=Ke,Fa=new WeakMap,Q8=e=>{let t=Fa.get(e);if(t!==void 0)return t;const r=jm.toSides(e);let n=0,s=0,o=0;if(r.length>0){for(let i=0;i<r.length;i++){const c=r[i][0],l=r[i][1],u=c[0]*l[1]-c[1]*l[0];n+=u,s+=(c[0]+l[0])*u,o+=(c[1]+l[1])*u}n/=2;const a=1/(n*6);s*=a,o*=a}return t=Or.fromValues(s,o,0),Fa.set(e,t),t},K8=e=>{let t=Fa.get(e);if(t!==void 0)return t;t=Or.create();const r=Hm.toPolygons(e);if(r.length===0)return t;let n=0;const s=Or.create();return r.forEach(o=>{const a=o.vertices;for(let i=0;i<a.length-2;i++){Or.cross(s,a[i+1],a[i+2]);const c=Or.dot(a[0],s)/6;n+=c,Or.add(s,a[0],a[i+1]),Or.add(s,s,a[i+2]);const l=Or.scale(s,s,1/4*c);Or.add(t,t,l)}}),Or.scale(t,t,1/n),Fa.set(e,t),t},J8=(...e)=>{e=Z8(e);const t=e.map(r=>jm.isA(r)?Q8(r):Hm.isA(r)?K8(r):[0,0,0]);return t.length===1?t[0]:t};var eM=J8;const tM=We,rM=Bn,nM=(...e)=>{e=tM(e);const t=e.map(r=>{const n=rM(r);return[n[1][0]-n[0][0],n[1][1]-n[0][1],n[1][2]-n[0][2]]});return t.length===1?t[0]:t};var sM=nM;const oM=We,{geom2:aM,geom3:iM,path2:cM}=Bl,Xl=Bm,jl=Bn,lM=e=>Xl(jl(e),2),fM=e=>Xl(jl(e),2),uM=e=>Xl(jl(e),3),dM=(...e)=>{if(e=oM(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>cM.isA(r)?lM(r):aM.isA(r)?fM(r):iM.isA(r)?uM(r):0);return t.length===1?t[0]:t};var cn=dM,hM={measureAggregateArea:i8,measureAggregateBoundingBox:ql,measureAggregateEpsilon:S8,measureAggregateVolume:B8,measureArea:Nm,measureBoundingBox:Bn,measureBoundingSphere:X8,measureCenter:W8,measureCenterOfMass:eM,measureDimensions:sM,measureEpsilon:cn,measureVolume:Vm};const mM=(e,t)=>Array.isArray(e)&&e.length>=t?e.every(r=>Number.isFinite(r)):!1,pM=(e,t)=>Number.isFinite(e)&&e>t,vM=(e,t)=>Number.isFinite(e)&&e>=t;var Rt={isNumberArray:mM,isGT:pM,isGTE:vM};const{EPS:l0,TAU:as}=st,Ir=rt,gM=ct,{isGT:yM,isGTE:Fc,isNumberArray:bM}=Rt,_M=e=>{const t={center:[0,0],radius:1,startAngle:0,endAngle:as,makeTangent:!1,segments:32};let{center:r,radius:n,startAngle:s,endAngle:o,makeTangent:a,segments:i}=Object.assign({},t,e);if(!bM(r,2))throw new Error("center must be an array of X and Y values");if(!yM(n,0))throw new Error("radius must be greater than zero");if(!Fc(s,0))throw new Error("startAngle must be positive");if(!Fc(o,0))throw new Error("endAngle must be positive");if(!Fc(i,4))throw new Error("segments must be four or more");s=s%as,o=o%as;let c=as;s<o&&(c=o-s),s>o&&(c=o+(as-s));const l=Math.acos((n*n+n*n-l0*l0)/(2*n*n)),u=Ir.clone(r);let d;const h=[];if(c<l)d=Ir.fromAngleRadians(Ir.create(),s),Ir.scale(d,d,n),Ir.add(d,d,u),h.push(d);else{const m=Math.max(1,Math.floor(i*(c/as)))+1;let $=m*.5/c;$>.25&&($=.25);const g=a?m+2:m;for(let y=0;y<=g;y++){let S=y;a&&(S=(y-1)*(m-2*$)/m+$,S<0&&(S=0),S>m&&(S=m));const N=s+S*(c/m);d=Ir.fromAngleRadians(Ir.create(),N),Ir.scale(d,d,n),Ir.add(d,d,u),h.push(d)}}return gM.fromPoints({closed:!1},h)};var wM=_M;const{EPS:f0,TAU:en}=st,Nc=rt,u0=Qe,{sin:$M,cos:xM}=It,{isGTE:Gc,isNumberArray:d0}=Rt,EM=e=>{const t={center:[0,0],radius:[1,1],startAngle:0,endAngle:en,segments:32};let{center:r,radius:n,startAngle:s,endAngle:o,segments:a}=Object.assign({},t,e);if(!d0(r,2))throw new Error("center must be an array of X and Y values");if(!d0(n,2))throw new Error("radius must be an array of X and Y values");if(!n.every(m=>m>=0))throw new Error("radius values must be positive");if(!Gc(s,0))throw new Error("startAngle must be positive");if(!Gc(o,0))throw new Error("endAngle must be positive");if(!Gc(a,3))throw new Error("segments must be three or more");if(n[0]===0||n[1]===0)return u0.create();s=s%en,o=o%en;let i=en;s<o&&(i=o-s),s>o&&(i=o+(en-s));const c=Math.min(n[0],n[1]),l=Math.acos((c*c+c*c-f0*f0)/(2*c*c));if(i<l)throw new Error("startAngle and endAngle do not define a significant rotation");a=Math.floor(a*(i/en));const u=Nc.clone(r),d=i/a,h=[];a=i<en?a+1:a;for(let m=0;m<a;m++){const $=d*m+s,g=Nc.fromValues(n[0]*xM($),n[1]*$M($));Nc.add(g,u,g),h.push(g)}return i<en&&h.push(u),u0.fromPoints(h)};var Ym=EM;const{TAU:AM}=st,TM=Ym,{isGTE:SM}=Rt,PM=e=>{const t={center:[0,0],radius:1,startAngle:0,endAngle:AM,segments:32};let{center:r,radius:n,startAngle:s,endAngle:o,segments:a}=Object.assign({},t,e);if(!SM(n,0))throw new Error("radius must be positive");return n=[n,n],TM({center:r,radius:n,startAngle:s,endAngle:o,segments:a})};var Wm=PM;const h0=Ke,CM=ot,{isNumberArray:m0}=Rt,MM=e=>{const t={center:[0,0,0],size:[2,2,2]},{center:r,size:n}=Object.assign({},t,e);if(!m0(r,3))throw new Error("center must be an array of X, Y and Z values");if(!m0(n,3))throw new Error("size must be an array of width, depth and height values");if(!n.every(o=>o>=0))throw new Error("size values must be positive");return n[0]===0||n[1]===0||n[2]===0?h0.create():h0.create([[[0,4,6,2],[-1,0,0]],[[1,3,7,5],[1,0,0]],[[0,1,5,4],[0,-1,0]],[[2,6,7,3],[0,1,0]],[[0,2,3,1],[0,0,-1]],[[4,5,7,6],[0,0,1]]].map(o=>{const a=o[0].map(i=>[r[0]+n[0]/2*(2*!!(i&1)-1),r[1]+n[1]/2*(2*!!(i&2)-1),r[2]+n[2]/2*(2*!!(i&4)-1)]);return CM.create(a)}))};var Hl=MM;const OM=Hl,{isGTE:LM}=Rt,RM=e=>{const t={center:[0,0,0],size:2};let{center:r,size:n}=Object.assign({},t,e);if(!LM(n,0))throw new Error("size must be positive");return n=[n,n,n],OM({center:r,size:n})};var FM=RM;const{EPS:p0,TAU:tn}=st,Dt=ze,NM=Ke,GM=ot,{sin:kM,cos:DM}=It,{isGT:BM,isGTE:kc,isNumberArray:Dc}=Rt,IM=e=>{const t={center:[0,0,0],height:2,startRadius:[1,1],startAngle:0,endRadius:[1,1],endAngle:tn,segments:32};let{center:r,height:n,startRadius:s,startAngle:o,endRadius:a,endAngle:i,segments:c}=Object.assign({},t,e);if(!Dc(r,3))throw new Error("center must be an array of X, Y and Z values");if(!BM(n,0))throw new Error("height must be greater then zero");if(!Dc(s,2))throw new Error("startRadius must be an array of X and Y values");if(!s.every(oe=>oe>=0))throw new Error("startRadius values must be positive");if(!Dc(a,2))throw new Error("endRadius must be an array of X and Y values");if(!a.every(oe=>oe>=0))throw new Error("endRadius values must be positive");if(a.every(oe=>oe===0)&&s.every(oe=>oe===0))throw new Error("at least one radius must be positive");if(!kc(o,0))throw new Error("startAngle must be positive");if(!kc(i,0))throw new Error("endAngle must be positive");if(!kc(c,4))throw new Error("segments must be four or more");o=o%tn,i=i%tn;let l=tn;o<i&&(l=i-o),o>i&&(l=i+(tn-o));const u=Math.min(s[0],s[1],a[0],a[1]),d=Math.acos((u*u+u*u-p0*p0)/(2*u*u));if(l<d)throw new Error("startAngle and endAngle do not define a significant rotation");const h=Math.floor(c*(l/tn)),m=Dt.fromValues(0,0,-(n/2)),$=Dt.fromValues(0,0,n/2),g=Dt.subtract(Dt.create(),$,m),y=Dt.fromValues(1,0,0),S=Dt.fromValues(0,1,0),N=Dt.create(),O=Dt.create(),L=Dt.create(),R=(oe,ve,le)=>{const Pe=ve*l+o;return Dt.scale(N,y,le[0]*DM(Pe)),Dt.scale(O,S,le[1]*kM(Pe)),Dt.add(N,N,O),Dt.scale(L,g,oe),Dt.add(L,L,m),Dt.add(Dt.create(),N,L)},F=(...oe)=>{const ve=oe.map(le=>Dt.add(Dt.create(),le,r));return GM.create(ve)},z=[];for(let oe=0;oe<h;oe++){const ve=oe/h;let le=(oe+1)/h;l===tn&&oe===h-1&&(le=0),a[0]===s[0]&&a[1]===s[1]?(z.push(F(m,R(0,le,a),R(0,ve,a))),z.push(F(R(0,le,a),R(1,le,a),R(1,ve,a),R(0,ve,a))),z.push(F($,R(1,ve,a),R(1,le,a)))):(s[0]>0&&s[1]>0&&z.push(F(m,R(0,le,s),R(0,ve,s))),(s[0]>0||s[1]>0)&&z.push(F(R(0,ve,s),R(0,le,s),R(1,ve,a))),a[0]>0&&a[1]>0&&z.push(F($,R(1,ve,a),R(1,le,a))),(a[0]>0||a[1]>0)&&z.push(F(R(1,ve,a),R(0,le,s),R(1,le,a))))}return l<tn&&(z.push(F(m,R(0,0,s),$)),z.push(F(R(0,0,s),R(1,0,a),$)),z.push(F(m,$,R(0,1,s))),z.push(F(R(0,1,s),$,R(1,1,a)))),NM.create(z)};var Zm=IM;const VM=Ke,zM=Zm,{isGTE:UM}=Rt,qM=e=>{const t={center:[0,0,0],height:2,radius:1,segments:32},{center:r,height:n,radius:s,segments:o}=Object.assign({},t,e);if(!UM(s,0))throw new Error("radius must be positive");return n===0||s===0?VM.create():zM({center:r,height:n,startRadius:[s,s],endRadius:[s,s],segments:o})};var Qm=qM;const{TAU:v0}=st,Ue=ze,g0=Ke,y0=ot,{sin:b0,cos:_0}=It,{isGTE:XM,isNumberArray:w0}=Rt,jM=e=>{const t={center:[0,0,0],radius:[1,1,1],segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]},{center:r,radius:n,segments:s,axes:o}=Object.assign({},t,e);if(!w0(r,3))throw new Error("center must be an array of X, Y and Z values");if(!w0(n,3))throw new Error("radius must be an array of X, Y and Z values");if(!n.every($=>$>=0))throw new Error("radius values must be positive");if(!XM(s,4))throw new Error("segments must be four or more");if(n[0]===0||n[1]===0||n[2]===0)return g0.create();const a=Ue.scale(Ue.create(),Ue.normalize(Ue.create(),o[0]),n[0]),i=Ue.scale(Ue.create(),Ue.normalize(Ue.create(),o[1]),n[1]),c=Ue.scale(Ue.create(),Ue.normalize(Ue.create(),o[2]),n[2]),l=Math.round(s/4);let u;const d=[],h=Ue.create(),m=Ue.create();for(let $=0;$<=s;$++){const g=v0*$/s,y=Ue.add(Ue.create(),Ue.scale(h,a,_0(g)),Ue.scale(m,i,b0(g)));if($>0){let S,N;for(let O=0;O<=l;O++){const L=v0/4*O/l,R=_0(L),F=b0(L);if(O>0){let z=[],J;J=Ue.subtract(Ue.create(),Ue.scale(h,u,S),Ue.scale(m,c,N)),z.push(Ue.add(J,J,r)),J=Ue.subtract(Ue.create(),Ue.scale(h,y,S),Ue.scale(m,c,N)),z.push(Ue.add(J,J,r)),O<l&&(J=Ue.subtract(Ue.create(),Ue.scale(h,y,R),Ue.scale(m,c,F)),z.push(Ue.add(J,J,r))),J=Ue.subtract(Ue.create(),Ue.scale(h,u,R),Ue.scale(m,c,F)),z.push(Ue.add(J,J,r)),d.push(y0.create(z)),z=[],J=Ue.add(Ue.create(),Ue.scale(h,u,S),Ue.scale(m,c,N)),z.push(Ue.add(Ue.create(),r,J)),J=Ue.add(J,Ue.scale(h,y,S),Ue.scale(m,c,N)),z.push(Ue.add(Ue.create(),r,J)),O<l&&(J=Ue.add(J,Ue.scale(h,y,R),Ue.scale(m,c,F)),z.push(Ue.add(Ue.create(),r,J))),J=Ue.add(J,Ue.scale(h,u,R),Ue.scale(m,c,F)),z.push(Ue.add(Ue.create(),r,J)),z.reverse(),d.push(y0.create(z))}S=R,N=F}}u=y}return g0.create(d)};var Km=jM;const HM=Ke,YM=ot,{isNumberArray:$0}=Rt,WM=e=>{const t={points:[],faces:[],colors:void 0,orientation:"outward"},{points:r,faces:n,colors:s,orientation:o}=Object.assign({},t,e);if(!(Array.isArray(r)&&Array.isArray(n)))throw new Error("points and faces must be arrays");if(r.length<3)throw new Error("three or more points are required");if(n.length<1)throw new Error("one or more faces are required");if(s){if(!Array.isArray(s))throw new Error("colors must be an array");if(s.length!==n.length)throw new Error("faces and colors must have the same length")}r.forEach((i,c)=>{if(!$0(i,3))throw new Error(`point ${c} must be an array of X, Y, Z values`)}),n.forEach((i,c)=>{if(i.length<3)throw new Error(`face ${c} must contain 3 or more indexes`);if(!$0(i,i.length))throw new Error(`face ${c} must be an array of numbers`)}),o!=="outward"&&n.forEach(i=>i.reverse());const a=n.map((i,c)=>{const l=YM.create(i.map(u=>r[u]));return s&&s[c]&&(l.color=s[c]),l});return HM.create(a)};var Jm=WM;const x0=ft,E0=ze,A0=Ke,ZM=Jm,{isGTE:T0}=Rt,QM=e=>{const t={radius:1,frequency:6};let{radius:r,frequency:n}=Object.assign({},t,e);if(!T0(r,0))throw new Error("radius must be positive");if(!T0(n,6))throw new Error("frequency must be six or more");if(r===0)return A0.create();n=Math.floor(n/6);const s=[[.850651,0,-.525731],[.850651,-0,.525731],[-.850651,-0,.525731],[-.850651,0,-.525731],[0,-.525731,.850651],[0,.525731,.850651],[0,.525731,-.850651],[0,-.525731,-.850651],[-.525731,-.850651,-0],[.525731,-.850651,-0],[.525731,.850651,0],[-.525731,.850651,0]],o=[[0,9,1],[1,10,0],[6,7,0],[10,6,0],[7,9,0],[5,1,4],[4,1,9],[5,10,1],[2,8,3],[3,11,2],[2,5,4],[4,8,2],[2,11,5],[3,7,6],[6,11,3],[8,7,3],[9,8,4],[11,10,5],[10,11,6],[8,9,7]],a=(h,m,$)=>{const g=h[0],y=h[1],S=h[2];let N=$;const O=[],L=[];for(let R=0;R<m;R++)for(let F=0;F<m-R;F++){const z=R/m,J=(R+1)/m,oe=F/(m-R),ve=(F+1)/(m-R),le=m-R-1?F/(m-R-1):1,Pe=[];Pe[0]=i(i(g,y,oe),S,z),Pe[1]=i(i(g,y,ve),S,z),Pe[2]=i(i(g,y,le),S,J);for(let Xe=0;Xe<3;Xe++){const ne=E0.length(Pe[Xe]);for(let Ne=0;Ne<3;Ne++)Pe[Xe][Ne]/=ne}if(O.push(Pe[0],Pe[1],Pe[2]),L.push([N,N+1,N+2]),N+=3,F<m-R-1){const Xe=m-R-1?(F+1)/(m-R-1):1;Pe[0]=i(i(g,y,ve),S,z),Pe[1]=i(i(g,y,Xe),S,J),Pe[2]=i(i(g,y,le),S,J);for(let ne=0;ne<3;ne++){const Ne=E0.length(Pe[ne]);for(let Ge=0;Ge<3;Ge++)Pe[ne][Ge]/=Ne}O.push(Pe[0],Pe[1],Pe[2]),L.push([N,N+1,N+2]),N+=3}}return{points:O,triangles:L,offset:N}},i=(h,m,$)=>{const g=1-$,y=[];for(let S=0;S<3;S++)y[S]=h[S]*g+m[S]*$;return y};let c=[],l=[],u=0;for(let h=0;h<o.length;h++){const m=a([s[o[h][0]],s[o[h][1]],s[o[h][2]]],n,u);c=c.concat(m.points),l=l.concat(m.triangles),u=m.offset}let d=ZM({points:c,faces:l,orientation:"inward"});return r!==1&&(d=A0.transform(x0.fromScaling(x0.create(),[r,r,r]),d)),d};var KM=QM;const JM=ct,eO=e=>{if(!Array.isArray(e))throw new Error("points must be an array");return JM.fromPoints({},e)};var tO=eO;const Bc=Qe,rO=e=>{const t={points:[],paths:[]},{points:r,paths:n}=Object.assign({},t,e);if(!(Array.isArray(r)&&Array.isArray(n)))throw new Error("points and paths must be arrays");let s=r;Array.isArray(r[0])&&(Array.isArray(r[0][0])||(s=[r])),s.forEach((c,l)=>{if(!Array.isArray(c))throw new Error("list of points "+l+" must be an array");if(c.length<3)throw new Error("list of points "+l+" must contain three or more points");c.forEach((u,d)=>{if(!Array.isArray(u))throw new Error("list of points "+l+", point "+d+" must be an array");if(u.length<2)throw new Error("list of points "+l+", point "+d+" must contain by X and Y values")})});let o=n;if(n.length===0){let c=0;o=s.map(l=>l.map(u=>c++))}const a=[];s.forEach(c=>c.forEach(l=>a.push(l)));let i=[];return o.forEach(c=>{const l=c.map(d=>a[d]),u=Bc.fromPoints(l);i=i.concat(Bc.toSides(u))}),Bc.create(i)};var nO=rO;const rn=rt,S0=Qe,{isNumberArray:P0}=Rt,sO=e=>{const t={center:[0,0],size:[2,2]},{center:r,size:n}=Object.assign({},t,e);if(!P0(r,2))throw new Error("center must be an array of X and Y values");if(!P0(n,2))throw new Error("size must be an array of X and Y values");if(!n.every(i=>i>=0))throw new Error("size values must be positive");if(n[0]===0||n[1]===0)return S0.create();const s=[n[0]/2,n[1]/2],o=[s[0],-s[1]],a=[rn.subtract(rn.create(),r,s),rn.add(rn.create(),r,o),rn.add(rn.create(),r,s),rn.subtract(rn.create(),r,o)];return S0.fromPoints(a)};var Yl=sO;const{EPS:Ca,TAU:Qs}=st,Ic=rt,St=ze,C0=Ke,ws=ot,{sin:oO,cos:aO}=It,{isGTE:M0,isNumberArray:O0}=Rt,iO=Hl,L0=(e,t,r,n,s,o)=>{const a=Qs/4*s/n,i=aO(a),c=oO(a),l=n-s;let u=r*i,d=t[2]-(r-r*c);o||(d=r-r*c-t[2]),u=u>Ca?u:0;const h=St.add(St.create(),e,[t[0]-r,t[1]-r,d]),m=St.add(St.create(),e,[r-t[0],t[1]-r,d]),$=St.add(St.create(),e,[r-t[0],r-t[1],d]),g=St.add(St.create(),e,[t[0]-r,r-t[1],d]),y=[],S=[],N=[],O=[];for(let L=0;L<=l;L++){const R=l>0?Qs/4*L/l:0,F=Ic.fromAngleRadians(Ic.create(),R);Ic.scale(F,F,u);const z=St.fromVec2(St.create(),F);y.push(St.add(St.create(),h,z)),St.rotateZ(z,z,[0,0,0],Qs/4),S.push(St.add(St.create(),m,z)),St.rotateZ(z,z,[0,0,0],Qs/4),N.push(St.add(St.create(),$,z)),St.rotateZ(z,z,[0,0,0],Qs/4),O.push(St.add(St.create(),g,z))}return o?[y,S,N,O]:(y.reverse(),S.reverse(),N.reverse(),O.reverse(),[O,N,S,y])},R0=(e,t)=>{const r=[];for(let n=0;n<e.length;n++){const s=e[n],o=t[n];for(let a=0;a<s.length-1;a++)r.push(ws.create([s[a],s[a+1],o[a]])),a<o.length-1&&r.push(ws.create([o[a],s[a+1],o[a+1]]))}return r},F0=(e,t)=>{const r=[];for(let n=0;n<e.length;n++){let s=e[n],o=t[n];const a=s[s.length-1],i=o[o.length-1],c=(n+1)%e.length;s=e[c],o=t[c];const l=s[0],u=o[0];r.push(ws.create([a,l,u,i]))}return r},cO=(e,t)=>{e=[e[3],e[2],e[1],e[0]],e=e.map(o=>o.slice().reverse());const r=[];e.forEach(o=>{o.forEach(a=>r.push(a))});const n=[];t.forEach(o=>{o.forEach(a=>n.push(a))});const s=[];for(let o=0;o<n.length;o++){const a=(o+1)%n.length;s.push(ws.create([r[o],r[a],n[a],n[o]]))}return s},lO=e=>{const t={center:[0,0,0],size:[2,2,2],roundRadius:.2,segments:32};let{center:r,size:n,roundRadius:s,segments:o}=Object.assign({},t,e);if(!O0(r,3))throw new Error("center must be an array of X, Y and Z values");if(!O0(n,3))throw new Error("size must be an array of X, Y and Z values");if(!n.every(l=>l>=0))throw new Error("size values must be positive");if(!M0(s,0))throw new Error("roundRadius must be positive");if(!M0(o,4))throw new Error("segments must be four or more");if(n[0]===0||n[1]===0||n[2]===0)return C0.create();if(s===0)return iO({center:r,size:n});if(n=n.map(l=>l/2),s>n[0]-Ca||s>n[1]-Ca||s>n[2]-Ca)throw new Error("roundRadius must be smaller then the radius of all dimensions");o=Math.floor(o/4);let a=null,i=null,c=[];for(let l=0;l<=o;l++){const u=L0(r,n,s,o,l,!0),d=L0(r,n,s,o,l,!1);if(l===0&&(c=c.concat(cO(d,u))),a&&(c=c.concat(R0(a,u),F0(a,u))),i&&(c=c.concat(R0(i,d),F0(i,d))),l===o){let h=u.map(m=>m[0]);c.push(ws.create(h)),h=d.map(m=>m[0]),c.push(ws.create(h))}a=u,i=d}return C0.create(c)};var fO=lO;const{EPS:uO,TAU:N0}=st,Le=ze,G0=Ke,dO=ot,{sin:k0,cos:D0}=It,{isGTE:fa,isNumberArray:hO}=Rt,mO=Qm,pO=e=>{const t={center:[0,0,0],height:2,radius:1,roundRadius:.2,segments:32},{center:r,height:n,radius:s,roundRadius:o,segments:a}=Object.assign({},t,e);if(!hO(r,3))throw new Error("center must be an array of X, Y and Z values");if(!fa(n,0))throw new Error("height must be positive");if(!fa(s,0))throw new Error("radius must be positive");if(!fa(o,0))throw new Error("roundRadius must be positive");if(o>s)throw new Error("roundRadius must be smaller then the radius");if(!fa(a,4))throw new Error("segments must be four or more");if(n===0||s===0)return G0.create();if(o===0)return mO({center:r,height:n,radius:s});const i=[0,0,-(n/2)],c=[0,0,n/2],l=Le.subtract(Le.create(),c,i),u=Le.length(l);if(2*o>u-uO)throw new Error("height must be larger than twice roundRadius");let d;Math.abs(l[0])>Math.abs(l[1])?d=Le.fromValues(0,1,0):d=Le.fromValues(1,0,0);const h=Le.scale(Le.create(),Le.normalize(Le.create(),l),o),m=Le.scale(Le.create(),Le.normalize(Le.create(),Le.cross(Le.create(),h,d)),s),$=Le.scale(Le.create(),Le.normalize(Le.create(),Le.cross(Le.create(),m,h)),s);Le.add(i,i,h),Le.subtract(c,c,h);const g=Math.floor(.25*a),y=F=>{const z=F.map(J=>Le.add(J,J,r));return dO.create(z)},S=[],N=Le.create(),O=Le.create();let L;for(let F=0;F<=a;F++){const z=N0*F/a,J=Le.add(Le.create(),Le.scale(N,m,D0(z)),Le.scale(O,$,k0(z)));if(F>0){let oe=[];oe.push(Le.add(Le.create(),i,J)),oe.push(Le.add(Le.create(),i,L)),oe.push(Le.add(Le.create(),c,L)),oe.push(Le.add(Le.create(),c,J)),S.push(y(oe));let ve,le;for(let Pe=0;Pe<=g;Pe++){const Xe=N0/4*Pe/g,ne=D0(Xe),Ne=k0(Xe);if(Pe>0){oe=[];let Ge;Ge=Le.add(Le.create(),i,Le.subtract(N,Le.scale(N,L,ve),Le.scale(O,h,le))),oe.push(Ge),Ge=Le.add(Le.create(),i,Le.subtract(N,Le.scale(N,J,ve),Le.scale(O,h,le))),oe.push(Ge),Pe<g&&(Ge=Le.add(Le.create(),i,Le.subtract(N,Le.scale(N,J,ne),Le.scale(O,h,Ne))),oe.push(Ge)),Ge=Le.add(Le.create(),i,Le.subtract(N,Le.scale(N,L,ne),Le.scale(O,h,Ne))),oe.push(Ge),S.push(y(oe)),oe=[],Ge=Le.add(Le.create(),Le.scale(N,L,ve),Le.scale(O,h,le)),Le.add(Ge,Ge,c),oe.push(Ge),Ge=Le.add(Le.create(),Le.scale(N,J,ve),Le.scale(O,h,le)),Le.add(Ge,Ge,c),oe.push(Ge),Pe<g&&(Ge=Le.add(Le.create(),Le.scale(N,J,ne),Le.scale(O,h,Ne)),Le.add(Ge,Ge,c),oe.push(Ge)),Ge=Le.add(Le.create(),Le.scale(N,L,ne),Le.scale(O,h,Ne)),Le.add(Ge,Ge,c),oe.push(Ge),oe.reverse(),S.push(y(oe))}ve=ne,le=Ne}}L=J}return G0.create(S)};var vO=pO;const{EPS:B0,TAU:ua}=st,pt=rt,I0=Qe,{isGTE:V0,isNumberArray:z0}=Rt,gO=Yl,yO=e=>{const t={center:[0,0],size:[2,2],roundRadius:.2,segments:32};let{center:r,size:n,roundRadius:s,segments:o}=Object.assign({},t,e);if(!z0(r,2))throw new Error("center must be an array of X and Y values");if(!z0(n,2))throw new Error("size must be an array of X and Y values");if(!n.every(g=>g>=0))throw new Error("size values must be positive");if(!V0(s,0))throw new Error("roundRadius must be positive");if(!V0(o,4))throw new Error("segments must be four or more");if(n[0]===0||n[1]===0)return I0.create();if(s===0)return gO({center:r,size:n});if(n=n.map(g=>g/2),s>n[0]-B0||s>n[1]-B0)throw new Error("roundRadius must be smaller then the radius of all dimensions");const a=Math.floor(o/4),i=pt.add(pt.create(),r,[n[0]-s,n[1]-s]),c=pt.add(pt.create(),r,[s-n[0],n[1]-s]),l=pt.add(pt.create(),r,[s-n[0],s-n[1]]),u=pt.add(pt.create(),r,[n[0]-s,s-n[1]]),d=[],h=[],m=[],$=[];for(let g=0;g<=a;g++){const y=ua/4*g/a,S=pt.fromAngleRadians(pt.create(),y);pt.scale(S,S,s),d.push(pt.add(pt.create(),i,S)),pt.rotate(S,S,pt.create(),ua/4),h.push(pt.add(pt.create(),c,S)),pt.rotate(S,S,pt.create(),ua/4),m.push(pt.add(pt.create(),l,S)),pt.rotate(S,S,pt.create(),ua/4),$.push(pt.add(pt.create(),u,S))}return I0.fromPoints(d.concat(h,m,$))};var bO=yO;const _O=Km,{isGTE:wO}=Rt,$O=e=>{const t={center:[0,0,0],radius:1,segments:32,axes:[[1,0,0],[0,-1,0],[0,0,1]]};let{center:r,radius:n,segments:s,axes:o}=Object.assign({},t,e);if(!wO(n,0))throw new Error("radius must be positive");return n=[n,n,n],_O({center:r,radius:n,segments:s,axes:o})};var ep=$O;const xO=Yl,{isGTE:EO}=Rt,AO=e=>{const t={center:[0,0],size:2};let{center:r,size:n}=Object.assign({},t,e);if(!EO(n,0))throw new Error("size must be positive");return n=[n,n],xO({center:r,size:n})};var TO=AO;const{TAU:tp}=st,io=rt,SO=Qe,{isGT:PO,isGTE:da,isNumberArray:CO}=Rt,MO=(e,t)=>e>0&&t>1&&t<e/2?Math.cos(Math.PI*t/e)/Math.cos(Math.PI*(t-1)/e):0,U0=(e,t,r,n)=>{const s=tp/e,o=[];for(let a=0;a<e;a++){const i=io.fromAngleRadians(io.create(),s*a+r);io.scale(i,i,t),io.add(i,n,i),o.push(i)}return o},OO=e=>{const t={center:[0,0],vertices:5,outerRadius:1,innerRadius:0,density:2,startAngle:0};let{center:r,vertices:n,outerRadius:s,innerRadius:o,density:a,startAngle:i}=Object.assign({},t,e);if(!CO(r,2))throw new Error("center must be an array of X and Y values");if(!da(n,2))throw new Error("vertices must be two or more");if(!PO(s,0))throw new Error("outerRadius must be greater than zero");if(!da(o,0))throw new Error("innerRadius must be greater than zero");if(!da(i,0))throw new Error("startAngle must be greater than zero");if(n=Math.floor(n),a=Math.floor(a),i=i%tp,o===0){if(!da(a,2))throw new Error("density must be two or more");o=s*MO(n,a)}const c=io.clone(r),l=U0(n,s,i,c),u=U0(n,o,i+Math.PI/n,c),d=[];for(let h=0;h<n;h++)d.push(l[h]),d.push(u[h]);return SO.fromPoints(d)};var LO=OO;const RO=We,q0=ft,X0=Nr,j0=Qe,H0=Ke,Y0=ct,Qa=(e,...t)=>{const r={origin:[0,0,0],normal:[0,0,1]},{origin:n,normal:s}=Object.assign({},r,e);if(t=RO(t),t.length===0)throw new Error("wrong number of arguments");const o=X0.fromNormalAndPoint(X0.create(),s,n);if(Number.isNaN(o[0]))throw new Error("the given origin and normal do not define a proper plane");const a=q0.mirrorByPlane(q0.create(),o),i=t.map(c=>Y0.isA(c)?Y0.transform(a,c):j0.isA(c)?j0.transform(a,c):H0.isA(c)?H0.transform(a,c):c);return i.length===1?i[0]:i},FO=(...e)=>Qa({normal:[1,0,0]},e),NO=(...e)=>Qa({normal:[0,1,0]},e),GO=(...e)=>Qa({normal:[0,0,1]},e);var co={mirror:Qa,mirrorX:FO,mirrorY:NO,mirrorZ:GO};const W0=Nr,Pn=ze,kO=e=>{const t=e.edges;if(t.length<3)throw new Error("slices must have 3 or more edges to calculate a plane");const r=t.reduce((a,i)=>Pn.add(Pn.create(),a,i[0]),Pn.create());Pn.scale(r,r,1/t.length);let n,s=0;t.forEach(a=>{if(!Pn.equals(a[0],a[1])){const i=Pn.squaredDistance(r,a[0]);i>s&&(n=a,s=i)}});const o=t.find(a=>Pn.equals(a[1],n[0]));return W0.fromPoints(W0.create(),o[0],n[0],n[1])};var rp=kO;const DO=e=>(e||(e=[]),{edges:e});var In=DO;const BO=In,Z0=ze,IO=(...e)=>{let t,r;return e.length===1?(t=BO(),r=e[0]):(t=e[0],r=e[1]),t.edges=r.edges.map(n=>[Z0.clone(n[0]),Z0.clone(n[1])]),t};var VO=IO;const zO=ze,UO=(e,t)=>{const r=e.edges,n=t.edges;return r.length!==n.length?!1:r.reduce((o,a,i)=>{const c=n[i],l=zO.squaredDistance(a[0],c[0]);return o&&l<Number.EPSILON},!0)};var qO=UO;const ha=ze,XO=In,jO=e=>{if(!Array.isArray(e))throw new Error("the given points must be an array");if(e.length<3)throw new Error("the given points must contain THREE or more points");const t=[];let r=e[e.length-1];return e.forEach(n=>{n.length===2&&t.push([ha.fromVec2(ha.create(),r),ha.fromVec2(ha.create(),n)]),n.length===3&&t.push([r,n]),r=n}),XO(t)};var HO=jO;const ma=ze,YO=In,WO=e=>{if(!Array.isArray(e))throw new Error("the given sides must be an array");const t=[];return e.forEach(r=>{t.push([ma.fromVec2(ma.create(),r[0]),ma.fromVec2(ma.create(),r[1])])}),YO(t)};var ZO=WO;const QO=e=>!!(e&&typeof e=="object"&&"edges"in e&&Array.isArray(e.edges));var KO=QO;const JO=In,e6=(...e)=>{let t,r;return e.length===1?(t=JO(),r=e[0]):(t=e[0],r=e[1]),t.edges=r.edges.map(n=>[n[1],n[0]]),t};var t6=e6;const r6=e=>e.edges;var n6=r6;const s6=(e,t)=>{let r,n,s,o,a,i=1;do{n=e,e=null;let c=null;for(a=0;n;){a++,s=n;let l=0;for(r=0;r<i&&(l++,s=s.nextZ,!!s);r++);let u=i;for(;l>0||u>0&&s;)l!==0&&(u===0||!s||t(n)<=t(s))?(o=n,n=n.nextZ,l--):(o=s,s=s.nextZ,u--),c?c.nextZ=o:e=o,o.prevZ=c,c=o;n=s}c.nextZ=null,i*=2}while(a>1);return e};var o6=s6;const a6=o6;let np=class{constructor(t,r,n){this.i=t,this.x=r,this.y=n,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}};const i6=(e,t,r,n)=>{const s=new np(e,t,r);return n?(s.next=n.next,s.prev=n,n.next.prev=s,n.next=s):(s.prev=s,s.next=s),s},c6=e=>{e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)};var sp={Node:np,insertNode:i6,removeNode:c6,sortLinked:a6};const l6=(e,t,r,n,s,o,a,i)=>(s-a)*(t-i)-(e-a)*(o-i)>=0&&(e-a)*(n-i)-(r-a)*(t-i)>=0&&(r-a)*(o-i)-(s-a)*(n-i)>=0,f6=(e,t,r)=>(t.y-e.y)*(r.x-t.x)-(t.x-e.x)*(r.y-t.y);var Wl={area:f6,pointInTriangle:l6};const{Node:Q0,insertNode:K0,removeNode:Na}=sp,{area:Qt}=Wl,u6=(e,t,r,n,s)=>{let o;if(s===g6(e,t,r,n)>0)for(let a=t;a<r;a+=n)o=K0(a,e[a],e[a+1],o);else for(let a=r-n;a>=t;a-=n)o=K0(a,e[a],e[a+1],o);return o&&Ka(o,o.next)&&(Na(o),o=o.next),o},op=(e,t)=>{if(!e)return e;t||(t=e);let r=e,n;do if(n=!1,!r.steiner&&(Ka(r,r.next)||Qt(r.prev,r,r.next)===0)){if(Na(r),r=t=r.prev,r===r.next)break;n=!0}else r=r.next;while(n||r!==t);return t},d6=(e,t,r)=>{let n=e;do{const s=n.prev,o=n.next.next;!Ka(s,o)&&ap(s,n,n.next,o)&&vo(s,o)&&vo(o,s)&&(t.push(s.i/r),t.push(n.i/r),t.push(o.i/r),Na(n),Na(n.next),n=e=o),n=n.next}while(n!==e);return op(n)},h6=(e,t)=>{let r=e;do{if(r.i!==e.i&&r.next.i!==e.i&&r.i!==t.i&&r.next.i!==t.i&&ap(r,r.next,e,t))return!0;r=r.next}while(r!==e);return!1},vo=(e,t)=>Qt(e.prev,e,e.next)<0?Qt(e,t,e.next)>=0&&Qt(e,e.prev,t)>=0:Qt(e,t,e.prev)<0||Qt(e,e.next,t)<0,m6=(e,t)=>{let r=e,n=!1;const s=(e.x+t.x)/2,o=(e.y+t.y)/2;do r.y>o!=r.next.y>o&&r.next.y!==r.y&&s<(r.next.x-r.x)*(o-r.y)/(r.next.y-r.y)+r.x&&(n=!n),r=r.next;while(r!==e);return n},p6=(e,t)=>{const r=new Q0(e.i,e.x,e.y),n=new Q0(t.i,t.x,t.y),s=e.next,o=t.prev;return e.next=t,t.prev=e,r.next=s,s.prev=r,n.next=r,r.prev=n,o.next=n,n.prev=o,n},v6=(e,t)=>e.next.i!==t.i&&e.prev.i!==t.i&&!h6(e,t)&&(vo(e,t)&&vo(t,e)&&m6(e,t)&&(Qt(e.prev,e,t.prev)||Qt(e,t.prev,t))||Ka(e,t)&&Qt(e.prev,e,e.next)>0&&Qt(t.prev,t,t.next)>0),ap=(e,t,r,n)=>{const s=Math.sign(Qt(e,t,r)),o=Math.sign(Qt(e,t,n)),a=Math.sign(Qt(r,n,e)),i=Math.sign(Qt(r,n,t));return!!(s!==o&&a!==i||s===0&&pa(e,r,t)||o===0&&pa(e,n,t)||a===0&&pa(r,e,n)||i===0&&pa(r,t,n))},pa=(e,t,r)=>t.x<=Math.max(e.x,r.x)&&t.x>=Math.min(e.x,r.x)&&t.y<=Math.max(e.y,r.y)&&t.y>=Math.min(e.y,r.y),g6=(e,t,r,n)=>{let s=0;for(let o=t,a=r-n;o<r;o+=n)s+=(e[a]-e[o])*(e[o+1]+e[a+1]),a=o;return s},Ka=(e,t)=>e.x===t.x&&e.y===t.y;var ip={cureLocalIntersections:d6,filterPoints:op,isValidDiagonal:v6,linkedPolygon:u6,locallyInside:vo,splitPolygon:p6};const{filterPoints:bl,linkedPolygon:y6,locallyInside:b6,splitPolygon:_6}=ip,{area:J0,pointInTriangle:w6}=Wl,$6=(e,t,r,n)=>{const s=[];for(let o=0,a=t.length;o<a;o++){const i=t[o]*n,c=o<a-1?t[o+1]*n:e.length,l=y6(e,i,c,n,!1);l===l.next&&(l.steiner=!0),s.push(T6(l))}s.sort((o,a)=>o.x-a.x);for(let o=0;o<s.length;o++)r=x6(s[o],r),r=bl(r,r.next);return r},x6=(e,t)=>{const r=E6(e,t);if(!r)return t;const n=_6(r,e),s=bl(r,r.next);return bl(n,n.next),t===r?s:t},E6=(e,t)=>{let r=t;const n=e.x,s=e.y;let o=-1/0,a;do{if(s<=r.y&&s>=r.next.y&&r.next.y!==r.y){const d=r.x+(s-r.y)*(r.next.x-r.x)/(r.next.y-r.y);if(d<=n&&d>o){if(o=d,d===n){if(s===r.y)return r;if(s===r.next.y)return r.next}a=r.x<r.next.x?r:r.next}}r=r.next}while(r!==t);if(!a)return null;if(n===o)return a;const i=a,c=a.x,l=a.y;let u=1/0;r=a;do{if(n>=r.x&&r.x>=c&&n!==r.x&&w6(s<l?n:o,s,c,l,s<l?o:n,s,r.x,r.y)){const d=Math.abs(s-r.y)/(n-r.x);b6(r,e)&&(d<u||d===u&&(r.x>a.x||r.x===a.x&&A6(a,r)))&&(a=r,u=d)}r=r.next}while(r!==i);return a},A6=(e,t)=>J0(e.prev,e,t.prev)<0&&J0(t.next,e,e.next)<0,T6=e=>{let t=e,r=e;do(t.x<r.x||t.x===r.x&&t.y<r.y)&&(r=t),t=t.next;while(t!==e);return r};var S6=$6;const P6=S6,{removeNode:C6,sortLinked:M6}=sp,{cureLocalIntersections:O6,filterPoints:Ga,isValidDiagonal:L6,linkedPolygon:R6,splitPolygon:F6}=ip,{area:Mn,pointInTriangle:lo}=Wl,N6=(e,t,r=2)=>{const n=t&&t.length,s=n?t[0]*r:e.length;let o=R6(e,0,s,r,!0);const a=[];if(!o||o.next===o.prev)return a;let i,c,l,u,d;if(n&&(o=P6(e,t,o,r)),e.length>80*r){i=l=e[0],c=u=e[1];for(let h=r;h<s;h+=r){const m=e[h],$=e[h+1];m<i&&(i=m),$<c&&(c=$),m>l&&(l=m),$>u&&(u=$)}d=Math.max(l-i,u-c),d=d!==0?1/d:0}return go(o,a,r,i,c,d),a},go=(e,t,r,n,s,o,a)=>{if(!e)return;!a&&o&&B6(e,n,s,o);let i=e,c,l;for(;e.prev!==e.next;){if(c=e.prev,l=e.next,o?k6(e,n,s,o):G6(e)){t.push(c.i/r),t.push(e.i/r),t.push(l.i/r),C6(e),e=l.next,i=l.next;continue}if(e=l,e===i){a?a===1?(e=O6(Ga(e),t,r),go(e,t,r,n,s,o,2)):a===2&&D6(e,t,r,n,s,o):go(Ga(e),t,r,n,s,o,1);break}}},G6=e=>{const t=e.prev,r=e,n=e.next;if(Mn(t,r,n)>=0)return!1;let s=e.next.next;for(;s!==e.prev;){if(lo(t.x,t.y,r.x,r.y,n.x,n.y,s.x,s.y)&&Mn(s.prev,s,s.next)>=0)return!1;s=s.next}return!0},k6=(e,t,r,n)=>{const s=e.prev,o=e,a=e.next;if(Mn(s,o,a)>=0)return!1;const i=s.x<o.x?s.x<a.x?s.x:a.x:o.x<a.x?o.x:a.x,c=s.y<o.y?s.y<a.y?s.y:a.y:o.y<a.y?o.y:a.y,l=s.x>o.x?s.x>a.x?s.x:a.x:o.x>a.x?o.x:a.x,u=s.y>o.y?s.y>a.y?s.y:a.y:o.y>a.y?o.y:a.y,d=_l(i,c,t,r,n),h=_l(l,u,t,r,n);let m=e.prevZ,$=e.nextZ;for(;m&&m.z>=d&&$&&$.z<=h;){if(m!==e.prev&&m!==e.next&&lo(s.x,s.y,o.x,o.y,a.x,a.y,m.x,m.y)&&Mn(m.prev,m,m.next)>=0||(m=m.prevZ,$!==e.prev&&$!==e.next&&lo(s.x,s.y,o.x,o.y,a.x,a.y,$.x,$.y)&&Mn($.prev,$,$.next)>=0))return!1;$=$.nextZ}for(;m&&m.z>=d;){if(m!==e.prev&&m!==e.next&&lo(s.x,s.y,o.x,o.y,a.x,a.y,m.x,m.y)&&Mn(m.prev,m,m.next)>=0)return!1;m=m.prevZ}for(;$&&$.z<=h;){if($!==e.prev&&$!==e.next&&lo(s.x,s.y,o.x,o.y,a.x,a.y,$.x,$.y)&&Mn($.prev,$,$.next)>=0)return!1;$=$.nextZ}return!0},D6=(e,t,r,n,s,o)=>{let a=e;do{let i=a.next.next;for(;i!==a.prev;){if(a.i!==i.i&&L6(a,i)){let c=F6(a,i);a=Ga(a,a.next),c=Ga(c,c.next),go(a,t,r,n,s,o),go(c,t,r,n,s,o);return}i=i.next}a=a.next}while(a!==e)},B6=(e,t,r,n)=>{let s=e;do s.z===null&&(s.z=_l(s.x,s.y,t,r,n)),s.prevZ=s.prev,s.nextZ=s.next,s=s.next;while(s!==e);s.prevZ.nextZ=null,s.prevZ=null,M6(s,o=>o.z)},_l=(e,t,r,n,s)=>(e=32767*(e-r)*s,t=32767*(t-n)*s,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e|t<<1);var I6=N6;const{area:V6}=wo,{toOutlines:z6}=Qe,{arePointsInside:U6}=Dl,q6=e=>{const t=z6(e),r=[],n=[];t.forEach((a,i)=>{const c=V6(a);c<0?n.push(i):c>0&&r.push(i)});const s=[],o=[];return r.forEach((a,i)=>{const c=t[a];s[i]=[],n.forEach((l,u)=>{const d=t[l];U6([d[0]],{vertices:c})&&(s[i].push(l),o[u]||(o[u]=[]),o[u].push(i))})}),n.forEach((a,i)=>{if(o[i]&&o[i].length>1){const c=X6(o[i],l=>s[l].length);o[i].forEach((l,u)=>{u!==c&&(s[l]=s[l].filter(d=>d!==a))})}}),s.map((a,i)=>({solid:t[r[i]],holes:a.map(c=>t[c])}))},X6=(e,t)=>{let r,n;return e.forEach((s,o)=>{const a=t(s);(n===void 0||a<n)&&(r=o,n=a)}),r};var j6=q6;const H6=Qe,ed=Nr,Y6=rt,Bt=ze,W6=rp,Z6=j6;let Q6=class{constructor(t){this.plane=W6(t);const r=Bt.orthogonal(Bt.create(),this.plane),n=Bt.cross(Bt.create(),this.plane,r);this.v=Bt.normalize(n,n),this.u=Bt.cross(Bt.create(),this.v,this.plane),this.basisMap=new Map;const s=t.edges.map(a=>a.map(i=>this.to2D(i))),o=H6.create(s);this.roots=Z6(o)}to2D(t){const r=Y6.fromValues(Bt.dot(t,this.u),Bt.dot(t,this.v));return this.basisMap.set(r,t),r}to3D(t){const r=this.basisMap.get(t);if(r)return r;{console.log("Warning: point not in original slice");const n=Bt.scale(Bt.create(),this.u,t[0]),s=Bt.scale(Bt.create(),this.v,t[1]),o=Bt.scale(Bt.create(),ed,ed[3]),a=Bt.add(n,n,o);return Bt.add(s,s,a)}}};var K6=Q6;const J6=ot,eL=I6,tL=K6,rL=e=>{const t=new tL(e),r=[];return t.roots.forEach(({solid:n,holes:s})=>{let o=n.length;const a=[];s.forEach((d,h)=>{a.push(o),o+=d.length});const i=[n,...s].flat(),c=i.flat(),l=d=>t.to3D(i[d]),u=eL(c,a);for(let d=0;d<u.length;d+=3){const h=u.slice(d,d+3).map(l);r.push(J6.fromPointsAndPlane(h,t.plane))}}),r};var nL=rL;const td=ze,sL=e=>e.reduce((t,r)=>t+=`[${td.toString(r[0])}, ${td.toString(r[1])}], `,""),oL=e=>`[${sL(e.edges)}]`;var aL=oL;const va=ze,iL=In,cL=(e,t)=>{const r=t.edges.map(n=>[va.transform(va.create(),n[0],e),va.transform(va.create(),n[1],e)]);return iL(r)};var lL=cL,As={calculatePlane:rp,clone:VO,create:In,equals:qO,fromPoints:HO,fromSides:ZO,isA:KO,reverse:t6,toEdges:n6,toPolygons:nL,toString:aL,transform:lL};const rd=ze,fL=In,uL=e=>{if(!e.edges)return e;let t=e.edges;const r=new Map,n=new Map;t=t.filter(a=>!rd.equals(a[0],a[1])),t.forEach(a=>{const i=a[0].toString(),c=a[1].toString();r.set(i,a[0]),r.set(c,a[1]),n.set(i,(n.get(i)||0)+1),n.set(c,(n.get(c)||0)-1)});const s=[],o=[];return n.forEach((a,i)=>{a<0&&s.push(i),a>0&&o.push(i)}),s.forEach(a=>{const i=r.get(a);let c=1/0,l;o.forEach(u=>{const d=r.get(u),h=rd.distance(i,d);h<c&&(c=h,l=d)}),console.warn(`slice.repair: repairing vertex gap ${i} to ${l} distance ${c}`),t=t.map(u=>u[0].toString()===a?[l,u[1]]:u[1].toString()===a?[u[0],l]:u)}),fL(t)};var dL=uL;const{EPS:nd}=st,is=ze,ga=ot,sd=As,wl=(e,t)=>e===t?e:e<t?wl(t,e):t===1?1:t===0?e:wl(t,e%t),hL=(e,t)=>e*t/wl(e,t),od=(e,t)=>{const r=e/t.length;if(r===1)return t;const n=is.fromValues(r,r,r),s=[];return t.forEach(o=>{const a=is.subtract(is.create(),o[1],o[0]);is.divide(a,a,n);let i=o[0];for(let c=1;c<=r;++c){const l=is.add(is.create(),i,a);s.push([i,l]),i=l}}),s},ad=nd*nd/2*Math.sin(Math.PI/3),mL=(e,t)=>{let r=sd.toEdges(e),n=sd.toEdges(t);if(r.length!==n.length){const o=hL(r.length,n.length);o!==r.length&&(r=od(o,r)),o!==n.length&&(n=od(o,n))}const s=[];return r.forEach((o,a)=>{const i=n[a],c=ga.create([o[0],o[1],i[1]]),l=ga.measureArea(c);Number.isFinite(l)&&l>ad&&s.push(c);const u=ga.create([o[0],i[1],i[0]]),d=ga.measureArea(u);Number.isFinite(d)&&d>ad&&s.push(u)}),s};var pL=mL;const id=ft,cd=Qe,vL=Ke,$l=ot,on=As,gL=dL,ld=pL,yL=(e,t,r)=>{let n=null;return cd.isA(r)&&(n=on.fromSides(cd.toSides(r))),$l.isA(r)&&(n=on.fromPoints($l.toPoints(r))),e===0||e===1?on.transform(id.fromTranslation(id.create(),[0,0,e]),n):null},bL=(e,t)=>{const r={numberOfSlices:2,capStart:!0,capEnd:!0,close:!1,repair:!0,callback:yL},{numberOfSlices:n,capStart:s,capEnd:o,close:a,repair:i,callback:c}=Object.assign({},r,e);if(n<2)throw new Error("numberOfSlices must be 2 or more");i&&(t=gL(t));const l=n-1;let u=null,d=null,h=null,m=[];for(let $=0;$<n;$++){const g=c($/l,$,t);if(g){if(!on.isA(g))throw new Error("the callback function must return slice objects");if(on.toEdges(g).length===0)throw new Error("the callback function must return slices with one or more edges");h&&(m=m.concat(ld(h,g))),$===0&&(u=g),$===n-1&&(d=g),h=g}}if(o){const $=on.toPolygons(d);m=m.concat($)}if(s){const $=on.toPolygons(u).map($l.invert);m=m.concat($)}return!s&&!o&&a&&!on.equals(d,u)&&(m=m.concat(ld(d,u))),vL.create(m)};var Ja=bL;const{TAU:ir}=st,Ks=ft,{mirrorX:_L}=co,Js=Qe,Vc=As,wL=Ja,$L=(e,t)=>{const r={segments:12,startAngle:0,angle:ir,overflow:"cap"};let{segments:n,startAngle:s,angle:o,overflow:a}=Object.assign({},r,e);if(n<3)throw new Error("segments must be greater then 3");s=Math.abs(s)>ir?s%ir:s,o=Math.abs(o)>ir?o%ir:o;let i=s+o;if(i=Math.abs(i)>ir?i%ir:i,i<s){const N=s;s=i,i=N}let c=i-s;if(c<=0&&(c=ir),Math.abs(c)<ir){const N=ir/n;n=Math.floor(Math.abs(c)/N),Math.abs(c)>n*N&&n++}let l=Js.toSides(t);if(l.length===0)throw new Error("the given geometry cannot be empty");const u=l.filter(N=>N[0][0]<0),d=l.filter(N=>N[0][0]>=0);u.length>0&&d.length>0&&a==="cap"&&(u.length>d.length?(l=l.map(N=>{let O=N[0],L=N[1];return O=[Math.min(O[0],0),O[1]],L=[Math.min(L[0],0),L[1]],[O,L]}),t=Js.reverse(Js.create(l)),t=_L(t)):d.length>=u.length&&(l=l.map(N=>{let O=N[0],L=N[1];return O=[Math.max(O[0],0),O[1]],L=[Math.max(L[0],0),L[1]],[O,L]}),t=Js.create(l)));const m=c/n,$=Math.abs(c)<ir,g=Vc.fromSides(Js.toSides(t));Vc.reverse(g,g);const y=Ks.create(),S=(N,O,L)=>{let R=m*O+s;return c===ir&&O===n&&(R=s),Ks.multiply(y,Ks.fromZRotation(y,R),Ks.fromXRotation(Ks.create(),ir/4)),Vc.transform(y,L)};return e={numberOfSlices:n+1,capStart:$,capEnd:$,close:!$,callback:S},wL(e,g)};var cp=$L;const xL=We,fd=ft,ud=Qe,dd=Ke,hd=ct,ei=(e,...t)=>{if(!Array.isArray(e))throw new Error("angles must be an array");if(t=xL(t),t.length===0)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(0);const r=e[2],n=e[1],s=e[0],o=fd.fromTaitBryanRotation(fd.create(),r,n,s),a=t.map(i=>hd.isA(i)?hd.transform(o,i):ud.isA(i)?ud.transform(o,i):dd.isA(i)?dd.transform(o,i):i);return a.length===1?a[0]:a},EL=(e,...t)=>ei([e,0,0],t),AL=(e,...t)=>ei([0,e,0],t),TL=(e,...t)=>ei([0,0,e],t);var fo={rotate:ei,rotateX:EL,rotateY:AL,rotateZ:TL};const SL=We,md=ft,pd=Qe,vd=Ke,gd=ct,ti=(e,...t)=>{if(!Array.isArray(e))throw new Error("offset must be an array");if(t=SL(t),t.length===0)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(0);const r=md.fromTranslation(md.create(),e),n=t.map(s=>gd.isA(s)?gd.transform(r,s):pd.isA(s)?pd.transform(r,s):vd.isA(s)?vd.transform(r,s):s);return n.length===1?n[0]:n},PL=(e,...t)=>ti([e,0,0],t),CL=(e,...t)=>ti([0,e,0],t),ML=(e,...t)=>ti([0,0,e],t);var Ln={translate:ti,translateX:PL,translateY:CL,translateZ:ML};const{TAU:OL}=st,LL=cp,{rotate:RL}=fo,{translate:FL}=Ln,NL=Wm,{isGT:zc,isGTE:Uc}=Rt,GL=e=>{const t={innerRadius:1,innerSegments:32,outerRadius:4,outerSegments:32,innerRotation:0,startAngle:0,outerRotation:OL},{innerRadius:r,innerSegments:n,outerRadius:s,outerSegments:o,innerRotation:a,startAngle:i,outerRotation:c}=Object.assign({},t,e);if(!zc(r,0))throw new Error("innerRadius must be greater than zero");if(!Uc(n,3))throw new Error("innerSegments must be three or more");if(!zc(s,0))throw new Error("outerRadius must be greater than zero");if(!Uc(o,3))throw new Error("outerSegments must be three or more");if(!Uc(i,0))throw new Error("startAngle must be positive");if(!zc(c,0))throw new Error("outerRotation must be greater than zero");if(r>=s)throw new Error("inner circle is two large to rotate about the outer circle");let l=NL({radius:r,segments:n});return a!==0&&(l=RL([0,0,a],l)),l=FL([s,0],l),LL({startAngle:i,angle:c,segments:o},l)};var kL=GL;const{NEPS:$s}=st,eo=rt,DL=Qe,{isNumberArray:BL}=Rt,xl=(e,t,r)=>Math.acos((e*e+t*t-r*r)/(2*e*t)),IL=(e,t,r)=>t>$s?Math.sqrt(e*e+r*r-2*e*r*Math.cos(t)):Math.sqrt((e-r)*(e-r)+e*r*t*t*(1-t*t/12)),VL=e=>{if(Math.abs(e[0]+e[1]+e[2]-Math.PI)>$s)throw new Error("AAA triangles require angles that sum to PI");const r=e[0],n=e[1],s=Math.PI-r-n,o=1,a=o/Math.sin(s)*Math.sin(r),i=o/Math.sin(s)*Math.sin(n);return Ts(r,n,s,a,i,o)},zL=e=>{const t=e[0],r=e[1],n=Math.PI+$s-t-r;if(n<$s)throw new Error("AAS triangles require angles that sum to PI");const s=e[2],o=s/Math.sin(t)*Math.sin(r),a=s/Math.sin(t)*Math.sin(n);return Ts(t,r,n,s,o,a)},UL=e=>{const t=e[0],r=e[2],n=Math.PI+$s-t-r;if(n<$s)throw new Error("ASA triangles require angles that sum to PI");const s=e[1],o=s/Math.sin(n)*Math.sin(t),a=s/Math.sin(n)*Math.sin(r);return Ts(t,r,n,o,a,s)},qL=e=>{const t=e[0],r=e[1],n=e[2],s=IL(t,r,n),o=xl(s,t,n),a=Math.PI-o-r;return Ts(o,r,a,n,s,t)},XL=e=>{const t=e[0],r=e[1],n=e[2],s=Math.asin(r*Math.sin(n)/t),o=Math.PI-s-n,a=t/Math.sin(n)*Math.sin(o);return Ts(s,o,n,r,a,t)},jL=e=>{const t=e[1],r=e[2],n=e[0];if(t+r<=n||r+n<=t||n+t<=r)throw new Error("SSS triangle is incorrect, as the longest side is longer than the sum of the other sides");const s=xl(r,n,t),o=xl(n,t,r),a=Math.PI-s-o;return Ts(s,o,a,t,r,n)},Ts=(e,t,r,n,s,o)=>{const a=eo.fromValues(0,0),i=eo.fromValues(o,0),c=eo.fromValues(n,0);return eo.add(c,eo.rotate(c,c,[0,0],Math.PI-t),i),DL.fromPoints([a,i,c])},HL=e=>{const t={type:"SSS",values:[1,1,1]};let{type:r,values:n}=Object.assign({},t,e);if(typeof r!="string")throw new Error("triangle type must be a string");if(r=r.toUpperCase(),!((r[0]==="A"||r[0]==="S")&&(r[1]==="A"||r[1]==="S")&&(r[2]==="A"||r[2]==="S")))throw new Error("triangle type must contain three letters; A or S");if(!BL(n,3))throw new Error("triangle values must contain three values");if(!n.every(s=>s>0))throw new Error("triangle values must be greater than zero");switch(r){case"AAA":return VL(n);case"AAS":return zL(n);case"ASA":return UL(n);case"SAS":return qL(n);case"SSA":return XL(n);case"SSS":return jL(n);default:throw new Error("invalid triangle type, try again")}};var YL=HL,WL={arc:wM,circle:Wm,cube:FM,cuboid:Hl,cylinder:Qm,cylinderElliptic:Zm,ellipse:Ym,ellipsoid:Km,geodesicSphere:KM,line:tO,polygon:nO,polyhedron:Jm,rectangle:Yl,roundedCuboid:fO,roundedCylinder:vO,roundedRectangle:bO,sphere:ep,square:TO,star:LO,torus:kL,triangle:YL},ZL={height:14,32:[16],33:[10,5,21,5,7,void 0,5,2,4,1,5,0,6,1,5,2],34:[16,4,21,4,14,void 0,12,21,12,14],35:[21,11,25,4,-7,void 0,17,25,10,-7,void 0,4,12,18,12,void 0,3,6,17,6],36:[20,8,25,8,-4,void 0,12,25,12,-4,void 0,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],37:[24,21,21,3,0,void 0,8,21,10,19,10,17,9,15,7,14,5,14,3,16,3,18,4,20,6,21,8,21,10,20,13,19,16,19,19,20,21,21,void 0,17,7,15,6,14,4,14,2,16,0,18,0,20,1,21,3,21,5,19,7,17,7],38:[26,23,12,23,13,22,14,21,14,20,13,19,11,17,6,15,3,13,1,11,0,7,0,5,1,4,2,3,4,3,6,4,8,5,9,12,13,13,14,14,16,14,18,13,20,11,21,9,20,8,18,8,16,9,13,11,10,16,3,18,1,20,0,22,0,23,1,23,2],39:[10,5,19,4,20,5,21,6,20,6,18,5,16,4,15],40:[14,11,25,9,23,7,20,5,16,4,11,4,7,5,2,7,-2,9,-5,11,-7],41:[14,3,25,5,23,7,20,9,16,10,11,10,7,9,2,7,-2,5,-5,3,-7],42:[16,8,21,8,9,void 0,3,18,13,12,void 0,13,18,3,12],43:[26,13,18,13,0,void 0,4,9,22,9],44:[10,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],45:[26,4,9,22,9],46:[10,5,2,4,1,5,0,6,1,5,2],47:[22,20,25,2,-7],48:[20,9,21,6,20,4,17,3,12,3,9,4,4,6,1,9,0,11,0,14,1,16,4,17,9,17,12,16,17,14,20,11,21,9,21],49:[20,6,17,8,18,11,21,11,0],50:[20,4,16,4,17,5,19,6,20,8,21,12,21,14,20,15,19,16,17,16,15,15,13,13,10,3,0,17,0],51:[20,5,21,16,21,10,13,13,13,15,12,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],52:[20,13,21,3,7,18,7,void 0,13,21,13,0],53:[20,15,21,5,21,4,12,5,13,8,14,11,14,14,13,16,11,17,8,17,6,16,3,14,1,11,0,8,0,5,1,4,2,3,4],54:[20,16,18,15,20,12,21,10,21,7,20,5,17,4,12,4,7,5,3,7,1,10,0,11,0,14,1,16,3,17,6,17,7,16,10,14,12,11,13,10,13,7,12,5,10,4,7],55:[20,17,21,7,0,void 0,3,21,17,21],56:[20,8,21,5,20,4,18,4,16,5,14,7,13,11,12,14,11,16,9,17,7,17,4,16,2,15,1,12,0,8,0,5,1,4,2,3,4,3,7,4,9,6,11,9,12,13,13,15,14,16,16,16,18,15,20,12,21,8,21],57:[20,16,14,15,11,13,9,10,8,9,8,6,9,4,11,3,14,3,15,4,18,6,20,9,21,10,21,13,20,15,18,16,14,16,9,15,4,13,1,10,0,8,0,5,1,4,3],58:[10,5,14,4,13,5,12,6,13,5,14,void 0,5,2,4,1,5,0,6,1,5,2],59:[10,5,14,4,13,5,12,6,13,5,14,void 0,6,1,5,0,4,1,5,2,6,1,6,-1,5,-3,4,-4],60:[24,20,18,4,9,20,0],61:[26,4,12,22,12,void 0,4,6,22,6],62:[24,4,18,20,9,4,0],63:[18,3,16,3,17,4,19,5,20,7,21,11,21,13,20,14,19,15,17,15,15,14,13,13,12,9,10,9,7,void 0,9,2,8,1,9,0,10,1,9,2],64:[27,18,13,17,15,15,16,12,16,10,15,9,14,8,11,8,8,9,6,11,5,14,5,16,6,17,8,void 0,12,16,10,14,9,11,9,8,10,6,11,5,void 0,18,16,17,8,17,6,19,5,21,5,23,7,24,10,24,12,23,15,22,17,20,19,18,20,15,21,12,21,9,20,7,19,5,17,4,15,3,12,3,9,4,6,5,4,7,2,9,1,12,0,15,0,18,1,20,2,21,3,void 0,19,16,18,8,18,6,19,5],65:[18,9,21,1,0,void 0,9,21,17,0,void 0,4,7,14,7],66:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,void 0,4,11,13,11,16,10,17,9,18,7,18,4,17,2,16,1,13,0,4,0],67:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5],68:[21,4,21,4,0,void 0,4,21,11,21,14,20,16,18,17,16,18,13,18,8,17,5,16,3,14,1,11,0,4,0],69:[19,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11,void 0,4,0,17,0],70:[18,4,21,4,0,void 0,4,21,17,21,void 0,4,11,12,11],71:[21,18,16,17,18,15,20,13,21,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,18,8,void 0,13,8,18,8],72:[22,4,21,4,0,void 0,18,21,18,0,void 0,4,11,18,11],73:[8,4,21,4,0],74:[16,12,21,12,5,11,2,10,1,8,0,6,0,4,1,3,2,2,5,2,7],75:[21,4,21,4,0,void 0,18,21,4,7,void 0,9,12,18,0],76:[17,4,21,4,0,void 0,4,0,16,0],77:[24,4,21,4,0,void 0,4,21,12,0,void 0,20,21,12,0,void 0,20,21,20,0],78:[22,4,21,4,0,void 0,4,21,18,0,void 0,18,21,18,0],79:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21],80:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,14,17,12,16,11,13,10,4,10],81:[22,9,21,7,20,5,18,4,16,3,13,3,8,4,5,5,3,7,1,9,0,13,0,15,1,17,3,18,5,19,8,19,13,18,16,17,18,15,20,13,21,9,21,void 0,12,4,18,-2],82:[21,4,21,4,0,void 0,4,21,13,21,16,20,17,19,18,17,18,15,17,13,16,12,13,11,4,11,void 0,11,11,18,0],83:[20,17,18,15,20,12,21,8,21,5,20,3,18,3,16,4,14,5,13,7,12,13,10,15,9,16,8,17,6,17,3,15,1,12,0,8,0,5,1,3,3],84:[16,8,21,8,0,void 0,1,21,15,21],85:[22,4,21,4,6,5,3,7,1,10,0,12,0,15,1,17,3,18,6,18,21],86:[18,1,21,9,0,void 0,17,21,9,0],87:[24,2,21,7,0,void 0,12,21,7,0,void 0,12,21,17,0,void 0,22,21,17,0],88:[20,3,21,17,0,void 0,17,21,3,0],89:[18,1,21,9,11,9,0,void 0,17,21,9,11],90:[20,17,21,3,0,void 0,3,21,17,21,void 0,3,0,17,0],91:[14,4,25,4,-7,void 0,5,25,5,-7,void 0,4,25,11,25,void 0,4,-7,11,-7],92:[14,0,21,14,-3],93:[14,9,25,9,-7,void 0,10,25,10,-7,void 0,3,25,10,25,void 0,3,-7,10,-7],94:[16,6,15,8,18,10,15,void 0,3,12,8,17,13,12,void 0,8,17,8,0],95:[16,0,-2,16,-2],96:[10,6,21,5,20,4,18,4,16,5,15,6,16,5,17],97:[19,15,14,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],98:[19,4,21,4,0,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],99:[18,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],100:[19,15,21,15,0,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],101:[18,3,8,15,8,15,10,14,12,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],102:[12,10,21,8,21,6,20,5,17,5,0,void 0,2,14,9,14],103:[19,15,14,15,-2,14,-5,13,-6,11,-7,8,-7,6,-6,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],104:[19,4,21,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],105:[8,3,21,4,20,5,21,4,22,3,21,void 0,4,14,4,0],106:[10,5,21,6,20,7,21,6,22,5,21,void 0,6,14,6,-3,5,-6,3,-7,1,-7],107:[17,4,21,4,0,void 0,14,14,4,4,void 0,8,8,15,0],108:[8,4,21,4,0],109:[30,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0,void 0,15,10,18,13,20,14,23,14,25,13,26,10,26,0],110:[19,4,14,4,0,void 0,4,10,7,13,9,14,12,14,14,13,15,10,15,0],111:[19,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3,16,6,16,8,15,11,13,13,11,14,8,14],112:[19,4,14,4,-7,void 0,4,11,6,13,8,14,11,14,13,13,15,11,16,8,16,6,15,3,13,1,11,0,8,0,6,1,4,3],113:[19,15,14,15,-7,void 0,15,11,13,13,11,14,8,14,6,13,4,11,3,8,3,6,4,3,6,1,8,0,11,0,13,1,15,3],114:[13,4,14,4,0,void 0,4,8,5,11,7,13,9,14,12,14],115:[17,14,11,13,13,10,14,7,14,4,13,3,11,4,9,6,8,11,7,13,6,14,4,14,3,13,1,10,0,7,0,4,1,3,3],116:[12,5,21,5,4,6,1,8,0,10,0,void 0,2,14,9,14],117:[19,4,14,4,4,5,1,7,0,10,0,12,1,15,4,void 0,15,14,15,0],118:[16,2,14,8,0,void 0,14,14,8,0],119:[22,3,14,7,0,void 0,11,14,7,0,void 0,11,14,15,0,void 0,19,14,15,0],120:[17,3,14,14,0,void 0,14,14,3,0],121:[16,2,14,8,0,void 0,14,14,8,0,6,-4,4,-6,2,-7,1,-7],122:[17,14,14,3,0,void 0,3,14,14,14,void 0,3,0,14,0],123:[14,9,25,7,24,6,23,5,21,5,19,6,17,7,16,8,14,8,12,6,10,void 0,7,24,6,22,6,20,7,18,8,17,9,15,9,13,8,11,4,9,8,7,9,5,9,3,8,1,7,0,6,-2,6,-4,7,-6,void 0,6,8,8,6,8,4,7,2,6,1,5,-1,5,-3,6,-5,7,-6,9,-7],124:[8,4,25,4,-7],125:[14,5,25,7,24,8,23,9,21,9,19,8,17,7,16,6,14,6,12,8,10,void 0,7,24,8,22,8,20,7,18,6,17,5,15,5,13,6,11,10,9,6,7,5,5,5,3,6,1,7,0,8,-2,8,-4,7,-6,void 0,8,8,6,6,6,4,7,2,8,1,9,-1,9,-3,8,-5,7,-6,5,-7],126:[24,3,6,3,8,4,11,6,12,8,12,10,11,14,8,16,7,18,7,20,8,21,10,void 0,3,8,4,10,6,11,8,11,10,10,14,7,16,6,18,6,20,7,21,10,21,12]};const QL=ZL,KL={xOffset:0,yOffset:0,input:"?",align:"left",font:QL,height:14,lineSpacing:2.142857142857143,letterSpacing:1,extrudeOffset:0},JL=(e,t)=>{!t&&typeof e=="string"&&(e={input:e}),e=e||{};const r=Object.assign({},KL,e);return r.input=t||r.input,r};var lp=JL;const eR=lp,tR=(e,t)=>{const{xOffset:r,yOffset:n,input:s,font:o,height:a,extrudeOffset:i}=eR(e,t);let c=s.charCodeAt(0);(!c||!o[c])&&(c=63);const l=[].concat(o[c]),u=(a-i)/o.height,d=i/2,h=l.shift()*u,m=[];let $=[];for(let g=0,y=l.length;g<y;g+=2){const S=u*l[g]+r,N=u*l[g+1]+n+d;if(l[g]!==void 0){$.push([S,N]);continue}m.push($),$=[],g--}return $.length&&m.push($),{width:h,height:a,segments:m}};var fp=tR;const rR=fp,nR=lp,yd=(e,t)=>{const{x:r,y:n}=Object.assign({x:0,y:0},e||{}),s=t.segments;let o=null,a=null;for(let i=0,c=s.length;i<c;i++){o=s[i];for(let l=0,u=o.length;l<u;l++)a=o[l],o[l]=[a[0]+r,a[1]+n]}return t},sR=(e,t)=>{const{xOffset:r,yOffset:n,input:s,font:o,height:a,align:i,extrudeOffset:c,lineSpacing:l,letterSpacing:u}=nR(e,t);let[d,h]=[r,n],m,$,g,y,S,N,O={width:0,segments:[]};const L=[];let R=[],F=0;const z=d,J=()=>{L.push(O),F=Math.max(F,O.width),O={width:0,segments:[]}};for(m=0,$=s.length;m<$;m++){if(g=s[m],y=rR({xOffset:d,yOffset:h,font:o,height:a,extrudeOffset:c},g),g===`
`){d=z,h-=y.height*l,J();continue}S=y.width*u,O.width+=S,d+=S,g!==" "&&(O.segments=O.segments.concat(y.segments))}for(O.segments.length&&J(),m=0,$=L.length;m<$;m++)O=L[m],F>O.width&&(N=F-O.width,i==="right"?O=yd({x:N},O):i==="center"&&(O=yd({x:N/2},O))),R=R.concat(O.segments);return R};var oR=sR,aR={vectorChar:fp,vectorText:oR};const iR=Qe,cR=Ke,lR=ct,fR=e=>{let t;for(const r of e){let n=0;if(iR.isA(r)&&(n=1),cR.isA(r)&&(n=2),lR.isA(r)&&(n=3),t&&n!==t)return!1;t=n}return!0};var xo=fR;const uR=e=>e*.017453292519943295;var dR=uR;const hR=(e,t)=>e-t;var up=hR;const mR=(e,t,r)=>{let n=0,s=e.length;for(;s>n;){const o=Math.floor((n+s)/2),a=e[o];r(t,a)>0?n=o+1:s=o}e.splice(n,0,t)};var pR=mR;const{TAU:bd}=st,vR=(e,t,r)=>{const n=t>0?e*bd/t:0,s=r>0?bd/r:0;return Math.ceil(Math.max(n,s,4))};var gR=vR;const yR=e=>e*57.29577951308232;var bR=yR,dp={areAllShapesTheSameType:xo,degToRad:dR,flatten:We,fnNumberSort:up,insertSorted:pR,radiusToSegments:gR,radToDeg:bR};const _d=rt,_R=Qe,wR=(e,t)=>{if(t.vertices.length<4)return null;const r=[],n=t.vertices.filter((a,i)=>a[2]>0?(r.push(i),!0):!1);if(n.length!==2)throw new Error("Assertion failed: fromFakePolygon: not enough points found");const s=n.map(a=>{const i=Math.round(a[0]/e)*e+0,c=Math.round(a[1]/e)*e+0;return _d.fromValues(i,c)});if(_d.equals(s[0],s[1]))return null;const o=r[1]-r[0];if(o===1||o===3)o===1&&s.reverse();else throw new Error("Assertion failed: fromFakePolygon: unknown index ordering");return s},$R=(e,t)=>{const r=t.map(n=>wR(e,n)).filter(n=>n!==null);return _R.create(r)};var Zl=$R;const nn=ze,xR=Qe,ER=Ke,AR=ot,TR=(e,t,r)=>{const n=[nn.fromVec2(nn.create(),r[0],e),nn.fromVec2(nn.create(),r[1],e),nn.fromVec2(nn.create(),r[1],t),nn.fromVec2(nn.create(),r[0],t)];return AR.create(n)},SR=(e,t)=>{const n=xR.toSides(t).map(o=>TR(e.z0,e.z1,o));return ER.create(n)};var Ql=SR;const wd=ft,PR=rt,Mt=ze,Nn=function(e,t){arguments.length<2&&(t=Mt.orthogonal(Mt.create(),e)),this.v=Mt.normalize(Mt.create(),Mt.cross(Mt.create(),e,t)),this.u=Mt.cross(Mt.create(),this.v,e),this.plane=e,this.planeorigin=Mt.scale(Mt.create(),e,e[3])};Nn.GetCartesian=function(e,t){const r=e+"/"+t;let n,s;if(r==="X/Y")n=[0,0,1],s=[1,0,0];else if(r==="Y/-X")n=[0,0,1],s=[0,1,0];else if(r==="-X/-Y")n=[0,0,1],s=[-1,0,0];else if(r==="-Y/X")n=[0,0,1],s=[0,-1,0];else if(r==="-X/Y")n=[0,0,-1],s=[-1,0,0];else if(r==="-Y/-X")n=[0,0,-1],s=[0,-1,0];else if(r==="X/-Y")n=[0,0,-1],s=[1,0,0];else if(r==="Y/X")n=[0,0,-1],s=[0,1,0];else if(r==="X/Z")n=[0,-1,0],s=[1,0,0];else if(r==="Z/-X")n=[0,-1,0],s=[0,0,1];else if(r==="-X/-Z")n=[0,-1,0],s=[-1,0,0];else if(r==="-Z/X")n=[0,-1,0],s=[0,0,-1];else if(r==="-X/Z")n=[0,1,0],s=[-1,0,0];else if(r==="-Z/-X")n=[0,1,0],s=[0,0,-1];else if(r==="X/-Z")n=[0,1,0],s=[1,0,0];else if(r==="Z/X")n=[0,1,0],s=[0,0,1];else if(r==="Y/Z")n=[1,0,0],s=[0,1,0];else if(r==="Z/-Y")n=[1,0,0],s=[0,0,1];else if(r==="-Y/-Z")n=[1,0,0],s=[0,-1,0];else if(r==="-Z/Y")n=[1,0,0],s=[0,0,-1];else if(r==="-Y/Z")n=[-1,0,0],s=[0,-1,0];else if(r==="-Z/-Y")n=[-1,0,0],s=[0,0,-1];else if(r==="Y/-Z")n=[-1,0,0],s=[0,1,0];else if(r==="Z/Y")n=[-1,0,0],s=[0,0,1];else throw new Error("OrthoNormalBasis.GetCartesian: invalid combination of axis identifiers. Should pass two string arguments from [X,Y,Z,-X,-Y,-Z], being two different axes.");return new Nn(new Plane(new Vector3D(n),0),new Vector3D(s))};Nn.Z0Plane=function(){const e=new Plane(new Vector3D([0,0,1]),0);return new Nn(e,new Vector3D([1,0,0]))};Nn.prototype={getProjectionMatrix:function(){return wd.fromValues(this.u[0],this.v[0],this.plane[0],0,this.u[1],this.v[1],this.plane[1],0,this.u[2],this.v[2],this.plane[2],0,0,0,-this.plane[3],1)},getInverseProjectionMatrix:function(){const e=Mt.scale(Mt.create(),this.plane,this.plane[3]);return wd.fromValues(this.u[0],this.u[1],this.u[2],0,this.v[0],this.v[1],this.v[2],0,this.plane[0],this.plane[1],this.plane[2],0,e[0],e[1],e[2],1)},to2D:function(e){return PR.fromValues(Mt.dot(e,this.u),Mt.dot(e,this.v))},to3D:function(e){const t=Mt.scale(Mt.create(),this.u,e[0]),r=Mt.scale(Mt.create(),this.v,e[1]),n=Mt.add(t,t,this.planeorigin);return Mt.add(r,r,n)},line3Dto2D:function(e){const t=e.point,r=e.direction.plus(t),n=this.to2D(t),s=this.to2D(r);return Line2D.fromPoints(n,s)},line2Dto3D:function(e){const t=e.origin(),r=e.direction().plus(t),n=this.to3D(t),s=this.to3D(r);return Line3D.fromPoints(n,s)},transform:function(e){const t=this.plane.transform(e),r=this.u.transform(e),n=new Vector3D(0,0,0).transform(e),s=r.minus(n);return new Nn(t,s)}};var CR=Nn;const{EPS:Vr}=st,sn=Ul,_r=rt,MR=CR,cs=Cm,{insertSorted:OR,fnNumberSort:LR}=dp,$d=ot,RR=e=>{if(e.length<2)return e;const t=[],r=e.length,n=$d.plane(e[0]),s=new MR(n),o=[],a=[],i=new Map,c=new Map,l=new Map,u=10/Vr;for(let $=0;$<r;$++){const g=e[$];let y=[],S=g.vertices.length,N=-1;if(S>0){let O,L;for(let R=0;R<S;R++){let F=s.to2D(g.vertices[R]);const z=Math.floor(F[1]*u);let J;l.has(z)?J=l.get(z):l.has(z+1)?J=l.get(z+1):l.has(z-1)?J=l.get(z-1):(J=F[1],l.set(z,F[1])),F=_r.fromValues(F[0],J),y.push(F);const oe=F[1];(R===0||oe<O)&&(O=oe,N=R),(R===0||oe>L)&&(L=oe);let ve=c.get(oe);ve||(ve={},c.set(oe,ve)),ve[$]=!0}if(O>=L)y=[],S=0,N=-1;else{let R=i.get(O);R||(R=[],i.set(O,R)),R.push($)}}y.reverse(),N=S-N-1,o.push(y),a.push(N)}const d=[];c.forEach(($,g)=>d.push(g)),d.sort(LR);let h=[],m=[];for(let $=0;$<d.length;$++){const g=[],y=d[$],S=c.get(y);for(let O=0;O<h.length;++O){const L=h[O],R=L.polygonindex;if(S[R]){const F=o[R],z=F.length;let J=L.leftvertexindex,oe=L.rightvertexindex;for(;;){let le=J+1;if(le>=z&&(le=0),F[le][1]!==y)break;J=le}let ve=oe-1;if(ve<0&&(ve=z-1),F[ve][1]===y&&(oe=ve),J!==L.leftvertexindex&&J===oe)h.splice(O,1),--O;else{L.leftvertexindex=J,L.rightvertexindex=oe,L.topleft=F[J],L.topright=F[oe];let le=J+1;le>=z&&(le=0),L.bottomleft=F[le];let Pe=oe-1;Pe<0&&(Pe=z-1),L.bottomright=F[Pe]}}}let N;if($>=d.length-1)h=[],N=null;else{N=Number(d[$+1]);const O=.5*(y+N),L=i.get(y);for(const R in L){const F=L[R],z=o[F],J=z.length,oe=a[F];let ve=oe;for(;;){let Ne=ve+1;if(Ne>=J&&(Ne=0),z[Ne][1]!==y||Ne===oe)break;ve=Ne}let le=oe;for(;;){let Ne=le-1;if(Ne<0&&(Ne=J-1),z[Ne][1]!==y||Ne===ve)break;le=Ne}let Pe=ve+1;Pe>=J&&(Pe=0);let Xe=le-1;Xe<0&&(Xe=J-1);const ne={polygonindex:F,leftvertexindex:ve,rightvertexindex:le,topleft:z[ve],topright:z[le],bottomleft:z[Pe],bottomright:z[Xe]};OR(h,ne,(Ne,Ge)=>{const bt=cs(Ne.topleft,Ne.bottomleft,O),xt=cs(Ge.topleft,Ge.bottomleft,O);return bt>xt?1:bt<xt?-1:0})}}for(const O in h){const L=h[O];let R=cs(L.topleft,L.bottomleft,y);const F=_r.fromValues(R,y);R=cs(L.topright,L.bottomright,y);const z=_r.fromValues(R,y);R=cs(L.topleft,L.bottomleft,N);const J=_r.fromValues(R,N);R=cs(L.topright,L.bottomright,N);const oe=_r.fromValues(R,N),ve={topleft:F,topright:z,bottomleft:J,bottomright:oe,leftline:sn.fromPoints(sn.create(),F,J),rightline:sn.fromPoints(sn.create(),oe,z)};if(g.length>0){const le=g[g.length-1],Pe=_r.distance(ve.topleft,le.topright),Xe=_r.distance(ve.bottomleft,le.bottomright);Pe<Vr&&Xe<Vr&&(ve.topleft=le.topleft,ve.leftline=le.leftline,ve.bottomleft=le.bottomleft,g.splice(g.length-1,1))}g.push(ve)}if($>0){const O=new Set,L=new Set;for(let R=0;R<g.length;R++){const F=g[R];for(let z=0;z<m.length;z++)if(!L.has(z)){const J=m[z];if(_r.distance(J.bottomleft,F.topleft)<Vr&&_r.distance(J.bottomright,F.topright)<Vr){L.add(z);const oe=sn.direction(F.leftline),ve=sn.direction(J.leftline),le=oe[0]-ve[0],Pe=sn.direction(F.rightline),Xe=sn.direction(J.rightline),ne=Pe[0]-Xe[0],Ne=Math.abs(le)<Vr,Ge=Math.abs(ne)<Vr,bt=Ne||le>=0,xt=Ge||ne>=0;bt&&xt&&(F.outpolygon=J.outpolygon,F.leftlinecontinues=Ne,F.rightlinecontinues=Ge,O.add(z));break}}}for(let R=0;R<m.length;R++)if(!O.has(R)){const F=m[R];F.outpolygon.rightpoints.push(F.bottomright),_r.distance(F.bottomright,F.bottomleft)>Vr&&F.outpolygon.leftpoints.push(F.bottomleft),F.outpolygon.leftpoints.reverse();const J=F.outpolygon.rightpoints.concat(F.outpolygon.leftpoints).map(ve=>s.to3D(ve)),oe=$d.fromPointsAndPlane(J,n);oe.vertices.length&&t.push(oe)}}for(let O=0;O<g.length;O++){const L=g[O];L.outpolygon?(L.leftlinecontinues||L.outpolygon.leftpoints.push(L.topleft),L.rightlinecontinues||L.outpolygon.rightpoints.push(L.topright)):(L.outpolygon={leftpoints:[],rightpoints:[]},L.outpolygon.leftpoints.push(L.topleft),_r.distance(L.topleft,L.topright)>Vr&&L.outpolygon.rightpoints.push(L.topright))}m=g}return t};var FR=RR;const xd=Ke,NR=ot,{NEPS:GR}=st,kR=FR,DR=e=>{if(e.isRetesselated)return e;const t=xd.toPolygons(e).map((o,a)=>({vertices:o.vertices,plane:NR.plane(o),index:a})),r=BR(t),n=[];r.forEach(o=>{if(Array.isArray(o)){const a=kR(o);n.push(...a)}else n.push(o)});const s=xd.create(n);return s.isRetesselated=!0,s},BR=e=>{let t=[e];const r=[];for(let s=3;s>=0;s--){const o=[],a=s===3?15e-9:GR;t.forEach(i=>{i.sort(IR(s,a));let c=0;for(let l=1;l<i.length;l++)i[l].plane[s]-i[c].plane[s]>a&&(l-c===1?r.push(i[c]):o.push(i.slice(c,l)),c=l);i.length-c===1?r.push(i[c]):o.push(i.slice(c))}),t=o}const n=[];return t.forEach(s=>{s[0]&&(n[s[0].index]=s)}),r.forEach(s=>{n[s.index]=s}),n},IR=(e,t)=>(r,n)=>r.plane[e]-n.plane[e]>t?1:n.plane[e]-r.plane[e]>t?-1:0;var Eo=DR;const{EPS:ls}=st,Ed=Bn,VR=(e,t)=>{if(e.polygons.length===0||t.polygons.length===0)return!1;const r=Ed(e),n=r[0],s=r[1],o=Ed(t),a=o[0],i=o[1];return!(a[0]-s[0]>ls||n[0]-i[0]>ls||a[1]-s[1]>ls||n[1]-i[1]>ls||a[2]-s[2]>ls||n[2]-i[2]>ls)};var Kl=VR;const Ad=Nr,zR=ot;let UR=class El{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygontreenodes=[],this.parent=t}invert(){const t=[this];let r;for(let n=0;n<t.length;n++){r=t[n],r.plane&&(r.plane=Ad.flip(Ad.create(),r.plane)),r.front&&t.push(r.front),r.back&&t.push(r.back);const s=r.front;r.front=r.back,r.back=s}}clipPolygons(t,r){let n={node:this,polygontreenodes:t},s;const o=[];do{if(s=n.node,t=n.polygontreenodes,s.plane){const a=s.plane,i=[],c=[],l=r?i:c,u=t.length;for(let h=0;h<u;h++){const m=t[h];m.isRemoved()||m.splitByPlane(a,l,i,c,i)}s.front&&c.length>0&&o.push({node:s.front,polygontreenodes:c});const d=i.length;if(s.back&&d>0)o.push({node:s.back,polygontreenodes:i});else for(let h=0;h<d;h++)i[h].remove()}n=o.pop()}while(n!==void 0)}clipTo(t,r){let n=this;const s=[];do n.polygontreenodes.length>0&&t.rootnode.clipPolygons(n.polygontreenodes,r),n.front&&s.push(n.front),n.back&&s.push(n.back),n=s.pop();while(n!==void 0)}addPolygonTreeNodes(t){let r={node:this,polygontreenodes:t};const n=[];do{const s=r.node,o=r.polygontreenodes;if(o.length===0){r=n.pop();continue}if(!s.plane){let l=0;l=Math.floor(o.length/2);const u=o[l].getPolygon();s.plane=zR.plane(u)}const a=[],i=[],c=o.length;for(let l=0;l<c;++l)o[l].splitByPlane(s.plane,s.polygontreenodes,i,a,i);a.length>0&&(s.front||(s.front=new El(s)),c===a.length&&i.length===0?s.front.polygontreenodes=a:n.push({node:s.front,polygontreenodes:a})),i.length>0&&(s.back||(s.back=new El(s)),c===i.length&&a.length===0?s.back.polygontreenodes=i:n.push({node:s.back,polygontreenodes:i})),r=n.pop()}while(r!==void 0)}};var qR=UR;const fs=ze,XR=(e,t,r)=>{const n=fs.subtract(fs.create(),r,t);let s=(e[3]-fs.dot(e,t))/fs.dot(e,n);return Number.isNaN(s)&&(s=0),s>1&&(s=1),s<0&&(s=0),fs.scale(n,n,s),fs.add(n,t,n),n};var jR=XR;const{EPS:ya}=st,HR=Nr,ba=ze,qc=ot,YR=jR,WR=(e,t)=>{const r={type:null,front:null,back:null},n=t.vertices,s=n.length,o=qc.plane(t);if(HR.equals(o,e))r.type=0;else{let a=!1,i=!1;const c=[],l=-ya;for(let u=0;u<s;u++){const d=ba.dot(e,n[u])-e[3],h=d<l;c.push(h),d>ya&&(a=!0),d<l&&(i=!0)}if(!a&&!i){const u=ba.dot(e,o);r.type=u>=0?0:1}else if(!i)r.type=2;else if(!a)r.type=3;else{r.type=4;const u=[],d=[];let h=c[0];for(let $=0;$<s;$++){const g=n[$];let y=$+1;y>=s&&(y=0);const S=c[y];if(h===S)h?d.push(g):u.push(g);else{const N=n[y],O=YR(e,g,N);h?(d.push(g),d.push(O),u.push(O)):(u.push(g),u.push(O),d.push(O))}h=S}const m=ya*ya;if(d.length>=3){let $=d[d.length-1];for(let g=0;g<d.length;g++){const y=d[g];ba.squaredDistance(y,$)<m&&(d.splice(g,1),g--),$=y}}if(u.length>=3){let $=u[u.length-1];for(let g=0;g<u.length;g++){const y=u[g];ba.squaredDistance(y,$)<m&&(u.splice(g,1),g--),$=y}}u.length>=3&&(r.front=qc.fromPointsAndPlane(u,o)),d.length>=3&&(r.back=qc.fromPointsAndPlane(d,o))}}return r};var ZR=WR;const{EPS:QR}=st,KR=ze,Td=ot,JR=ZR;let eF=class hp{constructor(t,r){this.parent=t,this.children=[],this.polygon=r,this.removed=!1}addPolygons(t){if(!this.isRootNode())throw new Error("Assertion failed");const r=this;t.forEach(n=>{r.addChild(n)})}remove(){if(!this.removed){this.removed=!0,this.polygon=null;const t=this.parent.children,r=t.indexOf(this);if(r<0)throw new Error("Assertion failed");t.splice(r,1),this.parent.recursivelyInvalidatePolygon()}}isRemoved(){return this.removed}isRootNode(){return!this.parent}invert(){if(!this.isRootNode())throw new Error("Assertion failed");this.invertSub()}getPolygon(){if(!this.polygon)throw new Error("Assertion failed");return this.polygon}getPolygons(t){let r=[this];const n=[r];let s,o,a,i;for(s=0;s<n.length;++s)for(r=n[s],o=0,a=r.length;o<a;o++)i=r[o],i.polygon?t.push(i.polygon):i.children.length>0&&n.push(i.children)}splitByPlane(t,r,n,s,o){if(this.children.length){const a=[this.children];let i,c,l,u,d;for(i=0;i<a.length;i++)for(d=a[i],c=0,l=d.length;c<l;c++)u=d[c],u.children.length>0?a.push(u.children):u._splitByPlane(t,r,n,s,o)}else this._splitByPlane(t,r,n,s,o)}_splitByPlane(t,r,n,s,o){const a=this.polygon;if(a){const i=Td.measureBoundingSphere(a),c=i[3]+QR,l=i,u=KR.dot(t,l)-t[3];if(u>c)s.push(this);else if(u<-c)o.push(this);else{const d=JR(t,a);switch(d.type){case 0:r.push(this);break;case 1:n.push(this);break;case 2:s.push(this);break;case 3:o.push(this);break;case 4:if(d.front){const h=this.addChild(d.front);s.push(h)}if(d.back){const h=this.addChild(d.back);o.push(h)}break}}}}addChild(t){const r=new hp(this,t);return this.children.push(r),r}invertSub(){let t=[this];const r=[t];let n,s,o,a;for(n=0;n<r.length;n++)for(t=r[n],s=0,o=t.length;s<o;s++)a=t[s],a.polygon&&(a.polygon=Td.invert(a.polygon)),a.children.length>0&&r.push(a.children)}recursivelyInvalidatePolygon(){this.polygon=null,this.parent&&this.parent.recursivelyInvalidatePolygon()}clear(){let t=[this];const r=[t];for(let n=0;n<r.length;++n){t=r[n];const s=t.length;for(let o=0;o<s;o++){const a=t[o];a.polygon&&(a.polygon=null),a.parent&&(a.parent=null),a.children.length>0&&r.push(a.children),a.children=[]}}}toString(){let t="",r=[this];const n=[r];let s,o,a,i;for(s=0;s<n.length;++s){r=n[s];const c=" ".repeat(s);for(o=0,a=r.length;o<a;o++)i=r[o],t+=`${c}PolygonTreeNode (${i.isRootNode()}): ${i.children.length}`,i.polygon?t+=`
 ${c}polygon: ${i.polygon.vertices}
`:t+=`
`,i.children.length>0&&n.push(i.children)}return t}};var tF=eF;const rF=qR,nF=tF;let sF=class{constructor(t){this.polygonTree=new nF,this.rootnode=new rF(null),t&&this.addPolygons(t)}invert(){this.polygonTree.invert(),this.rootnode.invert()}clipTo(t,r=!1){this.rootnode.clipTo(t,r)}allPolygons(){const t=[];return this.polygonTree.getPolygons(t),t}addPolygons(t){const r=new Array(t.length);for(let n=0;n<t.length;n++)r[n]=this.polygonTree.addChild(t[n]);this.rootnode.addPolygonTreeNodes(r)}clear(){this.polygonTree.clear()}toString(){return"Tree: "+this.polygonTree.toString("")}};var oF=sF,Jl={Tree:oF};const _a=Ke,aF=Kl,{Tree:Sd}=Jl,iF=(e,t)=>{if(!aF(e,t))return _a.create();const r=new Sd(_a.toPolygons(e)),n=new Sd(_a.toPolygons(t));r.invert(),n.clipTo(r),n.invert(),r.clipTo(n),n.clipTo(r),r.addPolygons(n.allPolygons()),r.invert();const s=r.allPolygons();return _a.create(s)};var cF=iF;const lF=We,fF=Eo,uF=cF,dF=(...e)=>{e=lF(e);let t=e.shift();return e.forEach(r=>{t=uF(t,r)}),t=fF(t),t};var mp=dF;const hF=We,mF=Ke,pF=cn,vF=Zl,gF=Ql,yF=mp,bF=(...e)=>{e=hF(e);const t=e.map(s=>gF({z0:-1,z1:1},s)),r=yF(t),n=pF(r);return vF(n,mF.toPolygons(r))};var _F=bF;const wF=We,$F=xo,xF=Qe,EF=Ke,AF=_F,TF=mp,SF=(...e)=>{if(e=wF(e),e.length===0)throw new Error("wrong number of arguments");if(!$F(e))throw new Error("only intersect of the types are supported");const t=e[0];return xF.isA(t)?AF(e):EF.isA(t)?TF(e):t};var PF=SF;const Xc=ze,CF=cn,Pd=Ke,MF=e=>e.sort((t,r)=>t-r).filter((t,r,n)=>!r||t!==n[r-1]),OF=(e,t,r)=>{const n=`${t}`,s=e.get(n);s===void 0?e.set(n,[r]):s.push(r)},LF=(e,t)=>{const r=`${t}`;return e.get(r)},RF=e=>{const t=CF(e),r=Pd.toPolygons(e),n=r.length,s=new Map,o=Xc.create();r.forEach((u,d)=>{u.vertices.forEach(h=>{OF(s,Xc.snap(o,h,t),d)})});const a=r.map(u=>{let d=[];return u.vertices.forEach(h=>{d=d.concat(LF(s,Xc.snap(o,h,t)))}),{e:1,d:MF(d)}});s.clear();let i=0;const c=a.length;for(let u=0;u<c;u++){const d=a[u];if(d.e>0){const h=new Array(n);h[u]=!0;do i=0,h.forEach((m,$)=>{const g=a[$];if(g.e>0){g.e=-1;for(let y=0;y<g.d.length;y++)h[g.d[y]]=!0;i++}});while(i>0);d.indexes=h}}const l=[];for(let u=0;u<c;u++)if(a[u].indexes){const d=[];a[u].indexes.forEach((h,m)=>d.push(r[m])),l.push(Pd.create(d))}return l};var FF=RF;const NF=We,GF=Ke,kF=FF,DF=(...e)=>{if(e=NF(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>GF.isA(r)?kF(r):r);return t.length===1?t[0]:t};var BF=DF;const wa=Ke,IF=Kl,{Tree:Cd}=Jl,VF=(e,t)=>{if(!IF(e,t))return wa.clone(e);const r=new Cd(wa.toPolygons(e)),n=new Cd(wa.toPolygons(t));r.invert(),r.clipTo(n),n.clipTo(r,!0),r.addPolygons(n.allPolygons()),r.invert();const s=r.allPolygons();return wa.create(s)};var zF=VF;const UF=We,qF=Eo,XF=zF,jF=(...e)=>{e=UF(e);let t=e.shift();return e.forEach(r=>{t=XF(t,r)}),t=qF(t),t};var pp=jF;const HF=We,YF=Ke,WF=cn,ZF=Zl,QF=Ql,KF=pp,JF=(...e)=>{e=HF(e);const t=e.map(s=>QF({z0:-1,z1:1},s)),r=KF(t),n=WF(r);return ZF(n,YF.toPolygons(r))};var eN=JF;const tN=We,rN=xo,nN=Qe,sN=Ke,oN=eN,aN=pp,iN=(...e)=>{if(e=tN(e),e.length===0)throw new Error("wrong number of arguments");if(!rN(e))throw new Error("only subtract of the types are supported");const t=e[0];return nN.isA(t)?oN(e):sN.isA(t)?aN(e):t};var cN=iN;const ys=Ke,lN=Kl,{Tree:Md}=Jl,fN=(e,t)=>{if(!lN(e,t))return uN(e,t);const r=new Md(ys.toPolygons(e)),n=new Md(ys.toPolygons(t));r.clipTo(n,!1),n.clipTo(r),n.invert(),n.clipTo(r),n.invert();const s=r.allPolygons().concat(n.allPolygons());return ys.create(s)},uN=(e,t)=>{let r=ys.toPolygons(e);return r=r.concat(ys.toPolygons(t)),ys.create(r)};var vp=fN;const dN=We,hN=Eo,mN=vp,pN=(...e)=>{e=dN(e);let t;for(t=1;t<e.length;t+=2)e.push(mN(e[t-1],e[t]));let r=e[t-1];return r=hN(r),r};var gp=pN;const vN=We,gN=Ke,yN=cn,bN=Zl,_N=Ql,wN=gp,$N=(...e)=>{e=vN(e);const t=e.map(s=>_N({z0:-1,z1:1},s)),r=wN(t),n=yN(r);return bN(n,gN.toPolygons(r))};var yp=$N;const xN=We,EN=xo,AN=Qe,TN=Ke,SN=yp,PN=gp,CN=(...e)=>{if(e=xN(e),e.length===0)throw new Error("wrong number of arguments");if(!EN(e))throw new Error("only unions of the same type are supported");const t=e[0];return AN.isA(t)?SN(e):TN.isA(t)?PN(e):t};var ef=CN,MN={intersect:PF,scission:BF,subtract:cN,union:ef};const{EPS:ON,TAU:LN}=st,Od=Mm,to=Ul,yt=rt,RN=Wa,FN=(e,t)=>{const r={delta:1,corners:"edge",closed:!1,segments:16};let{delta:n,corners:s,closed:o,segments:a}=Object.assign({},r,e);if(Math.abs(n)<ON)return t;let i=e.closed?RN(t):1;i===0&&(i=1);const c=i>0&&n>=0||i<0&&n<0;n=Math.abs(n);let l=null,u=[];const d=[],h=yt.create(),m=t.length;for(let $=0;$<m;$++){const g=($+1)%m,y=t[$],S=t[g];c?yt.subtract(h,y,S):yt.subtract(h,S,y),yt.normal(h,h),yt.normalize(h,h),yt.scale(h,h,n);const N=yt.add(yt.create(),y,h),O=yt.add(yt.create(),S,h),L=[N,O];if(l!=null&&(o||!o&&g!==0)){const R=Od(l[0],l[1],L[0],L[1]);R?(u.pop(),L[0]=R):d.push({c:y,s0:l,s1:L})}l=[N,O],!(g===0&&!o)&&(u.push(L[0]),u.push(L[1]))}if(o&&l!=null){const $=u[0],g=u[1],y=Od(l[0],l[1],$,g);if(y)u[0]=y,u.pop();else{const S=t[0],N=[$,g];d.push({c:S,s0:l,s1:N})}}if(s==="edge"){const $=new Map;u.forEach((S,N)=>$.set(S,N));const g=to.create(),y=to.create();d.forEach(S=>{to.fromPoints(g,S.s0[0],S.s0[1]),to.fromPoints(y,S.s1[0],S.s1[1]);const N=to.intersectPointOfLines(g,y);if(Number.isFinite(N[0])&&Number.isFinite(N[1])){const O=S.s0[1],L=$.get(O);u[L]=N,u[(L+1)%u.length]=void 0}else{const O=S.s1[0],L=$.get(O);u[L]=void 0}}),u=u.filter(S=>S!==void 0)}if(s==="round"){let $=Math.floor(a/4);const g=yt.create();d.forEach(y=>{let S=yt.angle(yt.subtract(g,y.s1[0],y.c));if(S-=yt.angle(yt.subtract(g,y.s0[1],y.c)),c&&S<0&&(S=S+Math.PI,S<0&&(S=S+Math.PI)),!c&&S>0&&(S=S-Math.PI,S>0&&(S=S-Math.PI)),S!==0){$=Math.floor(a*(Math.abs(S)/LN));const N=S/$,O=yt.angle(yt.subtract(g,y.s0[1],y.c)),L=[];for(let R=1;R<$;R++){const F=O+N*R,z=yt.fromAngleRadians(yt.create(),F);yt.scale(z,z,n),yt.add(z,z,y.c),L.push(z)}if(L.length>0){const R=y.s0[1];let F=u.findIndex(z=>yt.equals(R,z));F=(F+1)%u.length,u.splice(F,0,...L)}}else{const N=y.s1[0],O=u.findIndex(L=>yt.equals(N,L));u.splice(O,1)}})}return u};var ri=FN;const $a=Qe,NN=ri,GN=(e,t)=>{const r={delta:1,corners:"edge",segments:16},{delta:n,corners:s,segments:o}=Object.assign({},r,e);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const c=$a.toOutlines(t).map(l=>(e={delta:n,corners:s,closed:!0,segments:o},NN(e,l))).reduce((l,u)=>l.concat($a.toSides($a.fromPoints(u))),[]);return $a.create(c)};var kN=GN;const Ld=ft,DN=ze,BN=Ke,ro=ot,IN=(e,t)=>{DN.dot(ro.plane(t),e)>0&&(t=ro.invert(t));const n=[t],s=ro.transform(Ld.fromTranslation(Ld.create(),e),t),o=t.vertices.length;for(let a=0;a<o;a++){const i=a<o-1?a+1:0,c=ro.create([t.vertices[a],s.vertices[a],s.vertices[i],t.vertices[i]]);n.push(c)}return n.push(ro.invert(s)),BN.create(n)};var VN=IN;const{EPS:zN,TAU:jc}=st,Rd=ft,ut=ze,UN=up,Hc=Ke,Cn=ot,qN=ep,XN=Eo,Yc=vp,jN=VN,HN=(e,t,r)=>{const n=t.toString();if(e.has(n))e.get(n)[1].push(r);else{const s=[t,[r]];e.set(n,s)}},YN=(e,t,r)=>{const n=t[0].toString(),s=t[1].toString(),o=n<s?`${n},${s}`:`${s},${n}`;if(e.has(o))e.get(o)[1].push(r);else{const a=[t,[r]];e.set(o,a)}},Wc=(e,t)=>{e.findIndex(n=>n===t)<0&&e.push(t)},WN=(e,t)=>{const r={delta:1,segments:12},{delta:n,segments:s}=Object.assign({},r,e);let o=Hc.create();const a=new Map,i=new Map,c=ut.create(),l=ut.create();return Hc.toPolygons(t).forEach((d,h)=>{const m=ut.scale(ut.create(),Cn.plane(d),2*n),$=Cn.transform(Rd.fromTranslation(Rd.create(),ut.scale(ut.create(),m,-.5)),d),g=jN(m,$);o=Yc(o,g);const y=d.vertices;for(let S=0;S<y.length;S++){HN(a,y[S],Cn.plane(d));const N=(S+1)%y.length,O=[y[S],y[N]];YN(i,O,Cn.plane(d))}}),i.forEach(d=>{const h=d[0],m=d[1],$=h[0],g=h[1],y=ut.subtract(ut.create(),g,$);ut.normalize(y,y);const S=m[0],N=ut.cross(ut.create(),S,y);let O=[];for(let le=0;le<s;le++)Wc(O,le*jc/s);for(let le=0,Pe=m.length;le<Pe;le++){const Xe=m[le],ne=ut.dot(N,Xe),Ne=ut.dot(S,Xe);let Ge=Math.atan2(ne,Ne);Ge<0&&(Ge+=jc),Wc(O,Ge),Ge=Math.atan2(-ne,-Ne),Ge<0&&(Ge+=jc),Wc(O,Ge)}O=O.sort(UN);const L=O.length;let R,F;const z=[],J=[],oe=[];for(let le=-1;le<L;le++){const Pe=O[le<0?le+L:le],Xe=Math.sin(Pe),ne=Math.cos(Pe);ut.scale(c,S,ne*n),ut.scale(l,N,Xe*n),ut.add(c,c,l);const Ne=ut.add(ut.create(),$,c),Ge=ut.add(ut.create(),g,c);let bt=!1;if(le>=0&&ut.distance(Ne,R)<zN&&(bt=!0),!bt){if(le>=0){z.push(Ne),J.push(Ge);const xt=[F,Ge,Ne,R],vr=Cn.create(xt);oe.push(vr)}R=Ne,F=Ge}}J.reverse(),oe.push(Cn.create(z)),oe.push(Cn.create(J));const ve=Hc.create(oe);o=Yc(o,ve)}),a.forEach(d=>{const h=d[0],m=d[1],$=m[0];let g=null,y=0;for(let L=1;L<m.length;L++){const R=m[L],F=ut.cross(c,$,R),z=ut.length(F);z>.05&&z>y&&(y=z,g=R)}g||(g=ut.orthogonal(c,$));const S=ut.cross(c,$,g);ut.normalize(S,S);const N=ut.cross(l,S,$),O=qN({center:[h[0],h[1],h[2]],radius:n,segments:s,axes:[$,S,N]});o=Yc(o,O)}),XN(o)};var ZN=WN;const QN=Ke,KN=ef,JN=ZN,eG=(e,t)=>{const r={delta:1,corners:"round",segments:12},{delta:n,corners:s,segments:o}=Object.assign({},r,e);if(s!=="round")throw new Error('corners must be "round" for 3D geometries');if(QN.toPolygons(t).length===0)throw new Error("the given geometry cannot be empty");e={delta:n,corners:s,segments:o};const i=JN(e,t);return KN(t,i)};var tG=eG;const rG=Wa,Wt=rt,ms=Qe,uo=ct,Fd=ri,nG=e=>{let{external:t,internal:r}=e;rG(t)<0?t=t.reverse():r=r.reverse();const n=uo.fromPoints({closed:!0},t),s=uo.fromPoints({closed:!0},r),o=ms.toSides(ms.fromPoints(uo.toPoints(n))),a=ms.toSides(ms.fromPoints(uo.toPoints(s)));return o.push(...a),ms.create(o)},sG=(e,t,r,n)=>{const{points:s,external:o,internal:a}=e,i=Math.floor(t/2),c=[],l=[];if(r==="round"&&i>0){const d=Math.PI/i,h=s[s.length-1],m=Wt.angle(Wt.subtract(Wt.create(),o[o.length-1],h)),$=s[0],g=Wt.angle(Wt.subtract(Wt.create(),a[0],$));for(let y=1;y<i;y++){let S=m+d*y,N=Wt.fromAngleRadians(Wt.create(),S);Wt.scale(N,N,n),Wt.add(N,N,h),c.push(N),S=g+d*y,N=Wt.fromAngleRadians(Wt.create(),S),Wt.scale(N,N,n),Wt.add(N,N,$),l.push(N)}}const u=[];return u.push(...o,...c,...a.reverse(),...l),ms.fromPoints(u)},oG=(e,t)=>{e=Object.assign({},{delta:1,corners:"edge",segments:16},e);const{delta:n,corners:s,segments:o}=e;if(n<=0)throw new Error("the given delta must be positive for paths");if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const a=t.isClosed,i=uo.toPoints(t);if(i.length===0)throw new Error("the given geometry cannot be empty");const c={points:i,external:Fd({delta:n,corners:s,segments:o,closed:a},i),internal:Fd({delta:-n,corners:s,segments:o,closed:a},i)};return t.isClosed?nG(c):sG(c,o,s,n)};var aG=oG;const iG=We,cG=Qe,lG=Ke,fG=ct,uG=kN,dG=tG,hG=aG,mG=(e,...t)=>{if(t=iG(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>fG.isA(n)?hG(e,n):cG.isA(n)?uG(e,n):lG.isA(n)?dG(e,n):n);return r.length===1?r[0]:r};var tf=mG;const xa=Qe,Nd=Dl,pG=ri,vG=(e,t)=>{const r={delta:1,corners:"edge",segments:0},{delta:n,corners:s,segments:o}=Object.assign({},r,e);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');const a=xa.toOutlines(t),c=a.map(l=>(e={delta:a.reduce((h,m)=>h+Nd.arePointsInside(l,Nd.create(m)),0)%2===0?n:-n,corners:s,closed:!0,segments:o},pG(e,l))).reduce((l,u)=>l.concat(xa.toSides(xa.fromPoints(u))),[]);return xa.create(c)};var gG=vG;const Gd=ct,yG=ri,bG=(e,t)=>{const r={delta:1,corners:"edge",closed:t.isClosed,segments:16},{delta:n,corners:s,closed:o,segments:a}=Object.assign({},r,e);if(!(s==="edge"||s==="chamfer"||s==="round"))throw new Error('corners must be "edge", "chamfer", or "round"');e={delta:n,corners:s,closed:o,segments:a};const i=yG(e,Gd.toPoints(t));return Gd.fromPoints({closed:o},i)};var _G=bG;const wG=We,$G=Qe,xG=ct,EG=gG,AG=_G,TG=(e,...t)=>{if(t=wG(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>xG.isA(n)?AG(e,n):$G.isA(n)?EG(e,n):n);return r.length===1?r[0]:r};var SG=TG,PG={expand:tf,offset:SG};const no=ft,Zc=ze,CG=Qe,Qc=As,MG=Ja,OG=(e,t)=>{const r={offset:[0,0,1],twistAngle:0,twistSteps:12,repair:!0};let{offset:n,twistAngle:s,twistSteps:o,repair:a}=Object.assign({},r,e);if(o<1)throw new Error("twistSteps must be 1 or more");s===0&&(o=1);const i=Zc.clone(n),c=CG.toSides(t);if(c.length===0)throw new Error("the given geometry cannot be empty");const l=Qc.fromSides(c);i[2]<0&&Qc.reverse(l,l);const u=no.create(),d=(h,m,$)=>{const g=m/o*s,y=Zc.scale(Zc.create(),i,m/o);return no.multiply(u,no.fromZRotation(u,g),no.fromTranslation(no.create(),y)),Qc.transform(u,$)};return e={numberOfSlices:o+1,capStart:!0,capEnd:!0,repair:a,callback:d},MG(e,l)};var ni=OG;const LG=Qe,RG=ct,FG=ni,NG=(e,t)=>{if(!t.isClosed)throw new Error("extruded path must be closed");const r=RG.toPoints(t),n=LG.fromPoints(r);return FG(e,n)};var GG=NG;const kG=We,DG=Qe,BG=ct,IG=ni,VG=GG,zG=(e,...t)=>{const r={height:1,twistAngle:0,twistSteps:1,repair:!0},{height:n,twistAngle:s,twistSteps:o,repair:a}=Object.assign({},r,e);if(t=kG(t),t.length===0)throw new Error("wrong number of arguments");e={offset:[0,0,n],twistAngle:s,twistSteps:o,repair:a};const i=t.map(c=>BG.isA(c)?VG(e,c):DG.isA(c)?IG(e,c):c);return i.length===1?i[0]:i};var UG=zG;const qG=ct,XG=tf,jG=ni,HG=(e,t)=>{const r={size:1,height:1},{size:n,height:s}=Object.assign({},r,e);if(e.delta=n,e.offset=[0,0,s],qG.toPoints(t).length===0)throw new Error("the given geometry cannot be empty");const a=XG(e,t);return jG(e,a)};var YG=HG;const{area:WG}=wo,Kc=Qe,ZG=ct,QG=tf,KG=ni,JG=(e,t)=>{const r={size:1,height:1},{size:n,height:s}=Object.assign({},r,e);e.delta=n,e.offset=[0,0,s];const o=Kc.toOutlines(t);if(o.length===0)throw new Error("the given geometry cannot be empty");const i=o.map(l=>(WG(l)<0&&l.reverse(),QG(e,ZG.fromPoints({closed:!0},l)))).reduce((l,u)=>l.concat(Kc.toSides(u)),[]),c=Kc.create(i);return KG(e,c)};var ek=JG;const tk=We,rk=Qe,nk=ct,sk=YG,ok=ek,ak=(e,...t)=>{const r={size:1,height:1},{size:n,height:s}=Object.assign({},r,e);if(t=tk(t),t.length===0)throw new Error("wrong number of arguments");if(n<=0)throw new Error("size must be positive");if(s<=0)throw new Error("height must be positive");const o=t.map(a=>nk.isA(a)?sk(e,a):rk.isA(a)?ok(e,a):a);return o.length===1?o[0]:o};var ik=ak;const{TAU:so}=st,Jc=As,Cr=ft,ck=Ja,lk=Qe,fk=(e,t)=>{const r={angle:so,startAngle:0,pitch:10,endOffset:0,segmentsPerRotation:32},{angle:n,endOffset:s,segmentsPerRotation:o,startAngle:a}=Object.assign({},r,e);let i;if(!e.pitch&&e.height?i=e.height/(n/so):i=e.pitch?e.pitch:r.pitch,o<3)throw new Error("The number of segments per rotation needs to be at least 3.");const l=lk.toSides(t);if(l.length===0)throw new Error("the given geometry cannot be empty");const u=l.filter(S=>S[0][0]>=0);let d=Jc.fromSides(l);u.length===0&&(d=Jc.reverse(d));const h=Math.round(o/so*Math.abs(n)),m=h>=2?h:2,$=Cr.create();let g;const y=(S,N,O)=>{const L=a+n/m*N,R=s/m*N,F=(L-a)/so*i;return Cr.multiply($,Cr.fromTranslation(Cr.create(),[R,0,F*Math.sign(n)]),Cr.fromXRotation(Cr.create(),-so/4*Math.sign(n))),g=Cr.create(),Cr.multiply(g,Cr.fromZRotation(Cr.create(),L),$),Jc.transform(g,O)};return ck({numberOfSlices:m+1,callback:y},d)};var uk=fk;const dk=We,kd=zl,el=Nr,Dd=ft,Bd=Qe,bp=Ke,us=ot,hk=cn,mk=yp,pk=(e,t)=>{const r=el.fromNormalAndPoint(el.create(),e.axis,e.origin);if(Number.isNaN(r[0])||Number.isNaN(r[1])||Number.isNaN(r[2])||Number.isNaN(r[3]))throw new Error("project: invalid axis or origin");const n=hk(t),s=n*n*Math.sqrt(3)/4;if(n===0)return Bd.create();const o=bp.toPolygons(t);let a=[];for(let c=0;c<o.length;c++){const l=o[c].vertices.map(h=>el.projectionOfPoint(r,h)),u=us.create(l),d=us.plane(u);kd(r,d)&&(us.measureArea(u)<s||a.push(u))}if(!kd(r,[0,0,1])){const c=Dd.fromVectorRotation(Dd.create(),r,[0,0,1]);a=a.map(l=>us.transform(c,l))}a=a.sort((c,l)=>us.measureArea(l)-us.measureArea(c));const i=a.map(c=>Bd.fromPoints(c.vertices));return mk(i)},vk=(e,...t)=>{const r={axis:[0,0,1],origin:[0,0,0]},{axis:n,origin:s}=Object.assign({},r,e);if(t=dk(t),t.length===0)throw new Error("wrong number of arguments");e={axis:n,origin:s};const o=t.map(a=>bp.isA(a)?pk(e,a):a);return o.length===1?o[0]:o};var gk=vk,yk={extrudeFromSlices:Ja,extrudeLinear:UG,extrudeRectangular:ik,extrudeRotate:cp,extrudeHelical:uk,project:gk,slice:As};const Id=rt,bk=e=>{let t=Id.fromValues(1/0,1/0);e.forEach(s=>{(s[1]<t[1]||s[1]===t[1]&&s[0]<t[0])&&(t=s)});const r=[];e.forEach(s=>{const o=wk(s[1]-t[1],s[0]-t[0]),a=Id.squaredDistance(s,t);r.push({point:s,angle:o,distSq:a})}),r.sort((s,o)=>s.angle!==o.angle?s.angle-o.angle:s.distSq-o.distSq);const n=[];return r.forEach(s=>{let o=n.length;for(;o>1&&_k(n[o-2],n[o-1],s.point)<=Number.EPSILON;)n.pop(),o=n.length;n.push(s.point)}),n},_k=(e,t,r)=>(t[0]-e[0])*(r[1]-e[1])-(t[1]-e[1])*(r[0]-e[0]),wk=(e,t)=>e===0&&t===0?-1/0:-t/e;var _p=bk;const Vd=Qe,zd=Ke,Ud=ct,$k=e=>{const t=new Set,r=[],n=s=>{const o=s.toString();t.has(o)||(r.push(s),t.add(o))};return e.forEach(s=>{Vd.isA(s)?Vd.toPoints(s).forEach(n):zd.isA(s)?zd.toPoints(s).forEach(o=>o.forEach(n)):Ud.isA(s)&&Ud.toPoints(s).forEach(n)}),r};var rf=$k;const xk=We,Ek=ct,Ak=_p,Tk=rf,Sk=(...e)=>{e=xk(e);const t=Tk(e),r=Ak(t);return Ek.fromPoints({closed:!0},r)};var Pk=Sk;const Ck=We,qd=Qe,Mk=_p,Ok=rf,Lk=(...e)=>{e=Ck(e);const t=Ok(e),r=Mk(t);return r.length<3?qd.create():qd.fromPoints(r)};var Rk=Lk;const Fk=bo,Xd=za,jd=Yh,Nk=(e,t,r)=>{const n=[],s=[],o=[];Xd(n,r,t),Xd(s,e,t);const a=jd(Fk(o,s,n)),i=jd(n);if(i===0)throw Error("a and b are the same point");return a/i},Gk=(e,t,r)=>Math.sqrt(Nk(e,t,r));var kk=Gk;const Dk=bo,Bk=Ll,Hd=za,Ik=(e,t,r,n)=>{const s=[0,0,0];return Hd(e,t,r),Hd(s,r,n),Dk(e,e,s),Bk(e,e)};var Vk=Ik;let zk=class{constructor(){this.head=null,this.tail=null}clear(){this.head=this.tail=null}insertBefore(t,r){r.prev=t.prev,r.next=t,r.prev?r.prev.next=r:this.head=r,t.prev=r}insertAfter(t,r){r.prev=t,r.next=t.next,r.next?r.next.prev=r:this.tail=r,t.next=r}add(t){this.head?this.tail.next=t:this.head=t,t.prev=this.tail,t.next=null,this.tail=t}addAll(t){for(this.head?this.tail.next=t:this.head=t,t.prev=this.tail;t.next;)t=t.next;this.tail=t}remove(t){t.prev?t.prev.next=t.next:this.head=t.next,t.next?t.next.prev=t.prev:this.tail=t.prev}removeChain(t,r){t.prev?t.prev.next=r.next:this.head=r.next,r.next?r.next.prev=t.prev:this.tail=t.prev}first(){return this.head}isEmpty(){return!this.head}};var Uk=zk;let qk=class{constructor(t,r){this.point=t,this.index=r,this.next=null,this.prev=null,this.face=null}};var Xk=qk;const jk=zh,Hk=Hh;let Yk=class{constructor(t,r){this.vertex=t,this.face=r,this.next=null,this.prev=null,this.opposite=null}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){return this.tail()?jk(this.tail().point,this.head().point):-1}lengthSquared(){return this.tail()?Hk(this.tail().point,this.head().point):-1}setOpposite(t){this.opposite=t,t.opposite=this}};var Wk=Yk;const tl=Ih,Zk=Vh,Qk=bo,rl=Ia,Kk=Uh,Jk=Ll,Ea=jh,nl=za,sl=Wk,wp=0,eD=1,Al=2;let tD=class $p{constructor(){this.normal=[],this.centroid=[],this.offset=0,this.outside=null,this.mark=wp,this.edge=null,this.nVertices=0}getEdge(t){if(typeof t!="number")throw Error("requires a number");let r=this.edge;for(;t>0;)r=r.next,t-=1;for(;t<0;)r=r.prev,t+=1;return r}computeNormal(){const t=this.edge,r=t.next;let n=r.next;const s=nl([],r.head().point,t.head().point),o=[],a=[];for(this.nVertices=2,this.normal=[0,0,0];n!==t;)Zk(a,s),nl(s,n.head().point,t.head().point),tl(this.normal,this.normal,Qk(o,a,s)),n=n.next,this.nVertices+=1;this.area=Kk(this.normal),this.normal=Ea(this.normal,this.normal,1/this.area)}computeNormalMinArea(t){if(this.computeNormal(),this.area<t){let r,n=0,s=this.edge;do{const u=s.lengthSquared();u>n&&(r=s,n=u),s=s.next}while(s!==this.edge);const o=r.tail().point,a=r.head().point,i=nl([],a,o),c=Math.sqrt(n);Ea(i,i,1/c);const l=rl(this.normal,i);Ea(i,i,-l),tl(this.normal,this.normal,i),Jk(this.normal,this.normal)}}computeCentroid(){this.centroid=[0,0,0];let t=this.edge;do tl(this.centroid,this.centroid,t.head().point),t=t.next;while(t!==this.edge);Ea(this.centroid,this.centroid,1/this.nVertices)}computeNormalAndCentroid(t){typeof t<"u"?this.computeNormalMinArea(t):this.computeNormal(),this.computeCentroid(),this.offset=rl(this.normal,this.centroid)}distanceToPlane(t){return rl(this.normal,t)-this.offset}connectHalfEdges(t,r){let n;if(t.opposite.face===r.opposite.face){const s=r.opposite.face;let o;t===this.edge&&(this.edge=r),s.nVertices===3?(o=r.opposite.prev.opposite,s.mark=Al,n=s):(o=r.opposite.next,s.edge===o.prev&&(s.edge=o),o.prev=o.prev.prev,o.prev.next=o),r.prev=t.prev,r.prev.next=r,r.setOpposite(o),s.computeNormalAndCentroid()}else t.next=r,r.prev=t;return n}mergeAdjacentFaces(t,r){const n=t.opposite,s=n.face;r.push(s),s.mark=Al;let o=t.prev,a=t.next,i=n.prev,c=n.next;for(;o.opposite.face===s;)o=o.prev,c=c.next;for(;a.opposite.face===s;)a=a.next,i=i.prev;let l;for(l=c;l!==i.next;l=l.next)l.face=this;this.edge=a;let u;return u=this.connectHalfEdges(i,a),u&&r.push(u),u=this.connectHalfEdges(o,c),u&&r.push(u),this.computeNormalAndCentroid(),r}collectIndices(){const t=[];let r=this.edge;do t.push(r.head().index),r=r.next;while(r!==this.edge);return t}static createTriangle(t,r,n,s=0){const o=new $p,a=new sl(t,o),i=new sl(r,o),c=new sl(n,o);return a.next=c.prev=i,i.next=a.prev=c,c.next=i.prev=a,o.edge=a,o.computeNormalAndCentroid(s),o}};var rD={VISIBLE:wp,NON_CONVEX:eD,DELETED:Al,Face:tD};const ol=Ia,nD=kk,sD=Vk,Yd=Uk,oD=Xk,{Face:zr,VISIBLE:ds,NON_CONVEX:Wd,DELETED:aD}=rD,iD=1,Zd=2;let cD=class{constructor(t){if(!Array.isArray(t))throw TypeError("input is not a valid array");if(t.length<4)throw Error("cannot build a simplex out of <4 points");this.tolerance=-1,this.nFaces=0,this.nPoints=t.length,this.faces=[],this.newFaces=[],this.claimed=new Yd,this.unclaimed=new Yd,this.vertices=[];for(let r=0;r<t.length;r+=1)this.vertices.push(new oD(t[r],r));this.discardedFaces=[],this.vertexPointIndices=[]}addVertexToFace(t,r){t.face=r,r.outside?this.claimed.insertBefore(r.outside,t):this.claimed.add(t),r.outside=t}removeVertexFromFace(t,r){t===r.outside&&(t.next&&t.next.face===r?r.outside=t.next:r.outside=null),this.claimed.remove(t)}removeAllVerticesFromFace(t){if(t.outside){let r=t.outside;for(;r.next&&r.next.face===t;)r=r.next;return this.claimed.removeChain(t.outside,r),r.next=null,t.outside}}deleteFaceVertices(t,r){const n=this.removeAllVerticesFromFace(t);if(n)if(!r)this.unclaimed.addAll(n);else{let s;for(let o=n;o;o=s)s=o.next,r.distanceToPlane(o.point)>this.tolerance?this.addVertexToFace(o,r):this.unclaimed.add(o)}}resolveUnclaimedPoints(t){let r=this.unclaimed.first();for(let n=r;n;n=r){r=n.next;let s=this.tolerance,o;for(let a=0;a<t.length;a+=1){const i=t[a];if(i.mark===ds){const c=i.distanceToPlane(n.point);if(c>s&&(s=c,o=i),s>1e3*this.tolerance)break}}o&&this.addVertexToFace(n,o)}}computeExtremes(){const t=[],r=[],n=[],s=[];let o,a;for(o=0;o<3;o+=1)n[o]=s[o]=this.vertices[0];for(o=0;o<3;o+=1)t[o]=r[o]=this.vertices[0].point[o];for(o=1;o<this.vertices.length;o+=1){const i=this.vertices[o],c=i.point;for(a=0;a<3;a+=1)c[a]<t[a]&&(t[a]=c[a],n[a]=i);for(a=0;a<3;a+=1)c[a]>r[a]&&(r[a]=c[a],s[a]=i)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t[0]),Math.abs(r[0]))+Math.max(Math.abs(t[1]),Math.abs(r[1]))+Math.max(Math.abs(t[2]),Math.abs(r[2]))),[n,s]}createInitialSimplex(){const t=this.vertices,[r,n]=this.computeExtremes();let s,o,a,i,c=0,l=0;for(a=0;a<3;a+=1){const g=n[a].point[a]-r[a].point[a];g>c&&(c=g,l=a)}const u=r[l],d=n[l];for(c=0,a=0;a<this.vertices.length;a+=1){const g=this.vertices[a];if(g!==u&&g!==d){const y=nD(g.point,u.point,d.point);y>c&&(c=y,s=g)}}const h=sD([],u.point,d.point,s.point),m=ol(u.point,h);for(c=-1,a=0;a<this.vertices.length;a+=1){const g=this.vertices[a];if(g!==u&&g!==d&&g!==s){const y=Math.abs(ol(h,g.point)-m);y>c&&(c=y,o=g)}}const $=[];if(ol(o.point,h)-m<0)for($.push(zr.createTriangle(u,d,s),zr.createTriangle(o,d,u),zr.createTriangle(o,s,d),zr.createTriangle(o,u,s)),a=0;a<3;a+=1){const g=(a+1)%3;$[a+1].getEdge(2).setOpposite($[0].getEdge(g)),$[a+1].getEdge(1).setOpposite($[g+1].getEdge(0))}else for($.push(zr.createTriangle(u,s,d),zr.createTriangle(o,u,d),zr.createTriangle(o,d,s),zr.createTriangle(o,s,u)),a=0;a<3;a+=1){const g=(a+1)%3;$[a+1].getEdge(2).setOpposite($[0].getEdge((3-a)%3)),$[a+1].getEdge(0).setOpposite($[g+1].getEdge(1))}for(a=0;a<4;a+=1)this.faces.push($[a]);for(a=0;a<t.length;a+=1){const g=t[a];if(g!==u&&g!==d&&g!==s&&g!==o){c=this.tolerance;let y;for(i=0;i<4;i+=1){const S=$[i].distanceToPlane(g.point);S>c&&(c=S,y=$[i])}y&&this.addVertexToFace(g,y)}}}reindexFaceAndVertices(){const t=[];for(let r=0;r<this.faces.length;r+=1){const n=this.faces[r];n.mark===ds&&t.push(n)}this.faces=t}collectFaces(t){const r=[];for(let n=0;n<this.faces.length;n+=1){if(this.faces[n].mark!==ds)throw Error("attempt to include a destroyed face in the hull");const s=this.faces[n].collectIndices();if(t)r.push(s);else for(let o=0;o<s.length-2;o+=1)r.push([s[0],s[o+1],s[o+2]])}return r}nextVertexToAdd(){if(!this.claimed.isEmpty()){let t,r,n=0;const s=this.claimed.first().face;for(r=s.outside;r&&r.face===s;r=r.next){const o=s.distanceToPlane(r.point);o>n&&(n=o,t=r)}return t}}computeHorizon(t,r,n,s){this.deleteFaceVertices(n),n.mark=aD;let o;r?o=r.next:o=r=n.getEdge(0);do{const a=o.opposite,i=a.face;i.mark===ds&&(i.distanceToPlane(t)>this.tolerance?this.computeHorizon(t,a,i,s):s.push(o)),o=o.next}while(o!==r)}addAdjoiningFace(t,r){const n=zr.createTriangle(t,r.tail(),r.head());return this.faces.push(n),n.getEdge(-1).setOpposite(r.opposite),n.getEdge(0)}addNewFaces(t,r){this.newFaces=[];let n,s;for(let o=0;o<r.length;o+=1){const a=r[o],i=this.addAdjoiningFace(t,a);n?i.next.setOpposite(s):n=i,this.newFaces.push(i.face),s=i}n.next.setOpposite(s)}oppositeFaceDistance(t){return t.face.distanceToPlane(t.opposite.face.centroid)}doAdjacentMerge(t,r){let n=t.edge,s=!0,o=0;do{if(o>=t.nVertices)throw Error("merge recursion limit exceeded");const a=n.opposite.face;let i=!1;if(r===Zd?(this.oppositeFaceDistance(n)>-this.tolerance||this.oppositeFaceDistance(n.opposite)>-this.tolerance)&&(i=!0):t.area>a.area?this.oppositeFaceDistance(n)>-this.tolerance?i=!0:this.oppositeFaceDistance(n.opposite)>-this.tolerance&&(s=!1):this.oppositeFaceDistance(n.opposite)>-this.tolerance?i=!0:this.oppositeFaceDistance(n)>-this.tolerance&&(s=!1),i){const c=t.mergeAdjacentFaces(n,[]);for(let l=0;l<c.length;l+=1)this.deleteFaceVertices(c[l],t);return!0}n=n.next,o+=1}while(n!==t.edge);return s||(t.mark=Wd),!1}addVertexToHull(t){const r=[];this.unclaimed.clear(),this.removeVertexFromFace(t,t.face),this.computeHorizon(t.point,null,t.face,r),this.addNewFaces(t,r);for(let n=0;n<this.newFaces.length;n+=1){const s=this.newFaces[n];if(s.mark===ds)for(;this.doAdjacentMerge(s,iD););}for(let n=0;n<this.newFaces.length;n+=1){const s=this.newFaces[n];if(s.mark===Wd)for(s.mark=ds;this.doAdjacentMerge(s,Zd););}this.resolveUnclaimedPoints(this.newFaces)}build(){let t;for(this.createInitialSimplex();t=this.nextVertexToAdd();)this.addVertexToHull(t);this.reindexFaceAndVertices()}};var lD=cD;const fD=lD,uD=(e,t={})=>{const r=new fD(e);return r.build(),r.collectFaces(t.skipTriangulation)};var dD=uD;const hD=We,mD=Ke,pD=ot,vD=dD,gD=rf,yD=(...e)=>{if(e=hD(e),e.length===1)return e[0];const t=gD(e),n=vD(t,{skipTriangulation:!0}).map(s=>{const o=s.map(a=>t[a]);return pD.create(o)});return mD.create(n)};var bD=yD;const _D=We,wD=xo,$D=Qe,xD=Ke,ED=ct,AD=Pk,TD=Rk,SD=bD,PD=(...e)=>{if(e=_D(e),e.length===0)throw new Error("wrong number of arguments");if(!wD(e))throw new Error("only hulls of the same type are supported");const t=e[0];return ED.isA(t)?AD(e):$D.isA(t)?TD(e):xD.isA(t)?SD(e):t};var xp=PD;const CD=We,MD=ef,OD=xp,LD=(...e)=>{if(e=CD(e),e.length<2)throw new Error("wrong number of arguments");const t=[];for(let r=1;r<e.length;r++)t.push(OD(e[r-1],e[r]));return MD(t)};var RD=LD,FD={hull:xp,hullChain:RD};const al=ze,Ep=ot,ND=(e,t)=>{const r=Math.abs(Ep.measureArea(t));return Number.isFinite(r)&&r>e},GD=(e,t)=>{let r=t.map(s=>{const o=s.vertices.map(c=>al.snap(al.create(),c,e)),a=[];for(let c=0;c<o.length;c++){const l=(c+1)%o.length;al.equals(o[c],o[l])||a.push(o[c])}const i=Ep.create(a);return s.color&&(i.color=s.color),i});const n=e*e*Math.sqrt(3)/4;return r=r.filter(s=>ND(n,s)),r};var Ap=GD;const kD=zl,ps=ze,ka=ot,DD=e=>{const t=ka.toPoints(e),r=[];for(let n=0;n<t.length;n++){const s=(n+1)%t.length,o={v1:t[n],v2:t[s]};r.push(o)}for(let n=0;n<r.length;n++){const s=(n+1)%t.length;r[n].next=r[s],r[s].prev=r[n]}return r},BD=(e,t)=>{const r=`${t.v1}:${t.v2}`;e.set(r,t)},il=(e,t)=>{const r=`${t.v1}:${t.v2}`;e.delete(r)},ID=(e,t)=>{const r=`${t.v2}:${t.v1}`;return e.get(r)},VD=(e,t,r)=>{let n=e.prev.v1,s=e.prev.v2,o=t.next.v2;const a=Qd(n,s,o,r);n=t.prev.v1,s=t.prev.v2,o=e.next.v2;const i=Qd(n,s,o,r);return[a,i]},zD=ps.create(),UD=ps.create(),Qd=(e,t,r,n)=>{const s=ps.subtract(zD,t,e),o=ps.subtract(UD,r,t);return ps.cross(s,s,o),ps.dot(s,n)},qD=e=>{let t;const r=[];for(;e.next;){const n=e.next;r.push(e.v1),e.v1=null,e.v2=null,e.next=null,e.prev=null,e=n}return r.length>0&&(t=ka.create(r)),t},XD=e=>{if(e.length<2)return e;const t=e[0].plane,r=e.slice(),n=new Map;for(;r.length>0;){const o=r.shift(),a=DD(o);for(let i=0;i<a.length;i++){const c=a[i],l=ID(n,c);if(l){const u=VD(c,l,t);if(u[0]>=0&&u[1]>=0){const d=l.next,h=c.next;c.prev.next=l.next,c.next.prev=l.prev,l.prev.next=c.next,l.next.prev=c.prev,c.v1=null,c.v2=null,c.next=null,c.prev=null,il(n,l),l.v1=null,l.v2=null,l.next=null,l.prev=null;const m=($,g,y)=>{const S={v1:y.v1,v2:g.v2,next:g.next,prev:y.prev};y.prev.next=S,g.next.prev=S,il($,g),g.v1=null,g.v2=null,g.next=null,g.prev=null,il($,y),y.v1=null,y.v2=null,y.next=null,y.prev=null};u[0]===0&&m(n,d,d.prev),u[1]===0&&m(n,h,h.prev)}}else c.next&&BD(n,c)}}const s=[];return n.forEach(o=>{const a=qD(o);a&&s.push(a)}),n.clear(),s},jD=(e,t)=>Math.abs(e[3]-t[3])<15e-8?kD(e,t):!1,HD=(e,t)=>{const r=[];t.forEach(s=>{const o=r.find(a=>jD(a[0],ka.plane(s)));o?o[1].push(s):r.push([ka.plane(s),[s]])});let n=[];return r.forEach(s=>{const o=s[1],a=XD(o);n=n.concat(a)}),n};var YD=HD;const Kd=st,Mr=ze,WD=ot,Xt=e=>`${e}`,Jd=(e,t,r,n,s,o)=>{const a=Xt(n),i=Xt(s),c=`${a}/${i}`,l=`${i}/${a}`;if(e.has(l))return Ma(e,t,r,s,n,null),null;const u={vertex0:n,vertex1:s,polygonindex:o};return e.has(c)?e.get(c).push(u):e.set(c,[u]),t.has(a)?t.get(a).push(c):t.set(a,[c]),r.has(i)?r.get(i).push(c):r.set(i,[c]),c},Ma=(e,t,r,n,s,o)=>{const a=Xt(n),i=Xt(s),c=`${a}/${i}`;let l=-1;const u=e.get(c);for(let d=0;d<u.length;d++){const h=u[d];let m=Xt(h.vertex0);if(m===a&&(m=Xt(h.vertex1),m===i&&!(o!==null&&h.polygonindex!==o))){l=d;break}}u.splice(l,1),u.length===0&&e.delete(c),l=t.get(a).indexOf(c),t.get(a).splice(l,1),t.get(a).length===0&&t.delete(a),l=r.get(i).indexOf(c),r.get(i).splice(l,1),r.get(i).length===0&&r.delete(i)},ZD=e=>{const t=new Map;for(let r=0;r<e.length;r++){const n=e[r],s=n.vertices.length;if(s>=3){let o=n.vertices[0],a=Xt(o);for(let i=0;i<s;i++){let c=i+1;c===s&&(c=0);const l=n.vertices[c],u=Xt(l),d=`${a}/${u}`,h=`${u}/${a}`;if(t.has(h)){const m=t.get(h);m.splice(-1,1),m.length===0&&t.delete(h)}else{const m={vertex0:o,vertex1:l,polygonindex:r};t.has(d)?t.get(d).push(m):t.set(d,[m])}o=l,a=u}}else console.warn("warning: invalid polygon found during insertTjunctions")}if(t.size>0){const r=new Map,n=new Map,s=new Map;for(const[a,i]of t)s.set(a,!0),i.forEach(c=>{const l=Xt(c.vertex0),u=Xt(c.vertex1);r.has(l)?r.get(l).push(a):r.set(l,[a]),n.has(u)?n.get(u).push(a):n.set(u,[a])});const o=e.slice(0);for(;t.size!==0;){for(const i of t.keys())s.set(i,!0);let a=!1;for(;;){const i=Array.from(s.keys());if(i.length===0)break;const c=i[0];let l=!0;if(t.has(c)){const d=t.get(c)[0];for(let h=0;h<2;h++){const m=h===0?d.vertex0:d.vertex1,$=h===0?d.vertex1:d.vertex0,g=Xt(m),y=Xt($);let S=[];h===0?n.has(g)&&(S=n.get(g)):r.has(g)&&(S=r.get(g));for(let N=0;N<S.length;N++){const O=S[N],L=t.get(O)[0],R=h===0?L.vertex0:L.vertex1;if(h===0?L.vertex1:L.vertex0,Xt(R)===y){Ma(t,r,n,m,$,null),Ma(t,r,n,$,m,null),l=!1,h=2,a=!0;break}else{const z=m,J=$,oe=R,ve=Mr.subtract(Mr.create(),oe,z),le=Mr.dot(Mr.subtract(Mr.create(),J,z),ve)/Mr.dot(ve,ve);if(le>0&&le<1){const Pe=Mr.scale(Mr.create(),ve,le);if(Mr.add(Pe,Pe,z),Mr.squaredDistance(Pe,J)<Kd.EPS*Kd.EPS){const ne=L.polygonindex,Ne=o[ne],Ge=Xt(L.vertex1);let bt=-1;for(let Jt=0;Jt<Ne.vertices.length;Jt++)if(Xt(Ne.vertices[Jt])===Ge){bt=Jt;break}const xt=Ne.vertices.slice(0);xt.splice(bt,0,$);const vr=WD.create(xt);o[ne]=vr,Ma(t,r,n,L.vertex0,L.vertex1,ne);const Kt=Jd(t,r,n,L.vertex0,$,ne),gr=Jd(t,r,n,$,L.vertex1,ne);Kt!==null&&s.set(Kt,!0),gr!==null&&s.set(gr,!0),l=!1,h=2,a=!0;break}}}}}}l&&s.delete(c)}if(!a)break}e=o}return t.clear(),e};var QD=ZD;const cl=ze,ll=ot,KD=(e,t,r)=>{const n=t.vertices.length;if(n>3){if(n>4){const a=[0,0,0];t.vertices.forEach(i=>cl.add(a,a,i)),cl.snap(a,cl.divide(a,a,[n,n,n]),e);for(let i=0;i<n;i++){const c=ll.create([a,t.vertices[i],t.vertices[(i+1)%n]]);t.color&&(c.color=t.color),r.push(c)}return}const s=ll.create([t.vertices[0],t.vertices[1],t.vertices[2]]),o=ll.create([t.vertices[0],t.vertices[2],t.vertices[3]]);t.color&&(s.color=t.color,o.color=t.color),r.push(s,o);return}r.push(t)},JD=(e,t)=>{const r=[];return t.forEach(n=>{KD(e,n,r)}),r};var e7=JD;const t7=We,r7=cn,n7=Qe,Tp=Ke,s7=ct,o7=Ap,a7=YD,i7=QD,c7=e7,l7=(e,t)=>t,f7=(e,t)=>t,u7=(e,t)=>{const r={snap:!1,simplify:!1,triangulate:!1},{snap:n,simplify:s,triangulate:o}=Object.assign({},r,e),a=r7(t);let i=Tp.toPolygons(t);n&&(i=o7(a,i)),s&&(i=a7(a,i)),o&&(i=i7(i),i=c7(a,i));const c=Object.assign({},t);return c.polygons=i,c},d7=(e,...t)=>{if(t=t7(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>{if(s7.isA(n))return l7(e,n);if(n7.isA(n))return f7(e,n);if(Tp.isA(n))return u7(e,n);throw new Error("invalid geometry")});return r.length===1?r[0]:r};var h7=d7;const m7=We,On=rt,Tl=Qe,Sl=Ke,Pl=ct,nf=cn,p7=Ap,v7=e=>{const t=nf(e),n=Pl.toPoints(e).map(s=>On.snap(On.create(),s,t));return Pl.create(n)},g7=e=>{const t=nf(e);let n=Tl.toSides(e).map(s=>[On.snap(On.create(),s[0],t),On.snap(On.create(),s[1],t)]);return n=n.filter(s=>!On.equals(s[0],s[1])),Tl.create(n)},y7=e=>{const t=nf(e),r=Sl.toPolygons(e),n=p7(t,r);return Sl.create(n)},b7=(...e)=>{if(e=m7(e),e.length===0)throw new Error("wrong number of arguments");const t=e.map(r=>Pl.isA(r)?v7(r):Tl.isA(r)?g7(r):Sl.isA(r)?y7(r):r);return t.length===1?t[0]:t};var _7=b7,w7={generalize:h7,snap:_7,retessellate:Eo};const $7=(e,t,r)=>{for(e=e.slice();e.length<r;)e.push(t);return e};var x7=$7;const E7=We,eh=x7,Sp=ql,{translate:A7}=Ln,T7=e=>{if(!Array.isArray(e.modes)||e.modes.length>3)throw new Error("align(): modes must be an array of length <= 3");if(e.modes=eh(e.modes,"none",3),e.modes.filter(t=>["center","max","min","none"].includes(t)).length!==3)throw new Error('align(): all modes must be one of "center", "max" or "min"');if(!Array.isArray(e.relativeTo)||e.relativeTo.length>3)throw new Error("align(): relativeTo must be an array of length <= 3");if(e.relativeTo=eh(e.relativeTo,0,3),e.relativeTo.filter(t=>Number.isFinite(t)||t==null).length!==3)throw new Error("align(): all relativeTo values must be a number, or null.");if(typeof e.grouped!="boolean")throw new Error("align(): grouped must be a boolean value.");return e},S7=(e,t,r)=>{for(let n=0;n<3;n++)e[n]==null&&(t[n]==="center"?e[n]=(r[0][n]+r[1][n])/2:t[n]==="max"?e[n]=r[1][n]:t[n]==="min"&&(e[n]=r[0][n]));return e},th=(e,t,r)=>{const n=Sp(e),s=[0,0,0];for(let o=0;o<3;o++)t[o]==="center"?s[o]=r[o]-(n[0][o]+n[1][o])/2:t[o]==="max"?s[o]=r[o]-n[1][o]:t[o]==="min"&&(s[o]=r[o]-n[0][o]);return A7(s,e)},P7=(e,...t)=>{e=Object.assign({},{modes:["center","center","min"],relativeTo:[0,0,0],grouped:!1},e),e=T7(e);let{modes:n,relativeTo:s,grouped:o}=e;if(t=E7(t),t.length===0)throw new Error("align(): No geometries were provided to act upon");if(s.filter(a=>a==null).length){const a=Sp(t);s=S7(s,n,a)}return o?t=th(t,n,s):t=t.map(a=>th(a,n,s)),t.length===1?t[0]:t};var C7=P7;const M7=We,O7=Qe,L7=Ke,R7=ct,F7=Bn,{translate:N7}=Ln,fl=(e,t)=>{const r={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:n,relativeTo:s}=Object.assign({},r,e),o=F7(t),a=[0,0,0];return n[0]&&(a[0]=s[0]-(o[0][0]+(o[1][0]-o[0][0])/2)),n[1]&&(a[1]=s[1]-(o[0][1]+(o[1][1]-o[0][1])/2)),n[2]&&(a[2]=s[2]-(o[0][2]+(o[1][2]-o[0][2])/2)),N7(a,t)},si=(e,...t)=>{const r={axes:[!0,!0,!0],relativeTo:[0,0,0]},{axes:n,relativeTo:s}=Object.assign({},r,e);if(t=M7(t),t.length===0)throw new Error("wrong number of arguments");if(s.length!==3)throw new Error("relativeTo must be an array of length 3");e={axes:n,relativeTo:s};const o=t.map(a=>R7.isA(a)||O7.isA(a)||L7.isA(a)?fl(e,a):a);return o.length===1?o[0]:o},G7=(...e)=>si({axes:[!0,!1,!1]},e),k7=(...e)=>si({axes:[!1,!0,!1]},e),D7=(...e)=>si({axes:[!1,!1,!0]},e);var Aa={center:si,centerX:G7,centerY:k7,centerZ:D7};const B7=We,rh=ft,nh=Qe,sh=Ke,oh=ct,oi=(e,...t)=>{if(!Array.isArray(e))throw new Error("factors must be an array");if(t=B7(t),t.length===0)throw new Error("wrong number of arguments");for(e=e.slice();e.length<3;)e.push(1);if(e[0]<=0||e[1]<=0||e[2]<=0)throw new Error("factors must be positive");const r=rh.fromScaling(rh.create(),e),n=t.map(s=>oh.isA(s)?oh.transform(r,s):nh.isA(s)?nh.transform(r,s):sh.isA(s)?sh.transform(r,s):s);return n.length===1?n[0]:n},I7=(e,...t)=>oi([e,1,1],t),V7=(e,...t)=>oi([1,e,1],t),z7=(e,...t)=>oi([1,1,e],t);var Ta={scale:oi,scaleX:I7,scaleY:V7,scaleZ:z7};const U7=We,ah=Qe,ih=Ke,ch=ct,q7=(e,...t)=>{if(t=U7(t),t.length===0)throw new Error("wrong number of arguments");const r=t.map(n=>ch.isA(n)?ch.transform(e,n):ah.isA(n)?ah.transform(e,n):ih.isA(n)?ih.transform(e,n):n);return r.length===1?r[0]:r};var X7=q7,j7={align:C7,center:Aa.center,centerX:Aa.centerX,centerY:Aa.centerY,centerZ:Aa.centerZ,mirror:co.mirror,mirrorX:co.mirrorX,mirrorY:co.mirrorY,mirrorZ:co.mirrorZ,rotate:fo.rotate,rotateX:fo.rotateX,rotateY:fo.rotateY,rotateZ:fo.rotateZ,scale:Ta.scale,scaleX:Ta.scaleX,scaleY:Ta.scaleY,scaleZ:Ta.scaleZ,transform:X7,translate:Ln.translate,translateX:Ln.translateX,translateY:Ln.translateY,translateZ:Ln.translateZ},Ss={colors:JS,curves:pP,geometries:Bl,maths:ZC,measurements:hM,primitives:WL,text:aR,utils:dp,booleans:MN,expansions:PG,extrusions:yk,hulls:FD,modifiers:w7,transforms:j7};const{geometries:ul}=Ss,H7=(e,t)=>{t.statusCallback&&t.statusCallback({progress:0});const r=new ArrayBuffer(4),n=new Int32Array(r,0,1),s=new Int8Array(r,0,4);if(n[0]=287454020,s[0]!==68)throw new Error("Binary STL output is currently only supported on little-endian (Intel) processors");let o=0,a=0;e.forEach((y,S)=>{ul.geom3.toPolygons(y).forEach(O=>{const L=O.vertices.length,R=L>=3?L-2:0;o+=R,a+=1})});const i=new Uint8Array(80);for(let y=0;y<80;y++)i[y]=65;const c=new Uint32Array(1);c[0]=o;const l=new ArrayBuffer(50*o),u=new Int8Array(l),d=new ArrayBuffer(50),h=new Int8Array(d),m=new Float32Array(d,0,12),$=new Uint16Array(d,48,1);let g=0;return e.forEach(y=>{ul.geom3.toPolygons(y).forEach((N,O)=>{const L=N.vertices,R=L.length,F=ul.poly3.plane(N);for(let z=0;z<R-2;z++){m[0]=F[0],m[1]=F[1],m[2]=F[2];let J=3;for(let oe=0;oe<3;oe++){const ve=oe+(oe>0?z:0),le=L[ve];m[J++]=le[0],m[J++]=le[1],m[J++]=le[2]}$[0]=0,u.set(h,g),g+=50}t.statusCallback&&t.statusCallback({progress:100*O/a})})}),t.statusCallback&&t.statusCallback({progress:100}),[i.buffer,c.buffer,l]};var Y7={serializeBinary:H7};const{geometries:Pp}=Ss,W7=(e,t)=>{t.statusCallback&&t.statusCallback({progress:0});const r=`solid JSCAD
${Z7(e,t)}
endsolid JSCAD
`;return t.statusCallback&&t.statusCallback({progress:100}),[r]},Z7=(e,t)=>{const r=[];return e.forEach((n,s)=>{r.push(Q7(n)),t.statusCallback&&t.statusCallback({progress:100*s/e.length})}),r.join(`
`)},Q7=(e,t)=>{const r=[];return Pp.geom3.toPolygons(e).forEach((s,o)=>{r.push(K7(s))}),r.join(`
`)},Cp=e=>`${e[0]} ${e[1]} ${e[2]}`,dl=e=>`vertex ${Cp(e)}`,K7=e=>{const t=[];if(e.vertices.length>=3){const r=dl(e.vertices[0]);for(let n=0;n<e.vertices.length-2;n++){const s=`facet normal ${Cp(Pp.poly3.plane(e))}
outer loop
${r}
${dl(e.vertices[n+1])}
${dl(e.vertices[n+2])}
endloop
endfacet`;t.push(s)}}return t.join(`
`)};var J7={serializeText:W7};const{geometries:eB,modifiers:tB}=Ss,{flatten:rB,toArray:nB}=Cl,{serializeBinary:sB}=Y7,{serializeText:oB}=J7,aB="application/sla",iB=(e,...t)=>{e=Object.assign({},{binary:!0,statusCallback:null},e),t=rB(t);let n=t.filter(s=>eB.geom3.isA(s));if(n.length===0)throw new Error("only 3D geometries can be serialized to STL");return t.length!==n.length&&console.warn("some objects could not be serialized to STL"),n=nB(tB.generalize({snap:!0,triangulate:!0},n)),e.binary?sB(n,e):oB(n,e)};var cB={mimeType:aB,serialize:iB};const lB=x5(cB),fB=e=>{const t=lB.serialize({binary:!0},e);return new Blob(t)},uB=e=>dB(e)?Ss.booleans.subtract(hB(e),mB(e)):void 0,dB=e=>e.innerHeight>0&&e.innerLength>0&&e.innerWidth>0&&e.wallThickness>0,hB=e=>Ss.primitives.cuboid({size:[e.wallThickness*2+e.innerLength,e.wallThickness*2+e.innerWidth,e.wallThickness+e.innerHeight]}),mB=e=>Ss.primitives.cuboid({size:[e.innerLength,e.innerWidth,e.innerHeight],center:[0,0,e.wallThickness/2]}),pB=(e,t="model")=>{const r=URL.createObjectURL(e),n=document.createElement("a");n.href=r,n.download=t,n.click(),URL.revokeObjectURL(r)};function vB(e){let t,r,n,s,o,a,i,c,l;r=new w5({});function u(h){e[3](h)}let d={generate:e[2]};return e[0]!==void 0&&(d.parameters=e[0]),o=new L3({props:d}),an.push(()=>ao(o,"parameters",u)),c=new $3({props:{model:e[1]}}),{c(){t=lr("main"),wr(r.$$.fragment),n=$r(),s=lr("div"),wr(o.$$.fragment),i=$r(),wr(c.$$.fragment),Vt(s,"class","container svelte-1xvngkg"),Vt(t,"class","svelte-1xvngkg")},m(h,m){Fr(h,t,m),hr(r,t,null),Ot(t,n),Ot(t,s),hr(o,s,null),Ot(s,i),hr(c,s,null),l=!0},p(h,[m]){const $={};!a&&m&1&&(a=!0,$.parameters=h[0],oo(()=>a=!1)),o.$set($);const g={};m&2&&(g.model=h[1]),c.$set(g)},i(h){l||(cr(r.$$.fragment,h),cr(o.$$.fragment,h),cr(c.$$.fragment,h),l=!0)},o(h){dr(r.$$.fragment,h),dr(o.$$.fragment,h),dr(c.$$.fragment,h),l=!1},d(h){h&&xr(t),mr(r),mr(o),mr(c)}}}function gB(e,t,r){let n,s={innerLength:0,innerWidth:0,innerHeight:0,wallThickness:0};const o=()=>{const i=fB(n);pB(i,"Box.stl")};function a(i){s=i,r(0,s)}return e.$$.update=()=>{e.$$.dirty&1&&r(1,n=uB(s))},[s,n,o,a]}class yB extends Dn{constructor(t){super(),kn(this,t,gB,vB,Gn,{})}}new yB({target:document.getElementById("app")});
